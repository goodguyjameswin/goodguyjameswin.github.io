{"meta":{"title":"zt's blog","subtitle":null,"description":"没有记流水帐的习惯~","author":"Terry Joe","url":"http://goodguyjameswin.github.io"},"pages":[{"title":"","date":"2021-09-02T07:22:26.499Z","updated":"2021-09-02T07:21:51.283Z","comments":true,"path":"404.html","permalink":"http://goodguyjameswin.github.io/404.html","excerpt":"","text":"页面没有找到 | zt's Blog body { background: #00c4b6; } #not_found { position: fixed; top: 50%; left: 50%; transform: translateY(-50%) translateX(-50%) scale(1.2); width: 80%; height: auto; } (function () { var lastTime = 0; var vendors = ['ms', 'moz', 'webkit', 'o']; for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) { window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame']; window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] || window[vendors[x] + 'CancelRequestAnimationFrame']; } if (!window.requestAnimationFrame) window.requestAnimationFrame = function (callback, element) { var currTime = new Date().getTime(); var timeToCall = Math.max(0, 16 - (currTime - lastTime)); var id = window.setTimeout(function () { callback(currTime + timeToCall); }, timeToCall); lastTime = currTime + timeToCall; return id; }; if (!window.cancelAnimationFrame) window.cancelAnimationFrame = function (id) { clearTimeout(id); }; })(); //math2 utils var Math2 = {}; Math2.random = function (t, n) { return Math.random() * (n - t) + t; }, Math2.map = function (t, n, r, a, o) { return (o - a) * ((t - n) / (r - n)) + a; }, Math2.randomPlusMinus = function (t) { return t = t ? t : .5, Math.random() > t ? -1 : 1; }, Math2.randomInt = function (t, n) { return n += 1, Math.floor(Math.random() * (n - t) + t); }, Math2.randomBool = function (t) { return t = t ? t : .5, Math.random() < t ? !0 : !1; }, Math2.degToRad = function (t) { return rad = t * Math.PI / 180, rad; }, Math2.radToDeg = function (t) { return deg = 180 / (Math.PI * t), deg; }, Math2.rgbToHex = function (t) { function n(t) { return (\"0\" + parseInt(t).toString(16)).slice(-2); } t = t.match(/^rgb((d+),s*(d+),s*(d+))$/); var r = n(t[1]) + n(t[2]) + n(t[3]); return r.toUpperCase(); }, Math2.distance = function (t, n, r, a) { return Math.sqrt((r - t) * (r - t) + (a - n) * (a - n)); }; //mouse var mousePos = { x: 0, y: 0 }; window.onmousemove = function (e) { e = e || window.event; var pageX = e.pageX; var pageY = e.pageY; if (pageX === undefined) { pageX = e.clientX + document.body.scrollLeft + document.documentElement.scrollLeft; pageY = e.clientY + document.body.scrollTop + document.documentElement.scrollTop; } mousePos = { x: pageX, y: pageY }; }; var options = { width: window.innerWidth, height: window.innerHeight, keyword: \"404\", density: 10, densityText: 3, minDist: 20 }; // initialize canvas var canvas = document.createElement('canvas'); canvas.width = options.width; canvas.height = options.height; canvas.style.width = options.width / 2; canvas.style.height = options.height / 2; canvas.getContext('2d').scale(2, 2); var renderer = new PIXI.autoDetectRenderer(options.width, options.height, { transparent: true }); var stage = new PIXI.Stage(\"0X000000\", true); document.body.appendChild(renderer.view); renderer.view.id = \"not_found\"; var imageData = false; var particles = []; function init() { positionParticles(); positionText(); } function positionParticles() { var canvas = document.createElement(\"canvas\"); canvas.width = 500; canvas.height = 350; var context = canvas.getContext(\"2d\"); context.fillStyle = \"#000000\"; context.font = \"300px 'Arial', sans-serif\"; context.fillText(options.keyword, 0, 250); var imageData = context.getImageData(0, 0, 350, 500); data = imageData.data; // Iterate each row and column for (var i = 0; i < imageData.height; i += options.density) { for (var j = 0; j < imageData.width; j += options.density) { // Get the color of the pixel var color = data[j * (imageData.width * 4) + i * 4 - 1]; // If the color is black, draw pixels if (color == 255) { var newPar = particle(); newPar.setPosition(i, j); particles.push(newPar); stage.addChild(newPar); } } } } function positionText() { var canvas = document.createElement(\"canvas\"); canvas.width = 400; canvas.height = 200; var context = canvas.getContext(\"2d\"); context.fillStyle = \"#000000\"; context.font = \"80px 'Arial', sans-serif\"; context.fillText(\"Not Found\", 0, 80); var imageData = context.getImageData(0, 0, 400, 400); data = imageData.data; // Iterate each row and column for (var i = 0; i < imageData.height; i += options.densityText) { for (var j = 0; j < imageData.width; j += options.densityText) { // Get the color of the pixel var color = data[j * (imageData.width * 4) + i * 4 - 1]; // If the color is black, draw pixels if (color == 255) { var newPar = particle(true); newPar.setPosition(i, j); particles.push(newPar); stage.addChild(newPar); } } } } function particle(text) { $this = new PIXI.Graphics(); if (text == true) { $this.text = true; } $this.beginFill(0XFFFFFF); var radius; $this.radius = radius = $this.text ? Math.random() * 3.5 : Math.random() * 10.5; $this.drawCircle(0, 0, radius); $this.size = this.radius; $this.x = -this.width; $this.y = -this.height; $this.free = false; $this.timer = Math2.randomInt(0, 100); $this.v = Math2.randomPlusMinus() * Math2.random(.5, 1); $this.hovered = false; $this.alpha = Math2.randomInt(10, 100) / 100; $this.vy = -5 + parseInt(Math.random() * 10) / 2; $this.vx = -4 + parseInt(Math.random() * 8); $this.setPosition = function (x, y) { if ($this.text) { $this.x = x + (options.width / 2 - 180); $this.y = y + (options.height / 2 + 100); } else { $this.x = x + (options.width / 2 - 250); $this.y = y + (options.height / 2 - 175); } }; return $this; } function update() { renderer.render(stage); for (i = 0; i < particles.length; i++) { var p = particles[i]; if (mousePos.x > p.x && mousePos.x < p.x + p.size && mousePos.y > p.y && mousePos.y < p.y + p.size) { p.hovered = true; } p.scale.x = p.scale.y = scale = Math.max(Math.min(2.5 - Math2.distance(p.x, p.y, mousePos.x, mousePos.y) / 160, 160), 1); p.x = p.x + .2 * Math.sin(p.timer * .15); p.y = p.y + .2 * Math.cos(p.timer * .15); p.timer = p.timer + p.v; } window.requestAnimationFrame(update); } init(); update();"},{"title":"bangumi","date":"2021-09-04T13:32:48.000Z","updated":"2021-09-08T00:52:34.864Z","comments":false,"path":"bangumi/index.html","permalink":"http://goodguyjameswin.github.io/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"categories","date":"2021-09-04T16:40:09.000Z","updated":"2021-09-11T09:08:23.098Z","comments":false,"path":"categories/index.html","permalink":"http://goodguyjameswin.github.io/categories/index.html","excerpt":"","text":"","keywords":"分类图"},{"title":"links","date":"2021-09-04T15:11:06.000Z","updated":"2021-09-08T00:53:06.388Z","comments":false,"path":"links/index.html","permalink":"http://goodguyjameswin.github.io/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"comment","date":"2021-09-04T15:13:48.000Z","updated":"2021-09-08T00:52:58.243Z","comments":true,"path":"comment/index.html","permalink":"http://goodguyjameswin.github.io/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"about","date":"2021-09-04T14:14:36.000Z","updated":"2021-09-08T00:52:21.259Z","comments":false,"path":"about/index.html","permalink":"http://goodguyjameswin.github.io/about/index.html","excerpt":"","text":"[WHUTのTerryJoe] 与&nbsp; Kirito&nbsp; （ Asuna ） 对话中... bot_ui_ini()","keywords":"关于我"},{"title":"music","date":"2021-09-04T15:14:28.000Z","updated":"2021-09-08T00:53:14.590Z","comments":false,"path":"music/index.html","permalink":"http://goodguyjameswin.github.io/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"tags","date":"2021-09-05T15:13:48.000Z","updated":"2021-09-11T09:08:30.171Z","comments":false,"path":"tags/index.html","permalink":"http://goodguyjameswin.github.io/tags/index.html","excerpt":"","text":"","keywords":"标签云"},{"title":"rss","date":"2021-09-04T15:09:03.000Z","updated":"2021-09-08T00:53:21.547Z","comments":true,"path":"rss/index.html","permalink":"http://goodguyjameswin.github.io/rss/index.html","excerpt":"","text":""},{"title":"video","date":"2021-09-04T15:14:38.000Z","updated":"2021-09-08T00:53:48.250Z","comments":false,"path":"video/index.html","permalink":"http://goodguyjameswin.github.io/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"}],"posts":[{"title":"形状模板匹配的开源工程调试记录","slug":"形状模板匹配的开源工程调试记录","date":"2021-09-15T02:13:12.000Z","updated":"2021-09-15T04:56:08.164Z","comments":false,"path":"2021/09/15/形状模板匹配的开源工程调试记录/","link":"","permalink":"http://goodguyjameswin.github.io/2021/09/15/形状模板匹配的开源工程调试记录/","excerpt":"","text":"环境配置新建VS空工程，然后在VS-视图-属性管理器，配置opencv环境，VC++目录-包含目录添加： ..\\opencv\\build\\include ..\\opencv\\build\\include\\opencv ..\\opencv\\build\\include\\opencv2 VC++目录-库目录添加： ..\\opencv\\build\\x64\\vc15\\lib 链接器-输入-附加依赖项添加： opencv_world346d.lib 将原工程根目录下的源文件和头文件添加到新建VS工程里，修改fusion.h和line2Dup.h文件里的路径： #include &quot;MIPP/mipp.h&quot; // for SIMD in different platforms 修改test.cpp里的prefix变量路径，指向资源文件： static std::string prefix = &quot;../test/&quot;; api调用原作者分别对模板做了角度、尺度方面的测试，以及noise_test（NMS筛选）。这里假设模板是工业器件，且由于拍摄角度和器件摆放位置的随机性，需要简单写个my_test函数来调用api void my_test(string mode = &quot;test&quot;, bool use_rot = true) { int num_feature = 16; // 特征点数量 line2Dup::Detector detector(num_feature, { 4, 8 }); if (mode != &quot;test&quot;) { Mat img = imread(prefix + &quot;case3/train.jpg&quot;); // 训练图片 assert(!img.empty() &amp;&amp; &quot;check your img path&quot;); // crop the template from the original train image Rect roi(90, 35, 65, 35); img = img(roi).clone(); Mat mask = Mat(img.size(), CV_8UC1, { 255 }); // padding to avoid rotating out int padding = 25; cv::Mat padded_img = cv::Mat(img.rows + 2 * padding, img.cols + 2 * padding, img.type(), cv::Scalar::all(0)); img.copyTo(padded_img(Rect(padding, padding, img.cols, img.rows))); cv::Mat padded_mask = cv::Mat(mask.rows + 2 * padding, mask.cols + 2 * padding, mask.type(), cv::Scalar::all(0)); mask.copyTo(padded_mask(Rect(padding, padding, img.cols, img.rows))); shape_based_matching::shapeInfo_producer shapes(padded_img, padded_mask); shapes.angle_range = { 0, 360 }; // 模板库尺度范围 shapes.angle_step = 1; // 模板库尺度步长 shapes.scale_range = { 0.5f, 1.5f }; // 模板库角度范围 shapes.scale_step = 0.1f; // 模板库角度步长 //shapes.scale_range = { 1.0f }; shapes.produce_infos(); std::vector&lt;shape_based_matching::shapeInfo_producer::Info&gt; infos_have_templ; string class_id = &quot;gongjian&quot;; // 模板类名 bool is_first = true; // for other scales you want to re-extract points: // set shapes.scale_range then produce_infos; set is_first = false; int first_id = 0; float first_angle = 0; float first_scale = 0; for (auto&amp; info : shapes.infos) { Mat to_show = shapes.src_of(info); /********************/ // 通用场景 std::cout &lt;&lt; &quot;\\ninfo.angle: &quot; &lt;&lt; info.angle &lt;&lt; std::endl; int templ_id = detector.addTemplate(shapes.src_of(info), class_id, shapes.mask_of(info), int(num_feature * info.scale)); // todo: 模板图尺度没有变化的场景 //（第一次需要成功记录模板，尽量保证模板完整，轮廓层次分明） //（如果报错数组越界，先尝试改善模板图片质量，不行再尝试调小num_feature的值，但建议至少为8） /*std::cout &lt;&lt; &quot;\\ninfo.angle: &quot; &lt;&lt; info.angle &lt;&lt; std::endl; int templ_id; if (is_first) { templ_id = detector.addTemplate(shapes.src_of(info), class_id, shapes.mask_of(info), int(num_feature * info.scale)); first_id = templ_id; first_angle = info.angle; first_scale = info.scale; if (use_rot) is_first = false; } else { templ_id = detector.addTemplate_rotate(class_id, first_id, info.angle - first_angle, { shapes.src.cols / 2.0f, shapes.src.rows / 2.0f }); }*/ /********************/ std::cout &lt;&lt; &quot;templ_id: &quot; &lt;&lt; templ_id &lt;&lt; std::endl; if (templ_id != -1) { auto templ = detector.getTemplates(&quot;gongjian&quot;, templ_id); for (int i = 0; i &lt; templ[0].features.size(); i++) { auto feat = templ[0].features[i]; cv::circle(to_show, { feat.x + templ[0].tl_x, feat.y + templ[0].tl_y }, 3, { 0, 0, 255 }, -1); } infos_have_templ.push_back(info); // will be faster if not showing this imshow(&quot;train&quot;, to_show); waitKey(1); } if (fabs(info.scale - first_scale) &gt; 0.002f) { is_first = true; std::cout &lt;&lt; &quot;info_scale: &quot; &lt;&lt; info.scale &lt;&lt; std::endl; } } detector.writeClasses(prefix + &quot;case3/%s_templ.yaml&quot;); // 模板库 shapes.save_infos(infos_have_templ, prefix + &quot;case3/gongjian_info.yaml&quot;); // 模板信息 std::cout &lt;&lt; &quot;train end&quot; &lt;&lt; std::endl &lt;&lt; std::endl; } else if (mode == &quot;test&quot;) { std::vector&lt;std::string&gt; ids; ids.push_back(&quot;gongjian&quot;); detector.readClasses(ids, prefix + &quot;case3/%s_templ.yaml&quot;); // angle &amp; scale are saved here, fetched by match id auto infos = shape_based_matching::shapeInfo_producer::load_infos(prefix + &quot;case3/gongjian_info.yaml&quot;); Mat test_img = imread(prefix + &quot;case3/ori.jpg&quot;); // 测试图片 assert(!test_img.empty() &amp;&amp; &quot;check your img path&quot;); // padding to avoid rotating out int padding = 150; cv::Mat padded_img = cv::Mat(test_img.rows + 2 * padding, test_img.cols + 2 * padding, test_img.type(), cv::Scalar::all(0)); test_img.copyTo(padded_img(Rect(padding, padding, test_img.cols, test_img.rows))); int stride = 32; int n = padded_img.rows / stride; int m = padded_img.cols / stride; Rect roi(0, 0, stride * m, stride * n); Mat img = padded_img(roi).clone(); assert(img.isContinuous()); // cvtColor(img, img, CV_BGR2GRAY); // todo:训练模板用灰度图，测试图片也用灰度图，然后观察推理速度和效果 std::cout &lt;&lt; &quot;test img size: &quot; &lt;&lt; img.rows * img.cols &lt;&lt; std::endl &lt;&lt; std::endl; // check time span auto start_time = GetTickCount(); //Timer timer; auto matches = detector.match(img, 90, ids); // 匹配阈值 //timer.out(); std::cout &lt;&lt; &quot;matches.size(): &quot; &lt;&lt; matches.size() &lt;&lt; std::endl; vector&lt;Rect&gt; boxes; vector&lt;float&gt; scores; vector&lt;int&gt; idxs; for (auto match : matches) { Rect box; box.x = match.x; box.y = match.y; auto templ = detector.getTemplates(&quot;gongjian&quot;, match.template_id); box.width = templ[0].width; box.height = templ[0].height; boxes.push_back(box); scores.push_back(match.similarity); } cv_dnn::NMSBoxes(boxes, scores, 90, 0, idxs); // 筛选阈值 auto end_time = GetTickCount(); cout &lt;&lt; &quot;匹配算法耗时：&quot; &lt;&lt; (end_time - start_time) &lt;&lt; &quot;ms.&quot; &lt;&lt; endl; if (img.channels() == 1) cvtColor(img, img, CV_GRAY2BGR); for (auto idx : idxs) { auto match = matches[idx]; /*size_t top5 = 10; if (top5 &gt; matches.size()) top5 = matches.size(); for (size_t i = 0; i &lt; top5; i++) { auto match = matches[i];*/ auto templ = detector.getTemplates(&quot;gongjian&quot;, // 读取训练好的模板类 match.template_id); // 65 is width of template image, 35 is height of template image // 25 is padding when training // tl_x/y: template croping topleft corner when training float x_scaled = 60 / 2.0f * infos[match.template_id].scale; float y_scaled = 35 / 2.0f * infos[match.template_id].scale; // scaling won&#39;t affect this, because it has been determined by warpAffine // cv::warpAffine(src, dst, rot_mat, src.size()); last param float train_img_half_width = 60 / 2.0f + 25; float train_img_half_height = 35 / 2.0f + 25; // center x,y of train_img in test img float x = match.x - templ[0].tl_x + train_img_half_width; float y = match.y - templ[0].tl_y + train_img_half_height; cv::Vec3b randColor; randColor[0] = rand() % 155 + 100; randColor[1] = rand() % 155 + 100; randColor[2] = rand() % 155 + 100; for (int i = 0; i &lt; templ[0].features.size(); i++) { auto feat = templ[0].features[i]; cv::circle(img, { feat.x + match.x, feat.y + match.y }, 3, randColor, -1); } cv::putText(img, to_string(int(round(match.similarity))), Point(match.x + x_scaled - 10, match.y - 3), FONT_HERSHEY_PLAIN, 2, randColor); cv::RotatedRect rotatedRectangle({ x, y }, { 2 * x_scaled, 2 * y_scaled }, -infos[match.template_id].angle); cv::Point2f vertices[4]; rotatedRectangle.points(vertices); for (int i = 0; i &lt; 4; i++) { int next = (i + 1 == 4) ? 0 : (i + 1); cv::line(img, vertices[i], vertices[next], randColor, 2); } std::cout &lt;&lt; &quot;\\nmatch.template_id: &quot; &lt;&lt; match.template_id &lt;&lt; std::endl; std::cout &lt;&lt; &quot;match.similarity: &quot; &lt;&lt; match.similarity &lt;&lt; std::endl; } imshow(&quot;img&quot;, img); waitKey(0); std::cout &lt;&lt; &quot;test end&quot; &lt;&lt; std::endl &lt;&lt; std::endl; } } 效果训练 测试","categories":[{"name":"技术","slug":"技术","permalink":"http://goodguyjameswin.github.io/categories/技术/"}],"tags":[{"name":"开源项目","slug":"开源项目","permalink":"http://goodguyjameswin.github.io/tags/开源项目/"},{"name":"out-of-date","slug":"out-of-date","permalink":"http://goodguyjameswin.github.io/tags/out-of-date/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://goodguyjameswin.github.io/categories/技术/"}]},{"title":"深入理解计算机系统","slug":"深入理解计算机系统","date":"2021-09-10T01:27:31.000Z","updated":"2021-09-15T01:58:32.684Z","comments":false,"path":"2021/09/10/深入理解计算机系统/","link":"","permalink":"http://goodguyjameswin.github.io/2021/09/10/深入理解计算机系统/","excerpt":"","text":"模仿我喜欢的一个演员邹兆龙的一段反派戏里一句台词，“买了不吃是不是不给面子啊？”，引申一下，📕：“买了不看是不是不给面子啊？” 哈哈毕竟这本书100多老贵了。。 计算机系统漫游 预处理器根据#开头的命令，修改原始的C程序。比如 #include &lt;stdio.h&gt; 告诉预处理器读取系统头文件stdio.h的内容，并把它直接插入到程序文本中，得到另一个C程序 编译器将文件翻译成一个汇编语言程序，汇编器将文件翻译成机器语言指令，并打包成可重定位目标程序 每个C编译器都提供标准C库中的函数，它们存在于单独的预编译好了的目标文件中，这些文件必须以某种方式合并到我们的程序中，链接器就负责这种合并，最后得到一个可执行目标文件 贯穿整个系统的是一组电子管道，总线，总线通常被设计成定长的字节块，也就是字。字中的字节数（即字长）是一个系统的基本参数，各个系统都不尽相同 每个I/O设备都通过一个控制器或适配器与I/O总线相连，控制器是I/O设备本身或者系统的主印制电路板（通常叫主板）上的芯片组，而适配器则是一块插在主板插槽上的卡，它们的功能都是在I/O总线和I/O设备之间传递信息 存储器是一个线性的字节数组，每个字节都有唯一的地址（数组索引），这些地址是从零开始的 寄存器文件是一个小的存储设备，由一些单个字长的寄存器组成，每个寄存器都有唯一的名字 CPU处理器的核心是一个大小为一个字的存储设备（或寄存器），称为程序计数器（PC），在任何时刻，PC都指向主存中的某条机器语言指令（即含有该条指令的地址） 指令集架构描述的是每条机器代码指令的效果；而微体系结构描述的是处理器实际上是如何实现的 从一个进程到另一个进程的转换是由操作系统内核（kernel）管理的，内核是操作系统代码常驻主存的部分。内核不是一个独立的进程，它是处理全部进程所用代码和数据结构的集合 超线程，称为同时多线程，允许一个CPU执行多个控制流的技术，它涉及CPU某些硬件有多个备份，比如程序计数器和寄存器文件，而其他硬件部分只有一份，比如执行浮点算术运算的单元。超线程的处理器可以在单个周期的基础上决定要执行哪一个线程 信息的表示和处理大多数计算机使用8位的块，或者字节（byte），作为最小的可寻址的内存单位，而不是访问内存中单独的位，多字节对象都被存储为连续的字节序列，对象的地址为所使用字节中最小的地址 由于表示的精度有限，浮点运算是不可结合的。整数的表示虽然只能编码一个相对较小的数值范围，但这种表示是精确的，浮点数虽然可以编码一个较大的数值范围，但这种表示只是近似的 对于一个字长为w位的机器而言，虚拟地址的范围为0~2的w次方-1，程序最多访问2的w次方个字节 大多数64位机器也可以运行为32位机器编译的程序，程序称为“32位程序”、“64位程序”时，区别在于该程序是如何编译的，而不是其运行的机器类型 指针使用程序的全字长。顺序存储对象时，最低有效字节在最前面的方式，称为小端法，最高有效字节在最前面的方式，称为大端法 C语言中字符串中的每个字符用ASCII字符码编码，则在使用ASCII码作为字符码的任何系统上都将得到相同的结果，与字节顺序和字大小规则无关，UTF-8表示将每个字符编码为一个字节序列，则所有ASCII字节序列用ASCII码表示和UTF_8表示是一样的，Java编程语言使用Unicode表示字符串 二进制代码很少能在不同机器和操作系统组合之间移植，~0将生成一个全1的掩码，不管机器的字大小是多少，尽管对于一个32位机器来说，同样的掩码可以写成0xFFFFFFFF，但这样的代码是不可移植的 对于一个由w位组成的数据类型，如果移动k&gt;=w位，而实际上的位移量是通过计算k mod w的得到的，Java只支持有符号数。c中无符号数和有符号数作运算时，会隐式将有符号参数强制类型转换为无符号数 大多数编译器只在需要少量移位、加法和减法就足够的时候，用其来优化整数乘以（除以）常数的情况。浮点运算只有有限的范围和精度，且不遵循算术中的结合律和分配律 程序的机器级表示一个x86-64的中央处理单元（CPU）包含一组16个存储64位值的通用目的存储器","categories":[{"name":"生活","slug":"生活","permalink":"http://goodguyjameswin.github.io/categories/生活/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://goodguyjameswin.github.io/tags/学习笔记/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"http://goodguyjameswin.github.io/categories/生活/"}]},{"title":"java学习","slug":"java学习","date":"2021-09-08T03:01:24.000Z","updated":"2021-09-14T09:06:12.371Z","comments":false,"path":"2021/09/08/java学习/","link":"","permalink":"http://goodguyjameswin.github.io/2021/09/08/java学习/","excerpt":"","text":"Java基础应该是场持久战，先做好记录。。，部分学习笔记摘录于How2J HelloWorld创建txt文件，写入代码实现打印”helloworld“，改后缀名变为java源文件，需要在命令行里用javac命令编译成class文件后运行 javac filename.java java classname 变量类型整型数据类型byte、short、int的long缺省值都为0，默认的整数字面值是long类型，长度分别为8、16、32、64位（有符号数） char类型的值用单引号’表示 (双引号表示字符串)，其长度和short一样，只能存放一个字符，超过一个字符就会产生编译错误 浮点数类型float、double分别为32、64位，缺省值都为0.0，默认的小数值是double类型，在数字后面加一个字母f，直接把该数字声明成float类型 布尔类型boolean用于表示真假，长度为1，缺省值为false，虽然布尔型真正存放的数据是0（false）、1（true）但是，不能直接使用0、1进行赋值 String其实并不是基本数据类型，String类型是Immutable的，一旦创建就不能够被改变 public class HelloWorld { public static void main(String[] args) { long val = 26L; //以L结尾的字面值表示long型 int decVal = 26; //默认就是int型 int hexVal = 0x1a; //16进制 int oxVal = 032; //8进制 int binVal = 0b11010; //2进制 float f1 = 123.4F; // 以F结尾的字面值表示float类型 double d1 = 123.4; // 默认就是double类型 double d2 = 1.234e2; // 科学计数法表示double，e2表示10的二次方 } } 如果任何运算单元的长度都不超过int，那么其结果就是int。如果有任何运算单元的长度超过int，那么结果就按照最长的长度计算 public class HelloWorld { public static void main(String[] args) { byte b = 5; int i1 = 10; int i2 = 300; b = (byte) i1; //因为i1的值是在byte范围之内，所以即便进行强制转换 //最后得到的值，也是10 System.out.println(b); //因为i2的值是在byte范围之外，所以就会按照byte的长度进行截取 //i2的值是300，其对应的二进制数是 100101100 //按照byte的长度8位进行截取后，其值为 00101100 即44 b =(byte) i2; System.out.println(b); //查看一个整数对应的二进制的方法： System.out.println(Integer.toBinaryString(i2)); } } 作用域类的属性和方法名称一般来说，都是小写，如果有多个单词组成，后面的单词的第一个字母大写，比如moveSpeed 当一个变量被声明在类下面，变量就叫做字段或者属性、成员变量、Field，其作用域就是从其声明的位置开始的整个类 如果一个变量，是声明在一个方法上的，就叫做参数，参数的作用域即为该方法内的所有代码，其他方法不能访问该参数，类里面也不能访问该参数 声明在方法内的变量，叫做局部变量，其作用域在声明开始的位置，到其所处于的块结束位置 属性的作用域在方法中，参数的作用域也在方法中，如果属性和参数命名相同 public class HelloWorld { int i = 1; //属性名是i public void method1(int i) { //参数也是i System.out.println(i); } public static void main(String[] args) { new HelloWorld().method1(5); //结果打印出来是 5 } } 当一个变量被final修饰的时候，该变量只有一次赋值的机会 public class HelloWorld { public void method1(final int j) { j = 5; //这个不能执行 } } 以;结尾的一段代码，即为一个表达式，一个空;也是一个表达式。从 { 开始到对应的 } 结束，即一个块 操作符Scanner需要注意的是，如果在通过nextInt()读取了整数后，再接着读取字符串，读出来的是回车换行:”\\r\\n”,因为nextInt仅仅读取数字信息，而不会读取回车换行”\\r\\n”. 所以，如果在业务上需要读取了整数后，接着读取字符串，那么就应该连续执行两次nextLine()，第一次是取走回车换行，第二次才是读取真正的字符串 import java.util.Scanner; public class HelloWorld { public static void main(String[] args) { Scanner s = new Scanner(System.in); float a = s.nextFloat(); System.out.printIn(&quot;读取的浮点数的值是：&quot;+a); int a = s.nextInt(); System.out.printIn(&quot;第一个整数：&quot;+a); String rn = s.nextLine(); String a = s.nextLine(); System.out.printIn(&quot;读取的字符串是：&quot;+a); } } 逻辑操作符无论&amp;&amp;还是&amp;，两边的运算单元都是布尔值，都为真时，才为真，任意为假，就为假。&amp;&amp;两侧，都会被运算，&amp;只要第一个是false，第二个就不进行运算了 无论||还是|，两边的运算单元都是布尔值，都为真时，才为真，任意为假，就为假。||两侧，都会被运算，|只要第一个是false，第二个就不进行运算了 通过Integer.toBinaryString()方法，可将一个十进制整数转换为一个二进制字符串 带符号右移&gt;&gt;，对于正数，会把所有的位右移，并在最前面补0，对于负数，会把所有的位右移，并在最前面补1。无符号右移&gt;&gt;&gt;，如果是一个负数，那么对应的二进制的第一位是1，会把第一位的1也向右移动，导致移动后，第一位变成0，这样就会使得负数在无符号右移后，得到一个正数 控制流程switchswitch可以使用byte、short、int、char、String和enum，每个表达式结束，都应该有一个break，String在Java1.7之前是不支持的，Java从1.7开始支持switch用String的，编译后是把String转化为hash值，其实还是整数 循环break;只能结束当前循环，使用标签结束外部循环 public class HelloWorld { public static void main(String[] args) { //打印单数 outloop: //outloop这个标示是可以自定义的比如outloop1,ol2,out5 for (int i = 0; i &lt; 10; i++) { for (int j = 0; j &lt; 10; j++) { System.out.println(i+&quot;:&quot;+j); if(0==j%2) break outloop; //如果是双数，结束外部循环 } } } } 数组创建数组public class HelloWorld { public static void main(String[] args) { //声明一个引用，但如果仅仅是这一句声明，则不会创建数组 int[] a; //创建一个长度是5的数组，并且使用引用a指向该数组 a = new int[5]; //创建数组时，要指明数组的长度 int[] b = new int[5]; //声明的同时，指向一个数组 } } 获取0-100的随机整数，Math.random()，会得到一个0-1之间的随机浮点数 (int) (Math.random() * 100) 给数组分配空间、赋值，数组的长度是不可变的 public class HelloWorld { public static void main(String[] args) { //写法一： 分配空间同时赋值 int[] a = new int[]{100,102,444,836,3236}; //写法二： 省略了new int[],效果一样 int[] b = {100,102,444,836,3236}; //写法三：同时分配空间，和指定内容 //在这个例子里，长度是3，内容是5个，产生矛盾了 //所以如果指定了数组的内容，就不能同时设置数组的长度 int[] c = new int[3]{100,102,444,836,3236}; } } 把一个数组的值，复制到另一个数组中 System.arraycopy(src, srcPos, dest, destPos, length) src: 源数组 srcPos: 从源数组复制数据的起始位置 dest: 目标数组 destPos: 复制到目标数组的起始位置 length: 复制的长度 增强型for循环只能用来取值，却不能用来修改数组里的值 int[] a = new int[5]; for(int i = 0; i &lt; a.length; i++) { a[i] = (int) (Math.random() * 100); System.out.println(&quot;数组值依次为：&quot; + a[i]); } //增强型for循环遍历 for (int each : a) { System.out.println(each); } 二维数组二维数组里的每一个元素，都是一个一维数组 public class HelloWorld { public static void main(String[] args) { //初始化二维数组， int[][] a = new int[2][3]; //有两个一维数组，每个一维数组的长度是3 a[1][2] = 5; //可以直接访问一维数组，因为已经分配了空间 //只分配了二维数组 int[][] b = new int[2][]; //有两个一维数组，每个一维数组的长度暂未分配 b[0] =new int[3]; //必须事先分配长度，才可以访问 b[0][2] = 5; //指定内容的同时，分配空间 int[][] c = new int[][]{ {1,2,4}, {4,5}, {6,7,8,9} }; } } ArraysArrays是针对数组的工具类 import java.util.Arrays; public class HelloWorld { public static void main(String[] args) { int a[] = new int[] { 18, 62, 68, 82, 65, 9 }; // copyOfRange(int[] original, int from, int to) // 第一个参数表示源数组 // 第二个参数表示开始位置(取得到) // 第三个参数表示结束位置(取不到) // System.arraycopy，需要事先准备好目标数组，并分配长度。不同的是，copyOfRange只需要源数组就就可以了，通过返回值，就能够得到目标数组了 int[] b = Arrays.copyOfRange(a, 0, 3); // Arrays提供了一个toString()方法，直接把一个数组，转换为字符串 String content = Arrays.toString(a); // Arrays工具类提供了一个sort方法，只需要一行代码即可完成排序功能 Arrays.sort(a); // 查询元素出现的位置，需要注意的是，使用binarySearch进行查找之前，必须使用sort进行排序，如果数组中有多个相同的元素，查找结果是不确定的 Arrays.binarySearch(a, 62); // 比较两个数组的内容是否一样 Arrays.equals(a, b); // 使用同一个值，填充整个数组 Arrays.fill(a, 5); } } 类和对象引用如果一个变量的类型是 类类型，而非基本类型，那么该变量又叫做引用 Hero h = new Hero(); // 使用一个引用来指向这个对象 Hero h1 = new Hero(); Hero h2 = h1; // h2指向h1所指向的对象 第一行，引用garen指向新创建的对象（对象1）；第二行，同一个引用garen指向新创建的对象（对象2）。这个时候，对象1，就没有任何引用指向了，换句话说，就没有任何手段控制和访问该对象，那么该对象就变得没有意义 Hero garen = new Hero(); garen = new Hero(); 方法重载设计采用可变数量参数的方法，在方法里，使用操作数组的方式处理参数 public void attack(Hero h1) public void attack(Hero h1,Hero h2) public void attack(Hero h1,Hero h2,Hero h3) // 可变数量的参数 public void attack(Hero... heros) { for (int i = 0; i &lt; heros.length; i++) { System.out.println(name + &quot; 攻击了 &quot; + heros[i].name); } } 构造方法名和类名一样（包括大小写），没有返回类型，实例化一个对象时，必然调用构造方法，如果不自己定义，就会默认提供一个无参的构造方法，一旦提供了一个有参的构造方法，同时没有显式提供一个无参的构造方法，就不会提供默认的无参构造方法了 构造方法如果要在一个构造方法中，调用另一个构造方法，可以使用this() //带一个参数的构造方法 public Hero(String name){ System.out.println(&quot;一个参数的构造方法&quot;); this.name = name; } //带两个参数的构造方法 public Hero(String name,float hp){ this(name); System.out.println(&quot;两个参数的构造方法&quot;); this.hp = hp; } 传参如果一个变量是基本类型，=符号就表示赋值的意思。如果一个变量是类类型，=符号则表示指向的意思 当变量作为基本类型传递时，在方法内，无法修改方法外的基本类型参数。当变量为类类型传递时，实质传递的是该引用的地址，内部对形参修改影响的只是引用的地址新指向，除非修改对象.属性值，才能真正影响外部实参 访问修饰符 从作用域来看，public能够使用所有的情况 属性通常使用private封装起来 方法一般使用public用于被调用 会被子类继承的方法，通常使用protected package用的不多，一般新手会用package,因为还不知道有修饰符这个东西 作用范围最小原则，简单说，能用private就用private，不行就放大一级，用package，再不行就用protected，最后用public。这样就能把数据尽量的封装起来，没有必要露出来的，就不用露出来了 类属性当一个属性被static修饰的时候，就叫做类属性，又叫做静态属性。当一个属性被声明成类属性，那么所有的对象，都共享一个值 访问类属性可以使用 对象.类属性 类.类属性 类方法访问类方法可以使用 对象.类方法 类.类方法 如果方法里访问了对象属性，那么这个方法，就必须设计为对象方法。如果一个方法，没有调用任何对象属性，那么就可以考虑设计为类方法，这样更带有功能性色彩 初始化package charactor; public class Hero { // 对象属性初始化 public String name = &quot;some hero&quot;; //声明该属性的时候初始化 protected float hp; float maxHP; { maxHP = 200; //初始化块 } public Hero(){ hp = 100; //构造方法中初始化 } // 类属性初始化 public static int itemCapacity=8; //声明的时候 初始化 static{ itemCapacity = 6;//静态初始化块 初始化 } } 单例模式单例模式又叫做Singleton模式，指的是一个类，在一个JVM里，只有一个实例存在 构造方法私有化 静态属性指向实例 public static的getInstance方法，返回第二步的静态属性 package charactor; // 饿汉式单例模式 public class GiantDragon { //私有化构造方法使得该类无法在外部通过new 进行实例化 private GiantDragon(){} //准备一个类属性，指向一个实例化对象。 因为是类属性，所以只有一个 private static GiantDragon instance = new GiantDragon(); //public static 方法，提供给调用者获取12行定义的对象 public static GiantDragon getInstance(){ return instance; } } // 懒汉式单例模式 public class GiantDragon { //私有化构造方法使得该类无法在外部通过new 进行实例化 private GiantDragon(){} //准备一个类属性，用于指向一个实例化对象，但是暂时指向null private static GiantDragon instance; //public static 方法，返回实例对象 public static GiantDragon getInstance(){ //第一次访问的时候，发现instance没有指向任何对象，这时实例化一个对象 if(null==instance){ instance = new GiantDragon(); } //返回 instance指向的对象 return instance; } } 饿汉式是立即加载的方式，无论是否会用到这个对象，都会加载。懒汉式，是延迟加载的方式，只有使用的时候才会加载 枚举类型枚举enum是一种特殊的类（还是类），使用枚举可以很方便的定义常量 public enum Season { SPRING,SUMMER,AUTUMN,WINTER } public class HelloWorld { public static void main(String[] args) { // 在switch语句中，使用枚举来进行判断 Season season = Season.SPRING; switch (season) { case SPRING: System.out.println(&quot;春天&quot;); break; case SUMMER: System.out.println(&quot;夏天&quot;); break; case AUTUMN: System.out.println(&quot;秋天&quot;); break; case WINTER: System.out.println(&quot;冬天&quot;); break; } // 借助增强型for循环，可以很方便的遍历一个枚举都有哪些常量 for (Season s : Season.values()) { System.out.println(s); } } } 使用枚举，就能把常量season的取值范围限定在枚举类型Season的四个值当中 接口和继承对象转型引用类型和对象类型不一致时，才需要进行类型转换。所有的子类转换为父类都是可以的，父类转子类必须进行强制转换（有时候会失败）。没有继承关系的两个类互相转换，一定会失败。实现了接口的类型可以转换成接口。 instanceof判断一个引用所指向的对象 //判断引用h1指向的对象，是否是ADHero类型 System.out.println(h1 instanceof ADHero); 多态同一类型，调用同一个方法，却能呈现出不同的状态。类的多态，指的是父类引用指向子类对象 隐藏隐藏，就是子类覆盖父类的类方法。父类引用指向子类对象时，如果父类和子类创建的是静态方法，结果会调用引用所在的父类方法；如果父类和子类创建的是非静态方法，结果会调用引用所指向的子类方法 super实例化子类会调用其构造方法，其父类的构造方法也一定会被调用，且后者先调用，子类构造方法会默认调用父类的无参构造方法。可以使用关键字super显式调用父类带参的构造方法和父类的属性 若父类提供了有参构造方法，未提供无参构造方法，则需要在父类中显式提供无参构造方法，或者子类显式调用父类有参构造方法，否则实例化子类时会报错 object所有类都默认继承了Object类，它提供了一个toString方法，用来打印返回当前对象的字符串表达 当一个对象没有任何引用指向的时候，它就满足垃圾回收的条件，当它被回收的时候，它的finalize()方法就会被调用 equals()方法用于判断两个对象的内容是否相同，==不是Object的方法，用于判断两个引用是否指向了同一个对象 hashcode()方法返回一个对象的哈希值，线程同步相关方法wait()、notify()、notifyAll()。getClass()会返回一个对象的类对象 finalfinal修饰类，表示其不能被继承；修饰方法，表示其不能被重写；修饰基本类型变量，表示其只有一次赋值机会；修饰引用，表示其只有一次指向对象的机会；String类是final的，不能被继承 public static final int itemTotalNumber = 6; // 指的是常量，不会变化，公开，可以直接访问 抽象类public abstract void attack(); // 抽象方法 当一个类里有抽象方法时，它必须被声明为抽象类，一个类也可以在不提供抽象方法的前提下，声明为抽象类，一旦声明，就不能被直接实例化 抽象类的子类必须提供父类中抽象方法的具体实现。子类只能继承一个抽象类，但是可以实现多个接口，抽象类的属性定义方式与一般的类相同，但是接口中声明的属性，只能是public、静态、final的，即便没有显式地声明 内部类非静态内部类需要建立在外部类的基础上，且可以直接访问外部类的private实例属性，语法：new 外部类().new 内部类() 静态内部类的实例化不需要以一个外部类的实例为基础，可以直接实例化，语法：new 外部类.静态内部类()，静态内部类不可以访问外部类的实例属性和方法，除了可以访问外部类的私有静态成员外，静态内部类和普通类没什么大的区别 匿名类指的是在声明一个类的同时实例化它，这个类，没有命名，本地类可以理解为有名字的匿名类 package charactor; public abstract class Hero { private String name; float hp; float armor; int moveSpeed; public abstract void attack(); // 非静态内部类，只有一个外部类对象存在的时候，才有意义 class BattleScore { int kill; int die; int assit; public void legendary() { if (kill &gt;= 8) System.out.println(name + &quot;超神！&quot;); else System.out.println(name + &quot;尚未超神！&quot;); } } static class EnemyCrystal{ int hp=5000; public void checkIfVictory(){ if(hp==0){ Hero.battleWin(); //静态内部类不能直接访问外部类的对象属性 System.out.println(name + &quot; win this game&quot;); } } } public static void main(String[] args) { //在匿名类中使用外部的局部变量damage 必须修饰为final int damage = 5; //事实上的匿名类，会在匿名类里声明一个damage属性，并且使用构造方法初始化该属性的值 //在attack中使用的damage，真正使用的是这个内部damage，而非外部damage //假设外部属性不需要声明为final //那么在attack中修改damage的值，就会被暗示为修改了外部变量damage的值 //但是他们俩是不同的变量，是不可能修改外部变量damage的 //所以为了避免产生误导，外部的damage必须声明为final,&quot;看上去&quot;就不能修改了 //在jdk8中，已经不需要强制修饰成final了，如果没有写final，不会报错，因为编译器偷偷的帮你加上了看不见的final Hero garen = new Hero(); garen.name = &quot;盖伦&quot;; // 实例化内部类 // BattleScore对象只有在一个Hero对象存在的时候才有意义 // 所以其实例化必须建立在一个外部类对象的基础之上 BattleScore score = garen.new BattleScore(); score.kill = 9; score.legendary(); // 实例化静态内部类 Hero.EnemyCrystal crystal = new Hero.EnemyCrystal(); crystal.checkIfVictory(); // 通常情况下，要使用一个接口或者抽象类，都必须创建一个子类，有的时候，为了快速使用，直接实例化一个抽象类，并“当场”实现其抽象方法。既然实现了抽象方法，那么就是一个新的类，只是这个类，没有命名，叫做匿名类 Hero h = new Hero(){ //当场实现attack方法 public void attack() { System.out.println(&quot;新的进攻手段&quot;); } }; h.attack(); //通过打印h，可以看到h这个对象属于Hero$1这么一个系统自动分配的类名 System.out.println(h); //与匿名类的区别在于，本地类有了自定义的类名。内部类与匿名类不一样的是，内部类必须声明在成员的位置，即与属性和方法平等的位置，本地类和匿名类一样，直接声明在代码块里面，可以是主方法，for循环里等等地方 class SomeHero extends Hero{ public void attack() { System.out.println( name+ &quot; 新的进攻手段&quot;); } } SomeHero h =new SomeHero(); h.name =&quot;地卜师&quot;; h.attack(); //这里使用本地类AnonymousHero来模拟匿名类的隐藏属性机制 class AnonymousHero extends Hero{ int damage; public AnonymousHero(int damage){ this.damage = damage; } public void attack() { damage = 10; System.out.printf(&quot;新的进攻手段，造成%d点伤害&quot;,this.damage ); } } Hero h = new AnonymousHero(damage); } } 默认方法默认方法是JDK8新特性，指的是接口也可以提供具体方法了，而不像以前，只能提供抽象方法 package charactor; public interface Mortal { public void die(); // Mortal这个接口，增加了一个默认方法revive，这个方法有实现体，并且被声明为了default default public void revive() { System.out.println(&quot;本英雄复活了&quot;); } } 接口默认方法Override问题：如果是实现多个接口同时这些接口中都实现了同样的默认方法，那么实现的子类必须要实现这个默认方法（因为不知道要选择哪个方法）。而只要默认方法只有一个那么就可以不用实现（比如AP实现了默认方法，AD没实现，那么两个都实现的子类也不用实现），或者只实现了一个接口，那么子类也不用实现 UMLUML图中，实线表示继承关系，虚线表示实现关系 数字和字符串封装类所有的基本类型，都有对应的类类型，数字封装类有Byte、Short、Interger、Long、Float和Double，这些类都是抽象类Number的子类 //把一个基本类型的变量,转换为Integer对象 Integer it = new Integer(i); //把一个Integer对象，转换为一个基本类型的int int i2 = it.intValue(); 不需要调用构造方法，通过=符号自动把基本类型转换为类类型叫装箱，反过来就叫拆箱。基本类型的最值可以通过其对应的 封装类.MAX_VALUE、封装类.MIN_VALUE获取 字符串转换//使用String类的静态方法valueOf String str = String.valueOf(i); //先把基本类型装箱为对象，然后调用对象的toString Integer it = i; String str2 = it.toString(); //调用Integer的静态方法parseInt int i= Integer.parseInt(str); 数字方法import java.lang.Math Math.round(1.5);//四舍五入 Math.sqrt(9);//开方 Math.pow(2,4);//乘方 Math.PI;//π Math.E;//自然常数 格式化字符串printf和format能够达到一样的效果，在printf中直接调用了format //使用格式化输出 //%s表示字符串，%d表示数字,%n表示换行 String sentenceFormat =&quot;%s 在进行了连续 %d 次击杀后，获得了 %s 的称号%n&quot;; System.out.printf(sentenceFormat,name,kill,title); //使用format格式化输出 System.out.format(sentenceFormat,name,kill,title); 回车符’\\r’就是回到一行的开头，代码里敲回车键实际上是回车换行符。不同的操作系统中，换行符是不一样的，使用%n，就可以做到平台无关的换行 在DOS和Windows中，每行结尾是 “\\r\\n”； Linux系统里，每行结尾只有 “\\n”； Mac系统里，每行结尾是只有 “\\r”。 CharCharacter.isLetter(&#39;a&#39;); //判断是否为字母 Character.isDigit(&#39;a&#39;); //判断是否为数字 Character.isWhitespace(&#39; &#39;); //是否是空白 Character.isUpperCase(&#39;a&#39;); //是否是大写 Character.isLowerCase(&#39;a&#39;); //是否是小写 Character.toUpperCase(&#39;a&#39;); //转换为大写 Character.toLowerCase(&#39;A&#39;); //转换为小写 String a = &#39;a&#39;; //不能够直接把一个字符转换成字符串 String a2 = Character.toString(&#39;a&#39;); //转换为字符串 String str = &quot;abc123&quot;; char[] cs = str.toCharArray(); //字符串转换为字符数组 char[] cs = new char[]{&#39;崔&#39;,&#39;斯&#39;,&#39;特&#39;}; String hero = new String(cs);//通过字符数组创建一个字符串对象 字符串对象是immutable的，对象方法length()返回字符串的长度 String sentenceFormat =&quot;%s 在进行了连续 %d 次击杀后，获得了 %s 的称号%n&quot;; String sentence2 = String.format(sentenceFormat, name,kill,title); //格式化字符串 String unknowHero = &quot;&quot;; //可以有长度为0的字符串,即空字符串 System.out.println(unknowHero.length()); StringString sentence = &quot;盖伦,在进行了连续8次击杀后,获得了 超神 的称号&quot;; char c = sentence.charAt(0); //charAt(int index)获取指定位置的字符 char[] cs = sentence.toCharArray(); //toCharArray()获取对应的字符数组 String subString1 = sentence.substring(3); //截取从第3个开始的字符串 （基0） //截取从第3个开始的字符串 （基0），到5-1的位置的字符串，左闭右开 String subString2 = sentence.substring(3,5); //根据,进行分割，得到3个子字符串 String subSentences[] = sentence.split(&quot;,&quot;); sentence.trim(); //去掉首尾空格 sentence.toLowerCase(); //全部变成小写 sentence.toUpperCase(); //全部变成大写 sentence.indexOf(&#39;8&#39;); //字符第一次出现的位置 sentence.indexOf(&quot;超神&quot;); //字符串第一次出现的位置 sentence.lastIndexOf(&quot;了&quot;); //字符串最后出现的位置 sentence.indexOf(&#39;,&#39;,5); //从位置5开始，出现的第一次,的位置 sentence.contains(&quot;击杀&quot;); //是否包含字符串&quot;击杀&quot; String temp = sentence.replaceAll(&quot;击杀&quot;, &quot;被击杀&quot;); //替换所有的 temp = sentence.replaceFirst(&quot;,&quot;,&quot;&quot;); //只替换第一个 一般来说，编译器没碰到一个字符串的字符串的字面值，就会创建一个新的对象，但如果编译器编译过程中发现已经存在现成的字符串字面值的对象，那么就直接拿来使用，而不会进行重复创建 // ==用于判断是否是同一个字符串对象 System.out.println( str1 == str2); System.out.println(str1.equals(str3));// 使用equals进行字符串内容的比较，必须大小写一致 System.out.println(str1.equalsIgnoreCase(str3));// equalsIgnoreCase，忽略大小写判断内容是否一致 System.out.println(str1.startsWith(start));//以...开始 System.out.println(str1.endsWith(end));//以...结束 StringBuffer和String内部是一个字符数组一样，StringBuffer也维护了一个字符数组。但是，这个字符数组，留有冗余长度 String str1 = &quot;let there &quot;; StringBuffer sb = new StringBuffer(str1); //根据str1创建一个StringBuffer对象 sb.append(&quot;be light&quot;); //在最后追加 sb.delete(4, 10); //删除4-10之间的字符 sb.insert(4, &quot;there &quot;); //在4这个位置插入 there sb.reverse(); //反转 System.out.println(sb.length()); //内容长度 System.out.println(sb.capacity());//总空间，容量","categories":[{"name":"生活","slug":"生活","permalink":"http://goodguyjameswin.github.io/categories/生活/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://goodguyjameswin.github.io/tags/学习笔记/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"http://goodguyjameswin.github.io/categories/生活/"}]},{"title":"yolo格式的数据标签转icdar格式","slug":"yolo_icdar","date":"2021-09-06T12:30:01.000Z","updated":"2021-09-10T00:36:27.409Z","comments":false,"path":"2021/09/06/yolo_icdar/","link":"","permalink":"http://goodguyjameswin.github.io/2021/09/06/yolo_icdar/","excerpt":"","text":"引言第一篇文章（水文）！研一参与的第一个项目，用yolo来检测（识别）图片中的喷码字符（生产日期），然后很长一段时间都在给数据打标签 问题在于用yolo去做逐字符的检测，输出的框顺序并不像我们所认知的那样，分行排列，从上至下，从左至右 yolo格式标签&lt;object-class&gt; &lt;x&gt; &lt;y&gt; &lt;width&gt; &lt;height&gt; x，y是检测框的中心坐标；width，height是检测框的宽和高。这些坐标是通过归一化的，其中x，width是使用原图的width进行归一化；而y，height是使用原图的height进行归一化 icdar格式标签path/to/img [{&quot;transcription&quot;: &quot;content&quot;, &quot;points&quot;: [[x1, y1], [x2, y2], [x3, y3], [x4, y4]]}, {...}] 标签是包含多个字典的list，字典中的 points 表示文本框的四个点的坐标(x, y)，从左上角的点开始顺时针排列。 transcription 表示当前文本框的内容 实现把问题转换为对yolo输出检测框的排序。已知量是每个检测框的横、纵坐标，思路是先把所有检测框按纵坐标分成不同行，每行再按横坐标排序 原先的项目数据里，待识别的图片样式基本不变，可以直接在界面里设置每行文本的字符个数，当时的代码就是直接根据这一条件来对检测框排序。然后就检测条形码和二维码去了 后来项目的数据样式变多了，感觉原来的方法行不通了，最近在用paddleocr做文本识别，需要把以前训练yolo的一些数据标签转成icdar格式，所以又要重新面对这个yolo检测框的排序问题，那就趁着这个机会把代码写清楚 自然断点法a = np.array([5, 35, 38, 41, 65, 68, 98, 99, 100, 99, 105, 106, 102, 104, 103, 100, 110, 69, 64, 70, 75, 71, 73, 72, 42, 46, 40, 36, 37, 6, 8, 11, 4, 15, 10, 9, 4, 8, 135]) 思路还是先把检测框按纵坐标分行，想了半天，放弃 后来在pycharm里边写代码边debug，发现对数组View as Array的时候有个Colored cells选项，可以把一维数组分块，联想到yolo检测框按纵坐标分行，然后上网去搜有没有一维数组的聚类方法 发现可以用python的机器学习算法库里一个叫核密度估计的方法，实现对多维数据分布规律的曲线模拟。那把一维数组扩充到多维不就好了？（大材小用），搜了下这个库的调用方法 a = np.array([5, 35, 38, 41, 65, 68, 98, 99, 100, 99, 105, 106, 102, 104, 103, 100, 110, 69, 64, 70, 75, 71, 73, 72, 42, 46, 40, 36, 37, 6, 8, 11, 4, 15, 10, 9, 4, 8, 135]).reshape(-1, 1) kde = KernelDensity(kernel=&#39;gaussian&#39;, bandwidth=3).fit(a[:, 0].reshape(-1, 1)) # 构造指定数据的核密度估计 s = np.linspace(0, 140) e = kde.score_samples(s.reshape(-1, 1)) # 在特定数据上用核函数拟合 观察了下拟合出来的曲线，确实求个极值就可以找到断点了 mi, ma = argrelextrema(e, np.less)[0], argrelextrema(e, np.greater)[0] # 计算数组指定轴的相对极值 Minima: [25.71428571 54.28571429 85.71428571 122.85714286] Maxima: [8.57142857 37.14285714 71.42857143 100. 134.28571429] 然后根据断点把一维数组分块，还行 [5 6 8 11 4 15 10 9 4 8] [35 38 41 42 46 40 36 37] [65 68 69 64 70 75 71 73 72] [98 99 100 99 105 106 102 104 103 100 110] [135] 后话最后整合到标签转换脚本里去，转换速度还行。。吧 这样就可以用上学长的data_maker了哈哈哈 虽然我个人倾向于用python的pillow库函数ImageFont来制作字符数据，但是喷码样式的字体文件着实不好搞，字符贴图的背景区域定位那块代码也一直想吐槽，之后抽个时间优化下吧，顺便再水一篇文章","categories":[{"name":"技术","slug":"技术","permalink":"http://goodguyjameswin.github.io/categories/技术/"}],"tags":[{"name":"开源项目","slug":"开源项目","permalink":"http://goodguyjameswin.github.io/tags/开源项目/"},{"name":"out-of-date","slug":"out-of-date","permalink":"http://goodguyjameswin.github.io/tags/out-of-date/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://goodguyjameswin.github.io/categories/技术/"}]}]}