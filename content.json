{"meta":{"title":"zt's blog","subtitle":null,"description":"没有记流水帐的习惯~","author":"Terry Joe","url":"http://goodguyjameswin.github.io"},"pages":[{"title":"","date":"2021-09-02T07:22:26.499Z","updated":"2021-09-02T07:21:51.283Z","comments":true,"path":"404.html","permalink":"http://goodguyjameswin.github.io/404.html","excerpt":"","text":"页面没有找到 | zt's Blog body { background: #00c4b6; } #not_found { position: fixed; top: 50%; left: 50%; transform: translateY(-50%) translateX(-50%) scale(1.2); width: 80%; height: auto; } (function () { var lastTime = 0; var vendors = ['ms', 'moz', 'webkit', 'o']; for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) { window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame']; window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] || window[vendors[x] + 'CancelRequestAnimationFrame']; } if (!window.requestAnimationFrame) window.requestAnimationFrame = function (callback, element) { var currTime = new Date().getTime(); var timeToCall = Math.max(0, 16 - (currTime - lastTime)); var id = window.setTimeout(function () { callback(currTime + timeToCall); }, timeToCall); lastTime = currTime + timeToCall; return id; }; if (!window.cancelAnimationFrame) window.cancelAnimationFrame = function (id) { clearTimeout(id); }; })(); //math2 utils var Math2 = {}; Math2.random = function (t, n) { return Math.random() * (n - t) + t; }, Math2.map = function (t, n, r, a, o) { return (o - a) * ((t - n) / (r - n)) + a; }, Math2.randomPlusMinus = function (t) { return t = t ? t : .5, Math.random() > t ? -1 : 1; }, Math2.randomInt = function (t, n) { return n += 1, Math.floor(Math.random() * (n - t) + t); }, Math2.randomBool = function (t) { return t = t ? t : .5, Math.random() < t ? !0 : !1; }, Math2.degToRad = function (t) { return rad = t * Math.PI / 180, rad; }, Math2.radToDeg = function (t) { return deg = 180 / (Math.PI * t), deg; }, Math2.rgbToHex = function (t) { function n(t) { return (\"0\" + parseInt(t).toString(16)).slice(-2); } t = t.match(/^rgb((d+),s*(d+),s*(d+))$/); var r = n(t[1]) + n(t[2]) + n(t[3]); return r.toUpperCase(); }, Math2.distance = function (t, n, r, a) { return Math.sqrt((r - t) * (r - t) + (a - n) * (a - n)); }; //mouse var mousePos = { x: 0, y: 0 }; window.onmousemove = function (e) { e = e || window.event; var pageX = e.pageX; var pageY = e.pageY; if (pageX === undefined) { pageX = e.clientX + document.body.scrollLeft + document.documentElement.scrollLeft; pageY = e.clientY + document.body.scrollTop + document.documentElement.scrollTop; } mousePos = { x: pageX, y: pageY }; }; var options = { width: window.innerWidth, height: window.innerHeight, keyword: \"404\", density: 10, densityText: 3, minDist: 20 }; // initialize canvas var canvas = document.createElement('canvas'); canvas.width = options.width; canvas.height = options.height; canvas.style.width = options.width / 2; canvas.style.height = options.height / 2; canvas.getContext('2d').scale(2, 2); var renderer = new PIXI.autoDetectRenderer(options.width, options.height, { transparent: true }); var stage = new PIXI.Stage(\"0X000000\", true); document.body.appendChild(renderer.view); renderer.view.id = \"not_found\"; var imageData = false; var particles = []; function init() { positionParticles(); positionText(); } function positionParticles() { var canvas = document.createElement(\"canvas\"); canvas.width = 500; canvas.height = 350; var context = canvas.getContext(\"2d\"); context.fillStyle = \"#000000\"; context.font = \"300px 'Arial', sans-serif\"; context.fillText(options.keyword, 0, 250); var imageData = context.getImageData(0, 0, 350, 500); data = imageData.data; // Iterate each row and column for (var i = 0; i < imageData.height; i += options.density) { for (var j = 0; j < imageData.width; j += options.density) { // Get the color of the pixel var color = data[j * (imageData.width * 4) + i * 4 - 1]; // If the color is black, draw pixels if (color == 255) { var newPar = particle(); newPar.setPosition(i, j); particles.push(newPar); stage.addChild(newPar); } } } } function positionText() { var canvas = document.createElement(\"canvas\"); canvas.width = 400; canvas.height = 200; var context = canvas.getContext(\"2d\"); context.fillStyle = \"#000000\"; context.font = \"80px 'Arial', sans-serif\"; context.fillText(\"Not Found\", 0, 80); var imageData = context.getImageData(0, 0, 400, 400); data = imageData.data; // Iterate each row and column for (var i = 0; i < imageData.height; i += options.densityText) { for (var j = 0; j < imageData.width; j += options.densityText) { // Get the color of the pixel var color = data[j * (imageData.width * 4) + i * 4 - 1]; // If the color is black, draw pixels if (color == 255) { var newPar = particle(true); newPar.setPosition(i, j); particles.push(newPar); stage.addChild(newPar); } } } } function particle(text) { $this = new PIXI.Graphics(); if (text == true) { $this.text = true; } $this.beginFill(0XFFFFFF); var radius; $this.radius = radius = $this.text ? Math.random() * 3.5 : Math.random() * 10.5; $this.drawCircle(0, 0, radius); $this.size = this.radius; $this.x = -this.width; $this.y = -this.height; $this.free = false; $this.timer = Math2.randomInt(0, 100); $this.v = Math2.randomPlusMinus() * Math2.random(.5, 1); $this.hovered = false; $this.alpha = Math2.randomInt(10, 100) / 100; $this.vy = -5 + parseInt(Math.random() * 10) / 2; $this.vx = -4 + parseInt(Math.random() * 8); $this.setPosition = function (x, y) { if ($this.text) { $this.x = x + (options.width / 2 - 180); $this.y = y + (options.height / 2 + 100); } else { $this.x = x + (options.width / 2 - 250); $this.y = y + (options.height / 2 - 175); } }; return $this; } function update() { renderer.render(stage); for (i = 0; i < particles.length; i++) { var p = particles[i]; if (mousePos.x > p.x && mousePos.x < p.x + p.size && mousePos.y > p.y && mousePos.y < p.y + p.size) { p.hovered = true; } p.scale.x = p.scale.y = scale = Math.max(Math.min(2.5 - Math2.distance(p.x, p.y, mousePos.x, mousePos.y) / 160, 160), 1); p.x = p.x + .2 * Math.sin(p.timer * .15); p.y = p.y + .2 * Math.cos(p.timer * .15); p.timer = p.timer + p.v; } window.requestAnimationFrame(update); } init(); update();"},{"title":"about","date":"2021-09-04T14:14:36.000Z","updated":"2021-09-08T00:52:21.259Z","comments":false,"path":"about/index.html","permalink":"http://goodguyjameswin.github.io/about/index.html","excerpt":"","text":"[WHUTのTerryJoe] 与&nbsp; Kirito&nbsp; （ Asuna ） 对话中... bot_ui_ini()","keywords":"关于我"},{"title":"bangumi","date":"2021-09-04T13:32:48.000Z","updated":"2021-09-08T00:52:34.864Z","comments":false,"path":"bangumi/index.html","permalink":"http://goodguyjameswin.github.io/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"music","date":"2021-09-04T15:14:28.000Z","updated":"2021-10-07T08:23:31.367Z","comments":false,"path":"music/index.html","permalink":"http://goodguyjameswin.github.io/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"rss","date":"2021-09-04T15:09:03.000Z","updated":"2021-09-08T00:53:21.547Z","comments":true,"path":"rss/index.html","permalink":"http://goodguyjameswin.github.io/rss/index.html","excerpt":"","text":""},{"title":"links","date":"2021-09-04T15:11:06.000Z","updated":"2021-10-07T02:55:28.044Z","comments":false,"path":"links/index.html","permalink":"http://goodguyjameswin.github.io/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"tags","date":"2021-09-05T15:13:48.000Z","updated":"2021-09-11T09:08:30.171Z","comments":false,"path":"tags/index.html","permalink":"http://goodguyjameswin.github.io/tags/index.html","excerpt":"","text":"","keywords":"标签云"},{"title":"comment","date":"2021-09-04T15:13:48.000Z","updated":"2021-09-08T00:52:58.243Z","comments":true,"path":"comment/index.html","permalink":"http://goodguyjameswin.github.io/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"categories","date":"2021-09-04T16:40:09.000Z","updated":"2021-09-11T09:08:23.098Z","comments":false,"path":"categories/index.html","permalink":"http://goodguyjameswin.github.io/categories/index.html","excerpt":"","text":"","keywords":"分类图"},{"title":"video","date":"2021-09-04T15:14:38.000Z","updated":"2021-09-08T00:53:48.250Z","comments":false,"path":"video/index.html","permalink":"http://goodguyjameswin.github.io/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"}],"posts":[{"title":"rotated_data_maker","slug":"rotated-data-maker","date":"2021-10-27T13:30:45.000Z","updated":"2021-10-28T01:50:37.592Z","comments":false,"path":"2021/10/27/rotated-data-maker/","link":"","permalink":"http://goodguyjameswin.github.io/2021/10/27/rotated-data-maker/","excerpt":"","text":"简介一个用于数据增广的脚本，歪门邪道。实验室的深度学习方案，针对性的真实数据永远都只有几张图，可是网络模型的性能本身就是建立在数据集的多样性上面，合成数据只能在一定程度上缓解数据量不足的问题，而且过度依赖合成数据容易导致模型过拟合，且无法从根本上提高模型的鲁棒性 用于生成可以训练多角度目标检测的网络的合成训练数据， 需要背景图和模板图 然后合成的图片大概长这个样子，也没打算再去做进一步的美化了，感觉应付老师够了， 合成图片的过程中，将位置信息也记录下来，格式是DOTA数据集的标签样式 因为确实没什么实用性，写了一两天感觉也只是为了完成任务，细节的话，有兴趣可以看看这个贴图脚本（笑），注释倒写了不少，","categories":[{"name":"技术","slug":"技术","permalink":"http://goodguyjameswin.github.io/categories/技术/"}],"tags":[{"name":"开源项目","slug":"开源项目","permalink":"http://goodguyjameswin.github.io/tags/开源项目/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://goodguyjameswin.github.io/categories/技术/"}]},{"title":"yolov5-dota-obb","slug":"yolov5-dota-obb","date":"2021-10-09T02:19:20.000Z","updated":"2021-10-10T13:04:37.648Z","comments":false,"path":"2021/10/09/yolov5-dota-obb/","link":"","permalink":"http://goodguyjameswin.github.io/2021/10/09/yolov5-dota-obb/","excerpt":"","text":"简介最近出于项目需要，前段时间已经做了一个传统模板匹配的方案了，但是针对旋转目标检测的任务，老师坚持要做一个深度学习方案。拗了几次拗不过他，无奈，只能给他老人家追梦，逛了逛github，发现挺多相关论文的，也有一些源码，但是没几个实用的，不像yolo的reademe写的那么善解人意，没有办法，浏览过程中无意看到一个国内大佬，针对yolov5做了修改，引入了长边表示法对旋转矩形检测框的定义，感觉效果还不错，标签的格式也比较好懂，准备上手尝试 好家伙，还是离不开DOTA_devkit的编译，今年四月份左右想入这个坑，就被windows上各种第三方库的编译给劝退了，然后发现旋转目标检测，基本都离不开对这个工具包的编译，因为旋转目标检测网络目前基本都是用DOTA数据集作benchmark，这个工具包可以很好的处理DOTA数据集 老师那边又反复催，没办法，那就狠下心来读源码！ 后来发现其实编译这个工具包，目的是调用其中有关多边形（旋转矩形框）做NMS（非极大值抑制）的方法，好说，我记得python有个shapely的库，也可以做多边形的IOU（重叠面积占比）运算，多说无益，动手改源码！ 挖坑踩坑这个工程，训练的时候跟原本的yolov5生态环境是一样的，方法调用不需要其他第三方库的支持，比如经典的mosaic数据增强，但是有几个坑 比如原作者的长边表示法是针对opencv4.2以前的版本中minAreaRect这一函数所返回的旋转矩形框所定义的角度做的优化，在高版本的opencv（比如opencv4.5以上）就不支持了。还有就是高版本的pytorch需要针对错误“torch.nn.modules.module.ModuleAttributeError: ‘Hardswish’ object has no attribute ‘inplace’”，找到pytorch的源码部分并做修改 def __init__(self, inplace : bool = False) -&gt; None: super(Hardwish, self).__init__() self.inplace = inplace def forward(self, input : Tensor) -&gt; Tensor: # 源码如下： # return F.hardwish(input, self.inplace) # 修改如下： return F.hardwish(input) 然后重点就是预测的时候，因为需要对经过网络前向推理后的结果（旋转矩形检测框）做NMS，这里需要调用DOTA_devkit工具包里编译好的iou_poly及poly_nms方法，用shapely库重写这一块 from shapely.geometry import Polygon, MultiPoint def iou_rotated_rect(line1, line2): a = np.array(line1).reshape(4, 2) poly1 = Polygon(a).convex_hull b = np.array(line2).reshape(4, 2) poly2 = Polygon(b).convex_hull union_poly = np.concatenate((a, b)) if not poly1.intersects(poly2): # if there is no intersection between two polygons iou = 0 else: inter_area = poly1.intersection(poly2).area # intersection area print(inter_area) union_area = MultiPoint(union_poly).convex_hull.area print(union_area) if union_area == 0: iou = 0 iou = float(inter_area) / union_area return iou def nms_rotated_rect(dets, scores, thresh): obbs = dets[:, 0:-1] x1 = np.min(obbs[:, 0::2], axis=1) y1 = np.min(obbs[:, 1::2], axis=1) x2 = np.max(obbs[:, 0::2], axis=1) y2 = np.max(obbs[:, 1::2], axis=1) areas = (x2 - x1 + 1) * (y2 - y1 + 1) polys = [] for i in range(len(dets)): tm_polygon = [dets[i][0], dets[i][1], dets[i][2], dets[i][3], dets[i][4], dets[i][5], dets[i][6], dets[i][7]] polys.append(tm_polygon) order = scores.argsort()[::-1] keep = [] while order.size &gt; 0: i = order[0] keep.append(i) xx1 = np.maximum(x1[i], x1[order[1:]]) yy1 = np.maximum(y1[i], y1[order[1:]]) xx2 = np.minimum(x2[i], x2[order[1:]]) yy2 = np.minimum(y2[i], y2[order[1:]]) w = np.maximum(0.0, xx2 - xx1) h = np.maximum(0.0, yy2 - yy1) hbb_inter = w * h hbb_ovr = hbb_inter / (areas[i] + areas[order[1:]] - hbb_inter) h_inds = np.where(hbb_ovr &gt; 0)[0] tmp_order = order[h_inds + 1] for j in range(tmp_order.size): iou = iou_rotated_rect(polys[i], polys[tmp_order[j]]) hbb_ovr[h_inds[j]] = iou inds = np.where(hbb_ovr &lt;= thresh)[0] order = order[inds + 1] return keep 然后去掉原工程下detect.py中数据后处理部分对DOTA_devkit工具包的依赖 def rotate_non_max_suppression(...): ... # 源码如下： # i = np.array(py_cpu_nms_poly_fast(np.array(rects), np.array(scores.cpu()), iou_thres)) # 修改如下： i = np.array(nms_rotated_rect(np.array(rects), np.array(scores.cpu()), iou_thres)) ... 修改完毕，用“纯净版”的YOLOv5_DOTA_OBB跑一下demo，发现模型可以正常预测，性能好像也没有损失 然后开始制作自己的数据集，训练并测试，这里我用的是以前用过的标注工具labelimg2，不过说实话有时候莫名其妙闪退让我开始考虑换其他的标注工具了，虽然本来已经是白嫖，就不应该挑三拣四了 不过输出的格式是voc格式，所以我修改了下源码，让它能生成DOTA数据集格式的标签，在原工程的libs/labelFile.py里添加如下代码，会在当前目录下生成一个labels文件夹，里面存放对应标注图片的DOTA格式标签 label_dir = os.path.join(imgFolderPath, &quot;labels&quot;) if not os.path.exists(label_dir): os.makedirs(label_dir) label_file = os.path.join(label_dir, os.path.splitext(imgFileName)[0] + &#39;.txt&#39;) with open(label_file, &#39;w&#39;) as l: for shape in shapes: points = shape[&#39;points&#39;] label = shape[&#39;label&#39;] l.write(&#39; &#39;.join([str(points[0][0]), str(points[0][1]), str(points[1][0]), str(points[1][1]), str(points[2][0]), str(points[2][1]), str(points[3][0]), str(points[3][1]), label]) + &#39;\\n&#39;) 由于老师就给了我一张图片，但是他老人家又信仰深度学习，没办法，只能，通过数据增强来扩充数据集，欺骗自己，训练的数据量足够多，这里调用我自己修改的脚本，参考原项目，可以设置一下每张图片（标注好的）的增强次数，以及各类数据增强方法的参数 接着根据原作者提供的工具，将带DOTA格式标签的数据转换为“长边表示法”格式的标签数据，对应的格式转换代码如下 def dota2LongSideFormat(imgpath, txtpath, dstpath, extractclassname): if os.path.exists(dstpath): shutil.rmtree(dstpath) # delete output folder os.makedirs(dstpath) # make new output folder filelist = GetFileFromThisRootDir(txtpath) # fileist=[&#39;/.../P0005.txt&#39;, ..., /.../P000?.txt] for fullname in filelist: # fullname=&#39;/.../P000?.txt&#39; objects = parse_dota_poly(fullname) name = os.path.splitext(os.path.basename(fullname))[0] # name=&#39;P000?&#39; img_fullname = os.path.join(imgpath, name + &#39;.jpg&#39;) # img_fullname=&#39;/.../P000?.png&#39; img = Image.open(img_fullname) img_w, img_h = img.size # print img_w,img_h with open(os.path.join(dstpath, name + &#39;.txt&#39;), &#39;w&#39;) as f_out: num_gt = 0 for i, obj in enumerate(objects): num_gt = num_gt + 1 # 为当前有效gt计数 poly = obj[&#39;poly&#39;] # poly=[(x1,y1),(x2,y2),(x3,y3),(x4,y4)] poly = np.float32(np.array(poly)) # 四点坐标归一化 poly[:, 0] = poly[:, 0] / img_w poly[:, 1] = poly[:, 1] / img_h rect = cv2.minAreaRect(poly) # 得到最小外接矩形的（中心(x,y), (宽,高), 旋转角度） c_x = rect[0][0] c_y = rect[0][1] w = rect[1][0] h = rect[1][1] theta = rect[-1] # Range for angle is [-90，0) trans_data = cvminAreaRect2longsideformat(c_x, c_y, w, h, theta) if not trans_data: if theta != 90: # Θ=90说明wh中有为0的元素，即gt信息不完整，无需提示异常，直接删除 print(&#39;opencv表示法转长边表示法出现异常,已将第%d个box排除,问题出现在该图片中:%s&#39; % (i, img_fullname)) num_gt = num_gt - 1 continue else: # range:[-180，0) c_x, c_y, longside, shortside, theta_longside = trans_data bbox = np.array((c_x, c_y, longside, shortside)) if (sum(bbox &lt;= 0) + sum(bbox[:2] &gt;= 1)) &gt;= 1: # 0&lt;xy&lt;1, 0&lt;side&lt;=1 print(&#39;bbox[:2]中有&gt;= 1的元素,bbox中有&lt;= 0的元素,已将第%d个box排除,问题出现在该图片中:%s&#39; % (i, img_fullname)) print(&#39;出问题的longside形式数据:[%.16f, %.16f, %.16f, %.16f, %.1f]&#39; % ( c_x, c_y, longside, shortside, theta_longside)) num_gt = num_gt - 1 continue if (obj[&#39;name&#39;] in extractclassname): id = extractclassname.index(obj[&#39;name&#39;]) # id=类名的索引 比如&#39;plane&#39;对应id=0 else: print(&#39;预定类别中没有类别:%s;已将该box排除,问题出现在该图片中:%s&#39; % (obj[&#39;name&#39;], fullname)) num_gt = num_gt - 1 continue theta_label = int(theta_longside + 180.5) # range int[0,180] 四舍五入 if theta_label == 180: # range int[0,179] theta_label = 179 # outline=&#39;id x y longside shortside Θ&#39; # final check if id &gt; 15 or id &lt; 0: print(&#39;id problems,问题出现在该图片中:%s&#39; % (i, img_fullname)) print(&#39;出问题的longside形式数据:[%.16f, %.16f, %.16f, %.16f, %.1f]&#39; % ( c_x, c_y, longside, shortside, theta_longside)) if theta_label &lt; 0 or theta_label &gt; 179: print(&#39;id problems,问题出现在该图片中:%s&#39; % (i, img_fullname)) print(&#39;出问题的longside形式数据:[%.16f, %.16f, %.16f, %.16f, %.1f]&#39; % ( c_x, c_y, longside, shortside, theta_longside)) outline = str(id) + &#39; &#39; + &#39; &#39;.join(list(map(str, bbox))) + &#39; &#39; + str(theta_label) f_out.write(outline + &#39;\\n&#39;) # 写入txt文件中并加上换行符号 \\n if num_gt == 0: os.remove(os.path.join(dstpath, name + &#39;.txt&#39;)) # os.remove(img_fullname) os.remove(fullname) print(&#39;%s 图片对应的txt不存在有效目标,已删除对应图片与txt&#39; % img_fullname) print(&#39;已完成文件夹内DOTA数据形式到长边表示法的转换&#39;) def cvminAreaRect2longsideformat(x_c, y_c, width, height, theta): if theta == 0: theta = -90 buffer_width = width width = height height = buffer_width if theta &gt; 0: if theta != 90: # Θ=90说明wh中有为0的元素，即gt信息不完整，无需提示异常，直接删除 print(&#39;θ计算出现异常，当前数据为：%.16f, %.16f, %.16f, %.16f, %.1f;超出opencv表示法的范围：[-90,0)&#39; % ( x_c, y_c, width, height, theta)) return False if theta &lt; -90: print( &#39;θ计算出现异常，当前数据为：%.16f, %.16f, %.16f, %.16f, %.1f;超出opencv表示法的范围：[-90,0)&#39; % (x_c, y_c, width, height, theta)) return False if width != max(width, height): # 若width不是最长边 longside = height shortside = width theta_longside = theta - 90 else: # 若width是最长边(包括正方形的情况) longside = width shortside = height theta_longside = theta if longside &lt; shortside: print(&#39;旋转框转换表示形式后出现问题：最长边小于短边;[%.16f, %.16f, %.16f, %.16f, %.1f]&#39; % ( x_c, y_c, longside, shortside, theta_longside)) return False if (theta_longside &lt; -180 or theta_longside &gt;= 0): print(&#39;旋转框转换表示形式时出现问题:θ超出长边表示法的范围：[-180,0);[%.16f, %.16f, %.16f, %.16f, %.1f]&#39; % ( x_c, y_c, longside, shortside, theta_longside)) return False return x_c, y_c, longside, shortside, theta_longside 有了数据集，接下来就是训练调参了，经典踩坑，一开始训练采用的原作者的默认配置，后来loss就是降不下来，测试效果也就肉眼可见的差，翻了翻评论区，结合自己的一点点对超参数的理解，修改hyp_scratch.yaml文件中各部分loss的权重，以及根据评论区原作者建议，调低了mosaic数据增强的启用概率（虽说见过很多次了，但还是觉得提出这个数据增强方式的人真的强），然后象征性地打开了mixup数据增强 接下来划重点 由于原作者使用“长边表示法”表示旋转矩形框的算法具有局限性，标签在高版本opencv上无法成功从DOTA格式转换为longsideformat格式，宽高不等的图片无法作为数据正常送入网络进行训练，这是由于作者是先对图像宽高进行归一化之后再转换标签格式，然后在longsideformat格式下进行图片像素坐标的去归一化（会导致标签由旋转矩形框变成类平行四边形框），有一个好的解决方案是对图片归一化时，宽高都针对两者中的较大值作为归一化的分母做归一化，这样转换标签格式后，图片像素坐标去归一化的分母还是一样的，不会产生标签偏移，最好的解决办法是修改标签转换部分代码以及整个深度学习工程的像素坐标归一化与去归一化过程，但是这样修改起来工作量较大，且可行性得不到验证，因此目前仍建议采用宽高相等的图片作为训练数据 如果数据增强的时候，开启了多种增强方式（如旋转，平移，裁剪），建议训练的时候，将角度、box和置信度的loss权重调高，若不是做多分类，分类部分的loss权重可以调低，生成的训练数据集比较复杂的情况下，mosaic和mixup数据增强方式的启用概率可以适当调低，并且为了保证网络收敛，建议调高epochs，并且采用Adam优化算法 忙活了半天，终于训练出来一个还不错的效果了 640*640的图片，gpu单张预测时间在0.1s左右，还行ing","categories":[{"name":"技术","slug":"技术","permalink":"http://goodguyjameswin.github.io/categories/技术/"}],"tags":[{"name":"开源项目","slug":"开源项目","permalink":"http://goodguyjameswin.github.io/tags/开源项目/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://goodguyjameswin.github.io/categories/技术/"}]},{"title":"yolact","slug":"yolact","date":"2021-10-07T03:34:57.000Z","updated":"2021-10-10T13:34:20.468Z","comments":false,"path":"2021/10/07/yolact/","link":"","permalink":"http://goodguyjameswin.github.io/2021/10/07/yolact/","excerpt":"","text":"简介奉老师之命，调试一个实例分割的网络，用来做缺陷检测，至于为什么用实例分割网络做缺陷检测，我也不清楚，反正他老人家的意思是要能够在c++那头部署，好让人家写界面封装。话不多说，开始做数据！ 踩坑挖坑盯上了一个可以用ncnn部署的实例分割网络yolact，先考虑能否使用opencv的dnn库进行网络的部署，参考项目，使用official版yolact工程里自带的训练.pth权重，先转换成.onnx格式。这里有一个坑，貌似低版本的opencv，会报错，安装高版本（如opencv4.5）可以解决权重转换报错。其次就是，训练时使用的pytorch，一定要和.pth权重文件转.onnx格式时使用的pytorch版本对应 然后在c++端进行推理，发现可以成功，300*300的demo图片cpu推理时间在700ms左右，坚定了调试yolact工程的决心 然后去踩yolact网络训练测试的坑，发现同样是opencv版本低带来的坑，读训练图片的时候会报错，升级一下opencv版本就好了 用labelme工具标注图片分割数据，产生的json格式标签，同样的用脚本扩充一下数据集，验证一下标签转换是否正确 然后把标注并且增广后的数据及json格式标签，转换为COCO格式数据集 def main(): parser = argparse.ArgumentParser( formatter_class=argparse.ArgumentDefaultsHelpFormatter ) parser.add_argument(&quot;input_dir&quot;, help=&quot;input annotated directory&quot;) parser.add_argument(&quot;output_dir&quot;, help=&quot;output dataset directory&quot;) parser.add_argument(&quot;--labels&quot;, help=&quot;labels file&quot;, required=True) parser.add_argument( &quot;--noviz&quot;, help=&quot;no visualization&quot;, action=&quot;store_true&quot; ) args = parser.parse_args() if osp.exists(args.output_dir): print(&quot;Output directory already exists:&quot;, args.output_dir) sys.exit(1) os.makedirs(args.output_dir) os.makedirs(osp.join(args.output_dir, os.path.basename(args.input_dir) + &quot;_JPEGImages&quot;)) if not args.noviz: os.makedirs(osp.join(args.output_dir, &quot;Visualization&quot;)) print(&quot;Creating dataset:&quot;, args.output_dir) now = datetime.datetime.now() data = dict( info=dict( description=None, url=None, version=None, year=now.year, contributor=None, date_created=now.strftime(&quot;%Y-%m-%d %H:%M:%S.%f&quot;), ), licenses=[dict(url=None, id=0, name=None,)], images=[ # license, url, file_name, height, width, date_captured, id ], type=&quot;instances&quot;, annotations=[ # segmentation, area, iscrowd, image_id, bbox, category_id, id ], categories=[ # supercategory, id, name ], ) class_name_to_id = {} for i, line in enumerate(open(args.labels).readlines()): class_id = i - 1 # starts with -1 class_name = line.strip() if class_id == -1: assert class_name == &quot;__ignore__&quot; continue class_name_to_id[class_name] = class_id data[&quot;categories&quot;].append( dict(supercategory=None, id=class_id, name=class_name,) ) out_ann_file = osp.join(args.output_dir, os.path.basename(args.input_dir) + &quot;.json&quot;) label_files = glob.glob(osp.join(args.input_dir, &quot;*.json&quot;)) for image_id, filename in enumerate(label_files): print(&quot;Generating dataset from:&quot;, filename) label_file = labelme.LabelFile(filename=filename) base = osp.splitext(osp.basename(filename))[0] out_img_file = osp.join(args.output_dir, os.path.basename(args.input_dir) + &quot;_JPEGImages&quot;, base + &quot;.jpg&quot;) img = labelme.utils.img_data_to_arr(label_file.imageData) imgviz.io.imsave(out_img_file, img) data[&quot;images&quot;].append( dict( license=0, url=None, file_name=osp.relpath(out_img_file, osp.dirname(out_ann_file)), height=img.shape[0], width=img.shape[1], date_captured=None, id=image_id, ) ) masks = {} # for area segmentations = collections.defaultdict(list) # for segmentation for shape in label_file.shapes: points = shape[&quot;points&quot;] label = shape[&quot;label&quot;] group_id = shape.get(&quot;group_id&quot;) shape_type = shape.get(&quot;shape_type&quot;, &quot;polygon&quot;) mask = labelme.utils.shape_to_mask( img.shape[:2], points, shape_type ) if group_id is None: group_id = uuid.uuid1() instance = (label, group_id) if instance in masks: masks[instance] = masks[instance] | mask else: masks[instance] = mask if shape_type == &quot;rectangle&quot;: (x1, y1), (x2, y2) = points x1, x2 = sorted([x1, x2]) y1, y2 = sorted([y1, y2]) points = [x1, y1, x2, y1, x2, y2, x1, y2] else: points = np.asarray(points).flatten().tolist() segmentations[instance].append(points) segmentations = dict(segmentations) for instance, mask in masks.items(): cls_name, group_id = instance if cls_name not in class_name_to_id: continue cls_id = class_name_to_id[cls_name] mask = np.asfortranarray(mask.astype(np.uint8)) mask = pycocotools.mask.encode(mask) area = float(pycocotools.mask.area(mask)) bbox = pycocotools.mask.toBbox(mask).flatten().tolist() data[&quot;annotations&quot;].append( dict( id=len(data[&quot;annotations&quot;]), image_id=image_id, category_id=cls_id, segmentation=segmentations[instance], area=area, bbox=bbox, iscrowd=0, ) ) if not args.noviz: labels, captions, masks = zip( *[ (class_name_to_id[cnm], cnm, msk) for (cnm, gid), msk in masks.items() if cnm in class_name_to_id ] ) viz = imgviz.instances2rgb( image=img, labels=labels, masks=masks, captions=captions, font_size=15, line_width=2, ) out_viz_file = osp.join( args.output_dir, &quot;Visualization&quot;, base + &quot;.jpg&quot; ) imgviz.io.imsave(out_viz_file, viz) with open(out_ann_file, &quot;w&quot;) as f: json.dump(data, f) 简单配置训练信息，开始训练！ 训练完毕，先在python这边测试一下效果，马马虎虎 然后关键是，能否在c++端部署并成功预测，这里又有一个坑，如果是训练自己的数据集，得到的.pth权重文件在转换.onnx文件时，需要保证网络结构部分读取张量的尺寸能对齐（一般来说是图片尺寸通道数或者训练测试类别数的不一致会导致报错） 训练的模型也比较简单，看了下中间过程的mask图，这边生成的分割图还是不够准确，对模型的训练效果要求还是比较高，貌似效果和python那边预测的有点差距，初步估计是网络前向推理后的数据后处理部分还是有区别吧，留个坑，以后有时间再填~","categories":[{"name":"技术","slug":"技术","permalink":"http://goodguyjameswin.github.io/categories/技术/"}],"tags":[{"name":"开源项目","slug":"开源项目","permalink":"http://goodguyjameswin.github.io/tags/开源项目/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://goodguyjameswin.github.io/categories/技术/"}]},{"title":"PaddleOCR","slug":"PaddleOcr调试记录","date":"2021-10-07T02:20:57.000Z","updated":"2021-10-10T12:32:00.664Z","comments":false,"path":"2021/10/07/PaddleOcr调试记录/","link":"","permalink":"http://goodguyjameswin.github.io/2021/10/07/PaddleOcr调试记录/","excerpt":"","text":"简介由于项目需求，直接调用PaddleOCR官方训练好的中英文通用检测识别权重，把检测字符和识别串联的代码结构合并了一下，然后修改了分行的判别机制 原项目 修改前： 修改后： cpu串联推理结合mkldnn设置，速度大概提升了30%","categories":[{"name":"技术","slug":"技术","permalink":"http://goodguyjameswin.github.io/categories/技术/"}],"tags":[{"name":"开源项目","slug":"开源项目","permalink":"http://goodguyjameswin.github.io/tags/开源项目/"},{"name":"ocr","slug":"ocr","permalink":"http://goodguyjameswin.github.io/tags/ocr/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://goodguyjameswin.github.io/categories/技术/"}]},{"title":"data-augtools","slug":"data-augtools","date":"2021-09-26T07:14:03.000Z","updated":"2021-10-16T07:28:16.732Z","comments":false,"path":"2021/09/26/data-augtools/","link":"","permalink":"http://goodguyjameswin.github.io/2021/09/26/data-augtools/","excerpt":"","text":"简介在原项目的基础上，添加了针对标注工具labelimg2的数据增强 在labelme的数据增强部分添加了旋转和裁剪处理，并做了标签增强 修改后","categories":[{"name":"技术","slug":"技术","permalink":"http://goodguyjameswin.github.io/categories/技术/"}],"tags":[{"name":"开源项目","slug":"开源项目","permalink":"http://goodguyjameswin.github.io/tags/开源项目/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://goodguyjameswin.github.io/categories/技术/"}]},{"title":"text_generator","slug":"text-generator","date":"2021-09-22T04:37:14.000Z","updated":"2021-10-10T12:30:18.520Z","comments":false,"path":"2021/09/22/text-generator/","link":"","permalink":"http://goodguyjameswin.github.io/2021/09/22/text-generator/","excerpt":"","text":"引言用pillow的ImageFont模块去生成可供ocr模型训练的文本检测和识别训练数据，原项目暂时没找到。。 修改引入背景roi 就像上面这张图，有时候场景文本检测和识别任务中，文字只会出现在场景图片特定的语义区域中。因此在制作文本数据时，就需要限定文本出现的范围 调用opencv-python里的api： import cv2 class UseCv: def __init__(self): self.path = &#39;bg.jpg&#39; def cut(self): img = cv2.imread(self.path, flags=cv2.IMREAD_COLOR) bbox = cv2.selectROI(img, False) cut = img[bbox[1]:bbox[1] + bbox[3], bbox[0]:bbox[0] + bbox[2]] cv2.imwrite(&#39;bg_cut.jpg&#39;, cut) 更改： self.roi = cv2.selectROI(cv2.imread(self.bg, 1), False) if x + w &gt; (self.roi[0] + self.roi[2] - 10) or y + h &gt; (self.roi[1]+ self.roi[3] - 10): return draw, (w, h), False tl_x = random.randrange(self.roi[0], self.roi[0] + self.roi[2]) # 字体位置 tl_y = random.randrange(self.roi[1], self.roi[1] + self.roi[3]) 使用命令行调用生成语料： 9CHCAV1 6TXYQ WNVKWX 9OMKKCM5Y X4EPT1J- 9ZG4GB HUTTQRF KDB6TFFP 1ZNKT45E ULR26VPJE 选择roi 运行 结果","categories":[{"name":"技术","slug":"技术","permalink":"http://goodguyjameswin.github.io/categories/技术/"}],"tags":[{"name":"开源项目","slug":"开源项目","permalink":"http://goodguyjameswin.github.io/tags/开源项目/"},{"name":"ocr","slug":"ocr","permalink":"http://goodguyjameswin.github.io/tags/ocr/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://goodguyjameswin.github.io/categories/技术/"}]},{"title":"shape_based_matching","slug":"shape_based_matching","date":"2021-09-15T02:13:12.000Z","updated":"2021-10-10T12:31:17.306Z","comments":false,"path":"2021/09/15/shape_based_matching/","link":"","permalink":"http://goodguyjameswin.github.io/2021/09/15/shape_based_matching/","excerpt":"","text":"环境配置新建VS空工程，然后在VS-视图-属性管理器，配置opencv环境，VC++目录-包含目录添加： ..\\opencv\\build\\include ..\\opencv\\build\\include\\opencv ..\\opencv\\build\\include\\opencv2 VC++目录-库目录添加： ..\\opencv\\build\\x64\\vc15\\lib 链接器-输入-附加依赖项添加： opencv_world346d.lib 将原工程根目录下的源文件和头文件添加到新建VS工程里，修改fusion.h和line2Dup.h文件里的路径： #include &quot;MIPP/mipp.h&quot; // for SIMD in different platforms 修改test.cpp里的prefix变量路径，指向资源文件： static std::string prefix = &quot;../test/&quot;; api调用原作者分别对模板做了角度、尺度方面的测试，以及noise_test（NMS筛选）。这里假设模板是工业器件，且由于拍摄角度和器件摆放位置的随机性，需要简单写个my_test函数来调用api void my_test(string mode = &quot;test&quot;, bool use_rot = true) { int num_feature = 16; // 特征点数量 line2Dup::Detector detector(num_feature, { 4, 8 }); if (mode != &quot;test&quot;) { Mat img = imread(prefix + &quot;case3/train.jpg&quot;); // 训练图片 assert(!img.empty() &amp;&amp; &quot;check your img path&quot;); // crop the template from the original train image Rect roi(90, 35, 65, 35); img = img(roi).clone(); Mat mask = Mat(img.size(), CV_8UC1, { 255 }); // padding to avoid rotating out int padding = 25; cv::Mat padded_img = cv::Mat(img.rows + 2 * padding, img.cols + 2 * padding, img.type(), cv::Scalar::all(0)); img.copyTo(padded_img(Rect(padding, padding, img.cols, img.rows))); cv::Mat padded_mask = cv::Mat(mask.rows + 2 * padding, mask.cols + 2 * padding, mask.type(), cv::Scalar::all(0)); mask.copyTo(padded_mask(Rect(padding, padding, img.cols, img.rows))); shape_based_matching::shapeInfo_producer shapes(padded_img, padded_mask); shapes.angle_range = { 0, 360 }; // 模板库尺度范围 shapes.angle_step = 1; // 模板库尺度步长 shapes.scale_range = { 0.5f, 1.5f }; // 模板库角度范围 shapes.scale_step = 0.1f; // 模板库角度步长 //shapes.scale_range = { 1.0f }; shapes.produce_infos(); std::vector&lt;shape_based_matching::shapeInfo_producer::Info&gt; infos_have_templ; string class_id = &quot;gongjian&quot;; // 模板类名 bool is_first = true; // for other scales you want to re-extract points: // set shapes.scale_range then produce_infos; set is_first = false; int first_id = 0; float first_angle = 0; float first_scale = 0; for (auto&amp; info : shapes.infos) { Mat to_show = shapes.src_of(info); /********************/ // 通用场景 std::cout &lt;&lt; &quot;\\ninfo.angle: &quot; &lt;&lt; info.angle &lt;&lt; std::endl; int templ_id = detector.addTemplate(shapes.src_of(info), class_id, shapes.mask_of(info), int(num_feature * info.scale)); // todo: 模板图尺度没有变化的场景 //（第一次需要成功记录模板，尽量保证模板完整，轮廓层次分明） //（如果报错数组越界，先尝试改善模板图片质量，不行再尝试调小num_feature的值，但建议至少为8） /*std::cout &lt;&lt; &quot;\\ninfo.angle: &quot; &lt;&lt; info.angle &lt;&lt; std::endl; int templ_id; if (is_first) { templ_id = detector.addTemplate(shapes.src_of(info), class_id, shapes.mask_of(info), int(num_feature * info.scale)); first_id = templ_id; first_angle = info.angle; first_scale = info.scale; if (use_rot) is_first = false; } else { templ_id = detector.addTemplate_rotate(class_id, first_id, info.angle - first_angle, { shapes.src.cols / 2.0f, shapes.src.rows / 2.0f }); }*/ /********************/ std::cout &lt;&lt; &quot;templ_id: &quot; &lt;&lt; templ_id &lt;&lt; std::endl; if (templ_id != -1) { auto templ = detector.getTemplates(&quot;gongjian&quot;, templ_id); for (int i = 0; i &lt; templ[0].features.size(); i++) { auto feat = templ[0].features[i]; cv::circle(to_show, { feat.x + templ[0].tl_x, feat.y + templ[0].tl_y }, 3, { 0, 0, 255 }, -1); } infos_have_templ.push_back(info); // will be faster if not showing this imshow(&quot;train&quot;, to_show); waitKey(1); } if (fabs(info.scale - first_scale) &gt; 0.002f) { is_first = true; std::cout &lt;&lt; &quot;info_scale: &quot; &lt;&lt; info.scale &lt;&lt; std::endl; } } detector.writeClasses(prefix + &quot;case3/%s_templ.yaml&quot;); // 模板库 shapes.save_infos(infos_have_templ, prefix + &quot;case3/gongjian_info.yaml&quot;); // 模板信息 std::cout &lt;&lt; &quot;train end&quot; &lt;&lt; std::endl &lt;&lt; std::endl; } else if (mode == &quot;test&quot;) { std::vector&lt;std::string&gt; ids; ids.push_back(&quot;gongjian&quot;); detector.readClasses(ids, prefix + &quot;case3/%s_templ.yaml&quot;); // angle &amp; scale are saved here, fetched by match id auto infos = shape_based_matching::shapeInfo_producer::load_infos(prefix + &quot;case3/gongjian_info.yaml&quot;); Mat test_img = imread(prefix + &quot;case3/ori.jpg&quot;); // 测试图片 assert(!test_img.empty() &amp;&amp; &quot;check your img path&quot;); // padding to avoid rotating out int padding = 150; cv::Mat padded_img = cv::Mat(test_img.rows + 2 * padding, test_img.cols + 2 * padding, test_img.type(), cv::Scalar::all(0)); test_img.copyTo(padded_img(Rect(padding, padding, test_img.cols, test_img.rows))); int stride = 32; int n = padded_img.rows / stride; int m = padded_img.cols / stride; Rect roi(0, 0, stride * m, stride * n); Mat img = padded_img(roi).clone(); assert(img.isContinuous()); // cvtColor(img, img, CV_BGR2GRAY); // todo:训练模板用灰度图，测试图片也用灰度图，然后观察推理速度和效果 std::cout &lt;&lt; &quot;test img size: &quot; &lt;&lt; img.rows * img.cols &lt;&lt; std::endl &lt;&lt; std::endl; // check time span auto start_time = GetTickCount(); //Timer timer; auto matches = detector.match(img, 90, ids); // 匹配阈值 //timer.out(); std::cout &lt;&lt; &quot;matches.size(): &quot; &lt;&lt; matches.size() &lt;&lt; std::endl; vector&lt;Rect&gt; boxes; vector&lt;float&gt; scores; vector&lt;int&gt; idxs; for (auto match : matches) { Rect box; box.x = match.x; box.y = match.y; auto templ = detector.getTemplates(&quot;gongjian&quot;, match.template_id); box.width = templ[0].width; box.height = templ[0].height; boxes.push_back(box); scores.push_back(match.similarity); } cv_dnn::NMSBoxes(boxes, scores, 90, 0, idxs); // 筛选阈值 auto end_time = GetTickCount(); cout &lt;&lt; &quot;匹配算法耗时：&quot; &lt;&lt; (end_time - start_time) &lt;&lt; &quot;ms.&quot; &lt;&lt; endl; if (img.channels() == 1) cvtColor(img, img, CV_GRAY2BGR); for (auto idx : idxs) { auto match = matches[idx]; /*size_t top5 = 10; if (top5 &gt; matches.size()) top5 = matches.size(); for (size_t i = 0; i &lt; top5; i++) { auto match = matches[i];*/ auto templ = detector.getTemplates(&quot;gongjian&quot;, // 读取训练好的模板类 match.template_id); // 65 is width of template image, 35 is height of template image // 25 is padding when training // tl_x/y: template croping topleft corner when training float x_scaled = 60 / 2.0f * infos[match.template_id].scale; float y_scaled = 35 / 2.0f * infos[match.template_id].scale; // scaling won&#39;t affect this, because it has been determined by warpAffine // cv::warpAffine(src, dst, rot_mat, src.size()); last param float train_img_half_width = 60 / 2.0f + 25; float train_img_half_height = 35 / 2.0f + 25; // center x,y of train_img in test img float x = match.x - templ[0].tl_x + train_img_half_width; float y = match.y - templ[0].tl_y + train_img_half_height; cv::Vec3b randColor; randColor[0] = rand() % 155 + 100; randColor[1] = rand() % 155 + 100; randColor[2] = rand() % 155 + 100; for (int i = 0; i &lt; templ[0].features.size(); i++) { auto feat = templ[0].features[i]; cv::circle(img, { feat.x + match.x, feat.y + match.y }, 3, randColor, -1); } cv::putText(img, to_string(int(round(match.similarity))), Point(match.x + x_scaled - 10, match.y - 3), FONT_HERSHEY_PLAIN, 2, randColor); cv::RotatedRect rotatedRectangle({ x, y }, { 2 * x_scaled, 2 * y_scaled }, -infos[match.template_id].angle); cv::Point2f vertices[4]; rotatedRectangle.points(vertices); for (int i = 0; i &lt; 4; i++) { int next = (i + 1 == 4) ? 0 : (i + 1); cv::line(img, vertices[i], vertices[next], randColor, 2); } std::cout &lt;&lt; &quot;\\nmatch.template_id: &quot; &lt;&lt; match.template_id &lt;&lt; std::endl; std::cout &lt;&lt; &quot;match.similarity: &quot; &lt;&lt; match.similarity &lt;&lt; std::endl; } imshow(&quot;img&quot;, img); waitKey(0); std::cout &lt;&lt; &quot;test end&quot; &lt;&lt; std::endl &lt;&lt; std::endl; } } 效果训练 测试","categories":[{"name":"技术","slug":"技术","permalink":"http://goodguyjameswin.github.io/categories/技术/"}],"tags":[{"name":"开源项目","slug":"开源项目","permalink":"http://goodguyjameswin.github.io/tags/开源项目/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://goodguyjameswin.github.io/categories/技术/"}]},{"title":"深入理解计算机系统","slug":"深入理解计算机系统","date":"2021-09-10T01:27:31.000Z","updated":"2021-10-28T01:43:45.981Z","comments":false,"path":"2021/09/10/深入理解计算机系统/","link":"","permalink":"http://goodguyjameswin.github.io/2021/09/10/深入理解计算机系统/","excerpt":"","text":"模仿我喜欢的一个演员邹兆龙的一段反派戏里一句台词，“买了不吃是不是不给面子啊？”，引申一下，📕：“买了不看是不是不给面子啊？” 哈哈毕竟这本书100多老贵了。。 计算机系统漫游 预处理器根据#开头的命令，修改原始的C程序。比如 #include &lt;stdio.h&gt; 告诉预处理器读取系统头文件stdio.h的内容，并把它直接插入到程序文本中，得到另一个C程序 编译器将文件翻译成一个汇编语言程序，汇编器将文件翻译成机器语言指令，并打包成可重定位目标程序 每个C编译器都提供标准C库中的函数，它们存在于单独的预编译好了的目标文件中，这些文件必须以某种方式合并到我们的程序中，链接器就负责这种合并，最后得到一个可执行目标文件 贯穿整个系统的是一组电子管道，总线，总线通常被设计成定长的字节块，也就是字。字中的字节数（即字长）是一个系统的基本参数，各个系统都不尽相同 每个I/O设备都通过一个控制器或适配器与I/O总线相连，控制器是I/O设备本身或者系统的主印制电路板（通常叫主板）上的芯片组，而适配器则是一块插在主板插槽上的卡，它们的功能都是在I/O总线和I/O设备之间传递信息 存储器是一个线性的字节数组，每个字节都有唯一的地址（数组索引），这些地址是从零开始的 寄存器文件是一个小的存储设备，由一些单个字长的寄存器组成，每个寄存器都有唯一的名字 CPU处理器的核心是一个大小为一个字的存储设备（或寄存器），称为程序计数器（PC），在任何时刻，PC都指向主存中的某条机器语言指令（即含有该条指令的地址） 指令集架构描述的是每条机器代码指令的效果；而微体系结构描述的是处理器实际上是如何实现的 从一个进程到另一个进程的转换是由操作系统内核（kernel）管理的，内核是操作系统代码常驻主存的部分。内核不是一个独立的进程，它是处理全部进程所用代码和数据结构的集合 超线程，称为同时多线程，允许一个CPU执行多个控制流的技术，它涉及CPU某些硬件有多个备份，比如程序计数器和寄存器文件，而其他硬件部分只有一份，比如执行浮点算术运算的单元。超线程的处理器可以在单个周期的基础上决定要执行哪一个线程 信息的表示和处理大多数计算机使用8位的块，或者字节（byte），作为最小的可寻址的内存单位，而不是访问内存中单独的位，多字节对象都被存储为连续的字节序列，对象的地址为所使用字节中最小的地址 由于表示的精度有限，浮点运算是不可结合的。整数的表示虽然只能编码一个相对较小的数值范围，但这种表示是精确的，浮点数虽然可以编码一个较大的数值范围，但这种表示只是近似的 对于一个字长为w位的机器而言，虚拟地址的范围为0~2的w次方-1，程序最多访问2的w次方个字节 大多数64位机器也可以运行为32位机器编译的程序，程序称为“32位程序”、“64位程序”时，区别在于该程序是如何编译的，而不是其运行的机器类型 指针使用程序的全字长。顺序存储对象时，最低有效字节在最前面的方式，称为小端法，最高有效字节在最前面的方式，称为大端法 C语言中字符串中的每个字符用ASCII字符码编码，则在使用ASCII码作为字符码的任何系统上都将得到相同的结果，与字节顺序和字大小规则无关，UTF-8表示将每个字符编码为一个字节序列，则所有ASCII字节序列用ASCII码表示和UTF_8表示是一样的，Java编程语言使用Unicode表示字符串 二进制代码很少能在不同机器和操作系统组合之间移植，~0将生成一个全1的掩码，不管机器的字大小是多少，尽管对于一个32位机器来说，同样的掩码可以写成0xFFFFFFFF，但这样的代码是不可移植的 对于一个由w位组成的数据类型，如果移动k&gt;=w位，而实际上的位移量是通过计算k mod w的得到的，Java只支持有符号数。c中无符号数和有符号数作运算时，会隐式将有符号参数强制类型转换为无符号数 大多数编译器只在需要少量移位、加法和减法就足够的时候，用其来优化整数乘以（除以）常数的情况。浮点运算只有有限的范围和精度，且不遵循算术中的结合律和分配律 程序的机器级表示一个x86-64的中央处理单元（CPU）包含一组16个存储64位值的通用目的存储器 处理器通过流水线来获得高性能，采用非常精密的分支预测逻辑来猜测每条跳转指令是否会执行，因此一般指令流水线里充满着指令。分支预测错误会极大地降低程序的性能，此时可用条件数据传送代替条件控制转移 当x86-64过程需要的存储空间超出寄存器能够存放的大小时，就会在栈上分配空间，称为过程的栈帧。在x86-64中，可以通过寄存器最多传递6个整型（整型和指针）参数，而过程只分配自己所需要的栈帧部分。寄存器组是唯一被所有过程共享的资源 对抗缓冲区溢出攻击：栈随机化、栈破坏检测、限制可执行代码区域 处理器体系结构流水线（取指、译指、执行、访存）提高了系统的吞吐量（单位时间内执行的指令数），但是会轻微增加延迟（从头到尾执行一条指令所需时长），是由于增加的流水线寄存器的时间开销 冒险指的是一条指令的位置或操作数依赖于其他仍在流水线中的指令。暂停用于避免冒险，此时处理器会停止流水线中的一条或多条指令，直到冒险条件不再满足。将结果值直接从一个流水线阶段传到较早阶段的技术称为数据转发 因为内存读在流水线发生的比较晚，有时会产生加载/使用冒险，此时可用暂停来处理，称为加载互锁，可与转发技术结合起来处理所有可能类型的数据冒险，并且只有加载互锁会降低流水线的吞吐量 暂停和往流水线中插入气泡的技术可以动态调整流水线的流程，避免控制冒险 由流水线中最深的指令引起的异常，优先级最高 优化程序性能 限制编译器只进行安全的优化。比如编译器必须假设不同的指针可能会指向内存中同一个位置，即内存别名使用，或者函数调用时修改了全局状态的一部分，改变调用它的次数会改变程序的行为。 延迟界限（指一系列操作必须严格按照顺序执行）和吞吐量界限（刻画了处理器功能单元的原始能力）限制了程序的最大性能","categories":[{"name":"生活","slug":"生活","permalink":"http://goodguyjameswin.github.io/categories/生活/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://goodguyjameswin.github.io/tags/学习笔记/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"http://goodguyjameswin.github.io/categories/生活/"}]},{"title":"java学习","slug":"java学习","date":"2021-09-08T03:01:24.000Z","updated":"2021-10-29T08:01:31.187Z","comments":false,"path":"2021/09/08/java学习/","link":"","permalink":"http://goodguyjameswin.github.io/2021/09/08/java学习/","excerpt":"","text":"Java基础应该是场持久战，先做好记录。。，学习笔记摘录于How2J HelloWorld创建txt文件，写入代码实现打印”helloworld“，改后缀名变为java源文件，需要在命令行里用javac命令编译成class文件后运行 javac filename.java java classname 变量类型整型数据类型byte、short、int的long缺省值都为0，默认的整数字面值是int类型，长度分别为8、16、32、64位（有符号数） char类型的值用单引号’表示 (双引号表示字符串)，其长度和short一样，只能存放一个字符，超过一个字符就会产生编译错误 浮点数类型float、double分别为32、64位，缺省值都为0.0，默认的小数值是double类型，在数字后面加一个字母f，直接把该数字声明成float类型 布尔类型boolean用于表示真假，长度为1，缺省值为false，虽然布尔型真正存放的数据是0（false）、1（true）但是，不能直接使用0、1进行赋值 String其实并不是基本数据类型，String类型是Immutable的，一旦创建就不能够被改变 public class HelloWorld { public static void main(String[] args) { long val = 26L; //以L结尾的字面值表示long型 int decVal = 26; //默认就是int型 int hexVal = 0x1a; //16进制 int oxVal = 032; //8进制 int binVal = 0b11010; //2进制 float f1 = 123.4F; // 以F结尾的字面值表示float类型 double d1 = 123.4; // 默认就是double类型 double d2 = 1.234e2; // 科学计数法表示double，e2表示10的二次方 } } 如果任何运算单元的长度都不超过int，那么其结果就是int。如果有任何运算单元的长度超过int，那么结果就按照最长的长度计算 public class HelloWorld { public static void main(String[] args) { byte b = 5; int i1 = 10; int i2 = 300; b = (byte) i1; //因为i1的值是在byte范围之内，所以即便进行强制转换 //最后得到的值，也是10 System.out.println(b); //因为i2的值是在byte范围之外，所以就会按照byte的长度进行截取 //i2的值是300，其对应的二进制数是 100101100 //按照byte的长度8位进行截取后，其值为 00101100 即44 b =(byte) i2; System.out.println(b); //查看一个整数对应的二进制的方法： System.out.println(Integer.toBinaryString(i2)); } } 作用域类的属性和方法名称一般来说，都是小写，如果有多个单词组成，后面的单词的第一个字母大写，比如moveSpeed 当一个变量被声明在类下面，变量就叫做字段或者属性、成员变量、Field，其作用域就是从其声明的位置开始的整个类 如果一个变量，是声明在一个方法上的，就叫做参数，参数的作用域即为该方法内的所有代码，其他方法不能访问该参数，类里面也不能访问该参数 声明在方法内的变量，叫做局部变量，其作用域在声明开始的位置，到其所处于的块结束位置 属性的作用域在方法中，参数的作用域也在方法中，如果属性和参数命名相同 public class HelloWorld { int i = 1; //属性名是i public void method1(int i) { //参数也是i System.out.println(i); } public static void main(String[] args) { new HelloWorld().method1(5); //结果打印出来是 5 } } 当一个变量被final修饰的时候，该变量只有一次赋值的机会 public class HelloWorld { public void method1(final int j) { j = 5; //这个不能执行 } } 以;结尾的一段代码，即为一个表达式，一个空;也是一个表达式。从 { 开始到对应的 } 结束，即一个块 操作符Scanner需要注意的是，如果在通过nextInt()读取了整数后，再接着读取字符串，读出来的是回车换行:”\\r\\n”,因为nextInt仅仅读取数字信息，而不会读取回车换行”\\r\\n”. 所以，如果在业务上需要读取了整数后，接着读取字符串，那么就应该连续执行两次nextLine()，第一次是取走回车换行，第二次才是读取真正的字符串 import java.util.Scanner; public class HelloWorld { public static void main(String[] args) { Scanner s = new Scanner(System.in); float a = s.nextFloat(); System.out.printIn(&quot;读取的浮点数的值是：&quot;+a); int a = s.nextInt(); System.out.printIn(&quot;第一个整数：&quot;+a); String rn = s.nextLine(); String a = s.nextLine(); System.out.printIn(&quot;读取的字符串是：&quot;+a); } } 逻辑操作符无论&amp;&amp;还是&amp;，两边的运算单元都是布尔值，都为真时，才为真，任意为假，就为假。&amp;&amp;两侧，都会被运算，&amp;只要第一个是false，第二个就不进行运算了 无论||还是|，两边的运算单元都是布尔值，都为真时，才为真，任意为假，就为假。||两侧，都会被运算，|只要第一个是false，第二个就不进行运算了 通过Integer.toBinaryString()方法，可将一个十进制整数转换为一个二进制字符串 带符号右移&gt;&gt;，对于正数，会把所有的位右移，并在最前面补0，对于负数，会把所有的位右移，并在最前面补1。无符号右移&gt;&gt;&gt;，如果是一个负数，那么对应的二进制的第一位是1，会把第一位的1也向右移动，导致移动后，第一位变成0，这样就会使得负数在无符号右移后，得到一个正数 控制流程switchswitch可以使用byte、short、int、char、String和enum，每个表达式结束，都应该有一个break，String在Java1.7之前是不支持的，Java从1.7开始支持switch用String的，编译后是把String转化为hash值，其实还是整数 循环break;只能结束当前循环，使用标签结束外部循环 public class HelloWorld { public static void main(String[] args) { //打印单数 outloop: //outloop这个标示是可以自定义的比如outloop1,ol2,out5 for (int i = 0; i &lt; 10; i++) { for (int j = 0; j &lt; 10; j++) { System.out.println(i+&quot;:&quot;+j); if(0==j%2) break outloop; //如果是双数，结束外部循环 } } } } 数组创建数组public class HelloWorld { public static void main(String[] args) { //声明一个引用，但如果仅仅是这一句声明，则不会创建数组 int[] a; //创建一个长度是5的数组，并且使用引用a指向该数组 a = new int[5]; //创建数组时，要指明数组的长度 int[] b = new int[5]; //声明的同时，指向一个数组 } } 获取0-100的随机整数，Math.random()，会得到一个0-1之间的随机浮点数 (int) (Math.random() * 100) 给数组分配空间、赋值，数组的长度是不可变的 public class HelloWorld { public static void main(String[] args) { //写法一： 分配空间同时赋值 int[] a = new int[]{100,102,444,836,3236}; //写法二： 省略了new int[],效果一样 int[] b = {100,102,444,836,3236}; //写法三：同时分配空间，和指定内容 //在这个例子里，长度是3，内容是5个，产生矛盾了 //所以如果指定了数组的内容，就不能同时设置数组的长度 int[] c = new int[3]{100,102,444,836,3236}; } } 把一个数组的值，复制到另一个数组中 System.arraycopy(src, srcPos, dest, destPos, length) src: 源数组 srcPos: 从源数组复制数据的起始位置 dest: 目标数组 destPos: 复制到目标数组的起始位置 length: 复制的长度 增强型for循环只能用来取值，却不能用来修改数组里的值 int[] a = new int[5]; for(int i = 0; i &lt; a.length; i++) { a[i] = (int) (Math.random() * 100); System.out.println(&quot;数组值依次为：&quot; + a[i]); } //增强型for循环遍历 for (int each : a) { System.out.println(each); } 二维数组二维数组里的每一个元素，都是一个一维数组 public class HelloWorld { public static void main(String[] args) { //初始化二维数组， int[][] a = new int[2][3]; //有两个一维数组，每个一维数组的长度是3 a[1][2] = 5; //可以直接访问一维数组，因为已经分配了空间 //只分配了二维数组 int[][] b = new int[2][]; //有两个一维数组，每个一维数组的长度暂未分配 b[0] =new int[3]; //必须事先分配长度，才可以访问 b[0][2] = 5; //指定内容的同时，分配空间 int[][] c = new int[][]{ {1,2,4}, {4,5}, {6,7,8,9} }; } } ArraysArrays是针对数组的工具类 import java.util.Arrays; public class HelloWorld { public static void main(String[] args) { int a[] = new int[] { 18, 62, 68, 82, 65, 9 }; // copyOfRange(int[] original, int from, int to) // 第一个参数表示源数组 // 第二个参数表示开始位置(取得到) // 第三个参数表示结束位置(取不到) // System.arraycopy，需要事先准备好目标数组，并分配长度。不同的是，copyOfRange只需要源数组就就可以了，通过返回值，就能够得到目标数组了 int[] b = Arrays.copyOfRange(a, 0, 3); // Arrays提供了一个toString()方法，直接把一个数组，转换为字符串 String content = Arrays.toString(a); // Arrays工具类提供了一个sort方法，只需要一行代码即可完成排序功能 Arrays.sort(a); // 查询元素出现的位置，需要注意的是，使用binarySearch进行查找之前，必须使用sort进行排序，如果数组中有多个相同的元素，查找结果是不确定的 Arrays.binarySearch(a, 62); // 比较两个数组的内容是否一样 Arrays.equals(a, b); // 使用同一个值，填充整个数组 Arrays.fill(a, 5); } } 类和对象引用如果一个变量的类型是 类类型，而非基本类型，那么该变量又叫做引用 Hero h = new Hero(); // 使用一个引用来指向这个对象 Hero h1 = new Hero(); Hero h2 = h1; // h2指向h1所指向的对象 第一行，引用garen指向新创建的对象（对象1）；第二行，同一个引用garen指向新创建的对象（对象2）。这个时候，对象1，就没有任何引用指向了，换句话说，就没有任何手段控制和访问该对象，那么该对象就变得没有意义 Hero garen = new Hero(); garen = new Hero(); 方法重载设计采用可变数量参数的方法，在方法里，使用操作数组的方式处理参数 public void attack(Hero h1) public void attack(Hero h1,Hero h2) public void attack(Hero h1,Hero h2,Hero h3) // 可变数量的参数 public void attack(Hero... heros) { for (int i = 0; i &lt; heros.length; i++) { System.out.println(name + &quot; 攻击了 &quot; + heros[i].name); } } 构造方法名和类名一样（包括大小写），没有返回类型，实例化一个对象时，必然调用构造方法，如果不自己定义，就会默认提供一个无参的构造方法，一旦提供了一个有参的构造方法，同时没有显式提供一个无参的构造方法，就不会提供默认的无参构造方法了 构造方法如果要在一个构造方法中，调用另一个构造方法，可以使用this() //带一个参数的构造方法 public Hero(String name){ System.out.println(&quot;一个参数的构造方法&quot;); this.name = name; } //带两个参数的构造方法 public Hero(String name,float hp){ this(name); System.out.println(&quot;两个参数的构造方法&quot;); this.hp = hp; } 传参如果一个变量是基本类型，=符号就表示赋值的意思。如果一个变量是类类型，=符号则表示指向的意思 当变量作为基本类型传递时，在方法内，无法修改方法外的基本类型参数。当变量为类类型传递时，实质传递的是该引用的地址，内部对形参修改影响的只是引用的地址新指向，除非修改对象.属性值，才能真正影响外部实参 访问修饰符 从作用域来看，public能够使用所有的情况 属性通常使用private封装起来 方法一般使用public用于被调用 会被子类继承的方法，通常使用protected package用的不多，一般新手会用package,因为还不知道有修饰符这个东西 作用范围最小原则，简单说，能用private就用private，不行就放大一级，用package，再不行就用protected，最后用public。这样就能把数据尽量的封装起来，没有必要露出来的，就不用露出来了 类属性当一个属性被static修饰的时候，就叫做类属性，又叫做静态属性。当一个属性被声明成类属性，那么所有的对象，都共享一个值 访问类属性可以使用 对象.类属性 类.类属性 类方法访问类方法可以使用 对象.类方法 类.类方法 如果方法里访问了对象属性，那么这个方法，就必须设计为对象方法。如果一个方法，没有调用任何对象属性，那么就可以考虑设计为类方法，这样更带有功能性色彩 初始化package charactor; public class Hero { // 对象属性初始化 public String name = &quot;some hero&quot;; //声明该属性的时候初始化 protected float hp; float maxHP; { maxHP = 200; //初始化块 } public Hero(){ hp = 100; //构造方法中初始化 } // 类属性初始化 public static int itemCapacity=8; //声明的时候 初始化 static{ itemCapacity = 6;//静态初始化块 初始化 } } 单例模式单例模式又叫做Singleton模式，指的是一个类，在一个JVM里，只有一个实例存在 构造方法私有化 静态属性指向实例 public static的getInstance方法，返回第二步的静态属性 package charactor; // 饿汉式单例模式 public class GiantDragon { //私有化构造方法使得该类无法在外部通过new 进行实例化 private GiantDragon(){} //准备一个类属性，指向一个实例化对象。 因为是类属性，所以只有一个 private static GiantDragon instance = new GiantDragon(); //public static 方法，提供给调用者获取12行定义的对象 public static GiantDragon getInstance(){ return instance; } } // 懒汉式单例模式 public class GiantDragon { //私有化构造方法使得该类无法在外部通过new 进行实例化 private GiantDragon(){} //准备一个类属性，用于指向一个实例化对象，但是暂时指向null private static GiantDragon instance; //public static 方法，返回实例对象 public static GiantDragon getInstance(){ //第一次访问的时候，发现instance没有指向任何对象，这时实例化一个对象 if(null==instance){ instance = new GiantDragon(); } //返回 instance指向的对象 return instance; } } 饿汉式是立即加载的方式，无论是否会用到这个对象，都会加载。懒汉式，是延迟加载的方式，只有使用的时候才会加载 枚举类型枚举enum是一种特殊的类（还是类），使用枚举可以很方便的定义常量 public enum Season { SPRING,SUMMER,AUTUMN,WINTER } public class HelloWorld { public static void main(String[] args) { // 在switch语句中，使用枚举来进行判断 Season season = Season.SPRING; switch (season) { case SPRING: System.out.println(&quot;春天&quot;); break; case SUMMER: System.out.println(&quot;夏天&quot;); break; case AUTUMN: System.out.println(&quot;秋天&quot;); break; case WINTER: System.out.println(&quot;冬天&quot;); break; } // 借助增强型for循环，可以很方便的遍历一个枚举都有哪些常量 for (Season s : Season.values()) { System.out.println(s); } } } 使用枚举，就能把常量season的取值范围限定在枚举类型Season的四个值当中 接口和继承对象转型引用类型和对象类型不一致时，才需要进行类型转换。所有的子类转换为父类都是可以的，父类转子类必须进行强制转换（有时候会失败）。没有继承关系的两个类互相转换，一定会失败。实现了接口的类型可以转换成接口。 instanceof判断一个引用所指向的对象 //判断引用h1指向的对象，是否是ADHero类型 System.out.println(h1 instanceof ADHero); 多态同一类型，调用同一个方法，却能呈现出不同的状态。类的多态，指的是父类引用指向子类对象 隐藏隐藏，就是子类覆盖父类的类方法。父类引用指向子类对象时，如果父类和子类创建的是静态方法，结果会调用引用所在的父类方法；如果父类和子类创建的是非静态方法，结果会调用引用所指向的子类方法 super实例化子类会调用其构造方法，其父类的构造方法也一定会被调用，且后者先调用，子类构造方法会默认调用父类的无参构造方法。可以使用关键字super显式调用父类带参的构造方法和父类的属性 若父类提供了有参构造方法，未提供无参构造方法，则需要在父类中显式提供无参构造方法，或者子类显式调用父类有参构造方法，否则实例化子类时会报错 object所有类都默认继承了Object类，它提供了一个toString方法，用来打印返回当前对象的字符串表达 当一个对象没有任何引用指向的时候，它就满足垃圾回收的条件，当它被回收的时候，它的finalize()方法就会被调用 equals()方法用于判断两个对象的内容是否相同，==不是Object的方法，用于判断两个引用是否指向了同一个对象 hashcode()方法返回一个对象的哈希值，线程同步相关方法wait()、notify()、notifyAll()。getClass()会返回一个对象的类对象 finalfinal修饰类，表示其不能被继承；修饰方法，表示其不能被重写；修饰基本类型变量，表示其只有一次赋值机会；修饰引用，表示其只有一次指向对象的机会；String类是final的，不能被继承 public static final int itemTotalNumber = 6; // 指的是常量，不会变化，公开，可以直接访问 抽象类public abstract void attack(); // 抽象方法 当一个类里有抽象方法时，它必须被声明为抽象类，一个类也可以在不提供抽象方法的前提下，声明为抽象类，一旦声明，就不能被直接实例化 抽象类的子类必须提供父类中抽象方法的具体实现。子类只能继承一个抽象类，但是可以实现多个接口，抽象类的属性定义方式与一般的类相同，但是接口中声明的属性，只能是public、静态、final的，即便没有显式地声明 内部类非静态内部类需要建立在外部类的基础上，且可以直接访问外部类的private实例属性，语法：new 外部类().new 内部类() 静态内部类的实例化不需要以一个外部类的实例为基础，可以直接实例化，语法：new 外部类.静态内部类()，静态内部类不可以访问外部类的实例属性和方法，除了可以访问外部类的私有静态成员外，静态内部类和普通类没什么大的区别 匿名类指的是在声明一个类的同时实例化它，这个类，没有命名，本地类可以理解为有名字的匿名类 package charactor; public abstract class Hero { private String name; float hp; float armor; int moveSpeed; public abstract void attack(); // 非静态内部类，只有一个外部类对象存在的时候，才有意义 class BattleScore { int kill; int die; int assit; public void legendary() { if (kill &gt;= 8) System.out.println(name + &quot;超神！&quot;); else System.out.println(name + &quot;尚未超神！&quot;); } } static class EnemyCrystal{ int hp=5000; public void checkIfVictory(){ if(hp==0){ Hero.battleWin(); //静态内部类不能直接访问外部类的对象属性 System.out.println(name + &quot; win this game&quot;); } } } public static void main(String[] args) { //在匿名类中使用外部的局部变量damage 必须修饰为final int damage = 5; //事实上的匿名类，会在匿名类里声明一个damage属性，并且使用构造方法初始化该属性的值 //在attack中使用的damage，真正使用的是这个内部damage，而非外部damage //假设外部属性不需要声明为final //那么在attack中修改damage的值，就会被暗示为修改了外部变量damage的值 //但是他们俩是不同的变量，是不可能修改外部变量damage的 //所以为了避免产生误导，外部的damage必须声明为final,&quot;看上去&quot;就不能修改了 //在jdk8中，已经不需要强制修饰成final了，如果没有写final，不会报错，因为编译器偷偷的帮你加上了看不见的final Hero garen = new Hero(); garen.name = &quot;盖伦&quot;; // 实例化内部类 // BattleScore对象只有在一个Hero对象存在的时候才有意义 // 所以其实例化必须建立在一个外部类对象的基础之上 BattleScore score = garen.new BattleScore(); score.kill = 9; score.legendary(); // 实例化静态内部类 Hero.EnemyCrystal crystal = new Hero.EnemyCrystal(); crystal.checkIfVictory(); // 通常情况下，要使用一个接口或者抽象类，都必须创建一个子类，有的时候，为了快速使用，直接实例化一个抽象类，并“当场”实现其抽象方法。既然实现了抽象方法，那么就是一个新的类，只是这个类，没有命名，叫做匿名类 Hero h = new Hero(){ //当场实现attack方法 public void attack() { System.out.println(&quot;新的进攻手段&quot;); } }; h.attack(); //通过打印h，可以看到h这个对象属于Hero$1这么一个系统自动分配的类名 System.out.println(h); //与匿名类的区别在于，本地类有了自定义的类名。内部类与匿名类不一样的是，内部类必须声明在成员的位置，即与属性和方法平等的位置，本地类和匿名类一样，直接声明在代码块里面，可以是主方法，for循环里等等地方 class SomeHero extends Hero{ public void attack() { System.out.println( name+ &quot; 新的进攻手段&quot;); } } SomeHero h =new SomeHero(); h.name =&quot;地卜师&quot;; h.attack(); //这里使用本地类AnonymousHero来模拟匿名类的隐藏属性机制 class AnonymousHero extends Hero{ int damage; public AnonymousHero(int damage){ this.damage = damage; } public void attack() { damage = 10; System.out.printf(&quot;新的进攻手段，造成%d点伤害&quot;,this.damage ); } } Hero h = new AnonymousHero(damage); } } 默认方法默认方法是JDK8新特性，指的是接口也可以提供具体方法了，而不像以前，只能提供抽象方法 package charactor; public interface Mortal { public void die(); // Mortal这个接口，增加了一个默认方法revive，这个方法有实现体，并且被声明为了default default public void revive() { System.out.println(&quot;本英雄复活了&quot;); } } 接口默认方法Override问题：如果是实现多个接口同时这些接口中都实现了同样的默认方法，那么实现的子类必须要实现这个默认方法（因为不知道要选择哪个方法）。而只要默认方法只有一个那么就可以不用实现（比如AP实现了默认方法，AD没实现，那么两个都实现的子类也不用实现），或者只实现了一个接口，那么子类也不用实现 UMLUML图中，实线表示继承关系，虚线表示实现关系 数字和字符串封装类所有的基本类型，都有对应的类类型，数字封装类有Byte、Short、Interger、Long、Float和Double，这些类都是抽象类Number的子类 //把一个基本类型的变量,转换为Integer对象 Integer it = new Integer(i); //把一个Integer对象，转换为一个基本类型的int int i2 = it.intValue(); 不需要调用构造方法，通过=符号自动把基本类型转换为类类型叫装箱，反过来就叫拆箱。基本类型的最值可以通过其对应的 封装类.MAX_VALUE、封装类.MIN_VALUE获取 字符串转换//使用String类的静态方法valueOf String str = String.valueOf(i); //先把基本类型装箱为对象，然后调用对象的toString Integer it = i; String str2 = it.toString(); //调用Integer的静态方法parseInt int i= Integer.parseInt(str); 数字方法import java.lang.Math Math.round(1.5);//四舍五入 Math.sqrt(9);//开方 Math.pow(2,4);//乘方 Math.PI;//π Math.E;//自然常数 格式化字符串printf和format能够达到一样的效果，在printf中直接调用了format //使用格式化输出 //%s表示字符串，%d表示数字,%n表示换行 String sentenceFormat =&quot;%s 在进行了连续 %d 次击杀后，获得了 %s 的称号%n&quot;; System.out.printf(sentenceFormat,name,kill,title); //使用format格式化输出 System.out.format(sentenceFormat,name,kill,title); 回车符’\\r’就是回到一行的开头，代码里敲回车键实际上是回车换行符。不同的操作系统中，换行符是不一样的，使用%n，就可以做到平台无关的换行 在DOS和Windows中，每行结尾是 “\\r\\n”； Linux系统里，每行结尾只有 “\\n”； Mac系统里，每行结尾是只有 “\\r”。 CharCharacter.isLetter(&#39;a&#39;); //判断是否为字母 Character.isDigit(&#39;a&#39;); //判断是否为数字 Character.isWhitespace(&#39; &#39;); //是否是空白 Character.isUpperCase(&#39;a&#39;); //是否是大写 Character.isLowerCase(&#39;a&#39;); //是否是小写 Character.toUpperCase(&#39;a&#39;); //转换为大写 Character.toLowerCase(&#39;A&#39;); //转换为小写 String a = &#39;a&#39;; //不能够直接把一个字符转换成字符串 String a2 = Character.toString(&#39;a&#39;); //转换为字符串 String str = &quot;abc123&quot;; char[] cs = str.toCharArray(); //字符串转换为字符数组 char[] cs = new char[]{&#39;崔&#39;,&#39;斯&#39;,&#39;特&#39;}; String hero = new String(cs);//通过字符数组创建一个字符串对象 字符串对象是immutable的，对象方法length()返回字符串的长度 String sentenceFormat =&quot;%s 在进行了连续 %d 次击杀后，获得了 %s 的称号%n&quot;; String sentence2 = String.format(sentenceFormat, name,kill,title); //格式化字符串 String unknowHero = &quot;&quot;; //可以有长度为0的字符串,即空字符串 System.out.println(unknowHero.length()); StringString sentence = &quot;盖伦,在进行了连续8次击杀后,获得了 超神 的称号&quot;; char c = sentence.charAt(0); //charAt(int index)获取指定位置的字符 char[] cs = sentence.toCharArray(); //toCharArray()获取对应的字符数组 String subString1 = sentence.substring(3); //截取从第3个开始的字符串 （基0） //截取从第3个开始的字符串 （基0），到5-1的位置的字符串，左闭右开 String subString2 = sentence.substring(3,5); //根据,进行分割，得到3个子字符串 String subSentences[] = sentence.split(&quot;,&quot;); sentence.trim(); //去掉首尾空格 sentence.toLowerCase(); //全部变成小写 sentence.toUpperCase(); //全部变成大写 sentence.indexOf(&#39;8&#39;); //字符第一次出现的位置 sentence.indexOf(&quot;超神&quot;); //字符串第一次出现的位置 sentence.lastIndexOf(&quot;了&quot;); //字符串最后出现的位置 sentence.indexOf(&#39;,&#39;,5); //从位置5开始，出现的第一次,的位置 sentence.contains(&quot;击杀&quot;); //是否包含字符串&quot;击杀&quot; String temp = sentence.replaceAll(&quot;击杀&quot;, &quot;被击杀&quot;); //替换所有的 temp = sentence.replaceFirst(&quot;,&quot;,&quot;&quot;); //只替换第一个 一般来说，编译器没碰到一个字符串的字符串的字面值，就会创建一个新的对象，但如果编译器编译过程中发现已经存在现成的字符串字面值的对象，那么就直接拿来使用，而不会进行重复创建 // ==用于判断是否是同一个字符串对象 System.out.println( str1 == str2); System.out.println(str1.equals(str3));// 使用equals进行字符串内容的比较，必须大小写一致 System.out.println(str1.equalsIgnoreCase(str3));// equalsIgnoreCase，忽略大小写判断内容是否一致 System.out.println(str1.startsWith(start));//以...开始 System.out.println(str1.endsWith(end));//以...结束 StringBuffer和String内部是一个字符数组一样，StringBuffer也维护了一个字符数组。但是，这个字符数组，留有冗余长度 String str1 = &quot;let there &quot;; StringBuffer sb = new StringBuffer(str1); //根据str1创建一个StringBuffer对象 sb.append(&quot;be light&quot;); //在最后追加 sb.delete(4, 10); //删除4-10之间的字符 sb.insert(4, &quot;there &quot;); //在4这个位置插入 there sb.reverse(); //反转 System.out.println(sb.length()); //内容长度 System.out.println(sb.capacity());//总空间，容量 日期零.零这个数字，代表Java中的时间原点，其对应的日期就是1970年1月1日8点0分0秒 import java.util.Date; //而非 java.sql.Date，此类是给数据库访问的时候使用的 // 从1970年1月1日 早上8点0分0秒 开始经历的毫秒数 Date d2 = new Date(5000); Date now= new Date(); //getTime() 得到一个long型的整数 //这个整数代表 1970.1.1 08:00:00:000，每经历一毫秒，增加1 System.out.println(&quot;当前时间getTime()返回的值是：&quot;+now.getTime()); //通过System.currentTimeMillis()获取当前日期的毫秒数，和new Date.getTime()是一样的 System.out.println(&quot;System.currentTimeMillis() \\t返回值: &quot;+System.currentTimeMillis()); y 代表年 M 代表月 d 代表日 H 代表24进制的小时 h 代表12进制的小时 m 代表分钟 s 代表秒 S 代表毫秒 import java.text.SimpleDateFormat; SimpleDateFormat sdf =new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss SSS&quot; ); Date d= new Date(); String str = sdf.format(d); System.out.println(&quot;当前时间通过 yyyy-MM-dd HH:mm:ss SSS 格式化后的输出: &quot;+str); //模式（yyyy/MM/dd HH:mm:ss）需要和字符串格式保持一致，如果不一样就会抛出解析异常ParseException String str = &quot;2016/1/5 12:12:12&quot;; Date d = sdf.parse(str); System.out.printf(&quot;字符串 %s 通过格式 yyyy/MM/dd HH:mm:ss %n转换为日期对象: %s&quot;,str,d.toString()); 采用单例模式获取日历对象 import java.util.Calendar; Calendar c = Calendar.getInstance(); //通过日历对象得到日期对象 Date now = c.getTime(); Date d2 = new Date(0); c.setTime(d2); //把这个日历，调成日期 : 1970.1.1 08:00:00 // 下个月的今天 c.setTime(now); c.add(Calendar.MONTH, 1); System.out.println(&quot;下个月的今天:\\t&quot; +format(c.getTime())); // 去年的今天 c.setTime(now); c.add(Calendar.YEAR, -1); System.out.println(&quot;去年的今天:\\t&quot; +format(c.getTime())); // 上个月的第三天 c.setTime(now); c.add(Calendar.MONTH, -1); c.set(Calendar.DATE, 3); System.out.println(&quot;上个月的第三天:\\t&quot; +format(c.getTime())); Java中级异常如果代码运行时未发生异常，则顺序往下执行，并且不执行catch块中的代码，否则，try里的代码会立即终止，程序流程会运行到对应的catch块中，e.printStackTrace()，会打印出方法的调用痕迹 import java.io.File; import java.io.FileInputStream; import java.io.FileNotFoundException; import java.text.ParseException; File f= new File(&quot;d:/LOL.exe&quot;); //若文件不存在，而试图打开文件LOL.exe，会抛出FileNotFoundException，如果不处理该异常，就会有编译错误 try{ System.out.println(&quot;试图打开 d:/LOL.exe&quot;); new FileInputStream(f); Date d = sdf.parse(&quot;2016-06-03&quot;); System.out.println(&quot;成功打开&quot;); } //FileNotFoundException是Exception的子类，使用Exception也可以catch到FileNotFoundException catch(FileNotFoundException e){ System.out.println(&quot;d:/LOL.exe不存在&quot;); e.printStackTrace(); }catch (ParseException e) { System.out.println(&quot;日期格式解析错误&quot;); e.printStackTrace(); } //有时候一段代码会抛出多种异常，可以分别进行catch，也可以把多个异常，放在一个catch里统一捕捉 //好处是捕捉的代码更紧凑，不足之处是，一旦发生异常，不能确定到底是哪种异常，需要通过instanceof进行判断具体的异常类型 catch (FileNotFoundException | ParseException e) { if (e instanceof FileNotFoundException) System.out.println(&quot;d:/LOL.exe不存在&quot;); if (e instanceof ParseException) System.out.println(&quot;日期格式解析错误&quot;); } finally{ System.out.println(&quot;无论文件是否存在， 都会执行的代码&quot;); } //如果方法需要进行异常处理，但是方法体内不打算处理，可以在声明时把这个异常通过throws跑出去，外层调用此方法时就会接到这个异常，可以选择try catch处理掉，要么也是抛出去，如果处理掉了，继续往外的外层调用就不需要进行异常处理了 private static void method2() throws FileNotFoundException {} throws出现在方法声明上，而throw通常都出现在方法体内。throws表示出现异常的一种可能性，并不一定会发生这些异常；throw则是抛出了异常，执行throw则一定抛出了某个异常对象 如果一个有返回值的方法中进行了try catch的异常处理，那么在try和catch中有return依然会执行finally中的代码，若finally有返回值，那么将会覆盖try或是catch中返回的代码 可查异常：CheckedException，即必须进行处理的异常 运行时异常RuntimeException，即不是必须进行try catch的异常，常见的运行时异常有：ArithmeticException（除数不能为零异常）、ArrayIndexOutOfBoundsException（下标越界异常）、NullPointerException（空指针异常），与可查异常不同之处在于，即便不进行try catch，没有用throws子句声明抛出它，也不会有编译错误 错误Error，指的是系统级别的异常，通常是内存用光了，抛出OutOfMemoryError。在默认设置下，一般java程序启动的时候，最大可以使用16m的内存。与运行时异常一样，错误也是不要求强制捕捉的 Throwable是类，Exception和Error都继承了该类。所以在捕捉的时候，也可以使用Throwable进行捕捉 //自定义异常 class EnemyHeroIsDeadException extends Exception{ public EnemyHeroIsDeadException(){} public EnemyHeroIsDeadException(String msg){ super(msg); } } //声明该方法通过throws抛出该异常 public void attackHero(Hero h) throws EnemyHeroIsDeadException{ if(h.hp == 0){ //通过throw抛出该异常 throw new EnemyHeroIsDeadException(h.name + &quot; 已经挂了,不需要施放技能&quot; ); } } //捕捉异常的时候，可以通过 异常类名.getMessage() 获取当时出错的具体原因 I/O文件和字节流// 绝对路径 File f1 = new File(&quot;d:/LOLFolder&quot;); //System.out.println(&quot;当前文件是：&quot; +f); // 会打印出文件的绝对路径 // 相对路径,相对于工作目录 File f2 = new File(&quot;LOL.exe&quot;); // 把f1作为父目录创建文件对象 File f3 = new File(f1, &quot;LOL.exe&quot;); System.out.println(&quot;f3的绝对路径：&quot; + f3.getAbsolutePath()); //文件是否存在 System.out.println(&quot;判断是否存在：&quot;+f.exists()); //是否是文件夹 System.out.println(&quot;判断是否是文件夹：&quot;+f.isDirectory()); //是否是文件（非文件夹） System.out.println(&quot;判断是否是文件：&quot;+f.isFile()); //文件长度 System.out.println(&quot;获取文件的长度：&quot;+f.length()); //文件最后修改时间 long time = f.lastModified(); Date d = new Date(time); System.out.println(&quot;获取文件的最后修改时间：&quot;+d); //设置文件修改时间为1970.1.1 08:00:00 f.setLastModified(0); //文件重命名 File f2 =new File(&quot;d:/LOLFolder/DOTA.exe&quot;); f.renameTo(f2); // 以字符串数组的形式，返回当前文件夹下的所有文件（不包含子文件及子文件夹） f = f.getParent(); f.list(); // 以文件数组的形式，返回当前文件夹下的所有文件（不包含子文件及子文件夹） File[] fs= f.listFiles(); // 以字符串形式返回获取所在文件夹 f.getParent(); // 以文件形式返回获取所在文件夹 f.getParentFile(); // 创建文件夹，如果父文件夹skin不存在，创建就无效 f.mkdir(); // 创建文件夹，如果父文件夹skin不存在，就会创建父文件夹 f.mkdirs(); // 创建一个空文件,如果父文件夹skin不存在，就会抛出异常 f.createNewFile(); // 所以创建一个空文件之前，通常都会创建父目录 f.getParentFile().mkdirs(); // 列出所有的盘符c: d: e: 等等 f.listRoots(); // 刪除文件 f.delete(); // JVM结束的时候，刪除文件，常用于临时文件的删除 f.deleteOnExit(); // OutputStream是字节输出流，同时也是抽象类，只提供方法声明，不提供方法的具体实现。FileOutputStream 是OutputStream子类 import java.io.FileOutputStream File f = new File(&quot;d:/Downloads/source/test.txt&quot;); // 创建基于文件的输入流 FileInputStream fis = new FileInputStream(f); // 通过这个输入流，就可以把数据从硬盘，读取到Java的虚拟机中来，也就是读取到内存中 // 创建字节数组，其长度就是文件的长度 byte[] all =new byte[(int) f.length()]; // 以字节流的形式读取文件所有内容 fis.read(all); for (byte b : all) { //打印出来是65 66 System.out.println(b); } // 每次使用完流，都应该进行关闭 fis.close(); // 准备长度是2的字节数组，用88,89初始化，其对应的字符分别是X,Y byte data[] = { 88, 89 }; // 创建基于文件的输出流 FileOutputStream fos = new FileOutputStream(f); // 把数据写出到输出流 fos.write(data); // 关闭输出流 fos.close(); //如果文件d:/Downloads/source/test.txt不存在，写出操作会自动创建该文件。但是如果是文件d:/Downloads/source/xyz/test.txt，而目录xyz又不存在，会抛出异常，此时可以： //首先获取文件所在的目录 // File dir = f.getParentFile(); //如果该目录不存在，则创建该目录 // if(!dir.exists()){ // dir.mkdir(); //使用mkdir会抛出异常，因为该目录的父目录也不存在 // dir.mkdirs(); //使用mkdirs则会把不存在的目录都创建好 // } 在try的作用域里关闭文件输入流，如果文件不存在，或者读取的时候出现问题而抛出异常，那么就不会执行这一行关闭流的代码，存在巨大的资源占用隐患。不推荐使用 标准的关闭流的方式包括在finally中关闭： 首先把流的引用声明在try的外面，如果声明在try里面，其作用域无法抵达finally. 在finally关闭之前，要先判断该引用是否为空 关闭的时候，需要再一次进行try catch处理 所有的流，都实现了一个接口叫做AutoCloseable，任何类实现了这个接口，都可以在try()中进行实例化。 并且在try, catch, finally结束的时候自动关闭，回收相关资源 //把流定义在try()里,try,catch或者finally结束的时候，会自动关闭，称为try-with-resources的编码方式，从JDK7开始支持 try(FileInputStream fis = new FileInputStream(f)) 字符流import java.io.FileReader; // ISO-8859-1 ASCII编码，一个字符对应一个字节的存储。GBK同时包含简体和繁体中文以及日文 // UNICODE编码，数字、字母和汉字占4个字节，对应的子编码UTF-8对数字和字母使用一个字节，而对汉字使用3个字节 // 准备文件lol.txt其中的内容是AB File f = new File(&quot;d:/lol.txt&quot;); // 创建基于文件的Reader try (FileReader fr = new FileReader(f)) { // 创建字符数组，其长度就是文件的长度 char[] all = new char[(int) f.length()]; // 以字符流的形式读取文件所有内容 fr.read(all); for (char b : all) { // 打印出来是A B System.out.println(b); } } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); } // 创建基于文件的Writer try (FileWriter fr = new FileWriter(f)) { // 以字符流的形式把数据写入到文件中 String data=&quot;abcdefg1234567890&quot;; char[] cs = data.toCharArray(); fr.write(cs); } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); } Java采用Unicode编码，写在java源代码中的汉字，在执行之后，都会变成JVM中的字符。ANSI这个不是ASCII的意思，而是采用本地编码的意思。如果是中文的操作系统，就会是GBK，如果是英文的就会是ISO-8859-1 import java.io.UnsupportedEncodingException; String[] encodes = { &quot;BIG5&quot;, &quot;GBK&quot;, &quot;GB2312&quot;, &quot;UTF-8&quot;, &quot;UTF-16&quot;, &quot;UTF-32&quot; }; for (String encode : encodes) { showCode(str, encode); } private static void showCode(String str, String encode) { try { System.out.printf(&quot;字符: \\&quot;%s\\&quot; 的在编码方式%s下的十六进制值是%n&quot;, str, encode); byte[] bs = str.getBytes(encode); for (byte b : bs) { int i = b&amp;0xff;// 只取16进制的后两位 System.out.print(Integer.toHexString(i) + &quot;\\t&quot;); } String str = new String(all, &quot;GBK&quot;);// 以对应编码方式识别这些字节数据，得到正确的字符 } catch (UnsupportedEncodingException e) { System.out.printf(&quot;UnsupportedEncodingException: %s编码方式无法解析字符%s\\n&quot;, encode, str); } } import java.io.InputStreamReader; import java.nio.charset.Charset; //FileReader得到的是字符，所以一定是已经把字节根据某种编码识别成了字符了 //而FileReader使用的编码方式是Charset.defaultCharset()的返回值，如果是中文的操作系统，就是GBK try (FileReader fr = new FileReader(f)) { char[] cs = new char[(int) f.length()]; fr.read(cs); System.out.printf(&quot;FileReader会使用默认的编码方式%s,识别出来的字符是：%n&quot;,Charset.defaultCharset()); System.out.println(new String(cs)); } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); } //FileReader是不能手动设置编码方式的，为了使用其他的编码方式，只能使用InputStreamReader来代替 //并且使用new InputStreamReader(new FileInputStream(f),Charset.forName(&quot;UTF-8&quot;)); 这样的形式 try (InputStreamReader isr = new InputStreamReader(new FileInputStream(f),Charset.forName(&quot;UTF-8&quot;))) { char[] cs = new char[(int) f.length()]; isr.read(cs); System.out.printf(&quot;InputStreamReader 指定编码方式UTF-8,识别出来的字符是：%n&quot;); System.out.println(new String(cs)); } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); } 如果是使用记事本另存为UTF-8的格式，那么在第一个字节有一个标示符，叫做BOM用来标志这个文件是用UTF-8来编码的 缓存流以介质是硬盘为例，字节流和字符流的弊端就是，在每一次读写的时候，都会访问硬盘。如果读写的频率比较高的时候，其性能表现不佳。而缓存流在读取的时候，会一次性读较多的数据到缓存中，以后每一次的读取，都是在缓存中访问，直到缓存中的数据读取完毕，再到硬盘中读取 import java.io.BufferedReader; import java.io.PrintWriter; // 创建文件字符流 // 缓存流必须建立在一个存在的流的基础上 try ( FileReader fr = new FileReader(f); BufferedReader br = new BufferedReader(fr); PrintWriter pw = new PrintWriter(fw); ) { while (true) { // 一次读一行 String line = br.readLine(); if (null == line) break; System.out.println(line); // 写入一行 pw.println(&quot;garen kill teemo&quot;); // 强制把缓存中的数据写入硬盘，无论缓存是否已满 pw.flush(); } } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); } flush用于立即把数据写入到存储介质中（硬盘） 数据流import java.io.DataInputStream; import java.io.DataOutputStream; private static void read() { File f =new File(&quot;d:/lol.txt&quot;); try ( FileInputStream fis = new FileInputStream(f); DataInputStream dis =new DataInputStream(fis); ){ // 使用数据流进行数据的格式化顺序读 boolean b= dis.readBoolean(); int i = dis.readInt(); String str = dis.readUTF(); System.out.println(&quot;读取到布尔值:&quot;+b); System.out.println(&quot;读取到整数:&quot;+i); System.out.println(&quot;读取到字符串:&quot;+str); } catch (IOException e) { e.printStackTrace(); } } private static void write() { File f =new File(&quot;d:/lol.txt&quot;); try ( FileOutputStream fos = new FileOutputStream(f); DataOutputStream dos =new DataOutputStream(fos); ){ // 使用数据流进行数据的格式化顺序写 dos.writeBoolean(true); dos.writeInt(300); dos.writeUTF(&quot;123 this is gareen&quot;); } catch (IOException e) { e.printStackTrace(); } } 要用DataInputStream读取一个文件，这个文件必须是由DataOutputStream写出的，否则会出现EOFException，因为DataOutputStream在写出的时候会做一些特殊标记，只有DataInputStream才能成功的读取 对象流对象流指的是可以直接把一个对象以流的形式传输给其他的介质，比如硬盘。一个对象以流的形式进行传输，叫做序列化。该对象所对应的类，必须是实现Serializable接口 import java.io.Serializable; public class Hero implements Serializable { //表示这个类当前的版本，如果有了变化，比如新设计了属性，就应该修改这个版本号 private static final long serialVersionUID = 1L; } import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import charactor.Hero; Hero h = new Hero(); //准备一个文件用于保存该对象 File f =new File(&quot;d:/garen.lol&quot;); try( //创建对象输出流 FileOutputStream fos = new FileOutputStream(f); ObjectOutputStream oos =new ObjectOutputStream(fos); //创建对象输入流 FileInputStream fis = new FileInputStream(f); ObjectInputStream ois =new ObjectInputStream(fis); ) { oos.writeObject(h); Hero h2 = (Hero) ois.readObject(); } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); } catch (ClassNotFoundException e) { // TODO Auto-generated catch block e.printStackTrace(); } System.inimport java.io.InputStream; import java.util.Scanner; // 控制台输入 try (InputStream is = System.in;) { while (true) { // 敲入a,然后敲回车可以看到 // 97 13 10 // 97是a的ASCII码 // 13 10分别对应回车换行 int i = is.read(); System.out.println(i); // 使用Scanner就可以逐行读取了 Scanner s = new Scanner(System.in); while(true){ String line = s.nextLine(); System.out.println(line); int a = s.nextInt(); System.out.println(&quot;读取一个整数：&quot;+a); } } } catch (IOException e) { e.printStackTrace(); } 集合框架ArrayListimport java.util.ArrayList; // 容器类ArrayList，用于存放对象 ArrayList heros = new ArrayList(); heros.add(new Hero(&quot;盖伦&quot;)); System.out.println(heros.size()); // 容器的容量&quot;capacity&quot;会随着对象的增加，自动增长 // 只需要不断往容器里增加对象即可，不用担心会出现数组的边界问题。 // add用于在指定位置增加对象 Hero specialHero = new Hero(&quot;special hero&quot;); heros.add(3, specialHero); // contains判断一个对象是否在容器中 // 判断标准： 是否是同一个对象，而不是name是否相同 System.out.println(heros.contains(new Hero(&quot;hero 1&quot;))); System.out.println(heros.contains(specialHero)); // get用于获取指定位置的对象 System.out.println(heros.get(5)); // indexOf用于判断一个对象在ArrayList中所处的位置，判断标准与contains一样 System.out.println(&quot;specialHero所处的位置:&quot;+heros.indexOf(specialHero)); System.out.println(&quot;新的英雄，但是名字是\\&quot;hero 1\\&quot;所处的位置:&quot;+heros.indexOf(new Hero(&quot;hero 1&quot;))); // remove可以根据下标删除ArrayList的元素 heros.remove(2); // 也可以根据对象删除 heros.remove(specialHero); // set用于替换指定位置的元素 heros.set(5, new Hero(&quot;hero 5&quot;)); // size用于获取ArrayList的大小 System.out.println(heros.size()); // toArray可以把一个ArrayList对象转换为数组 // 如果要转换为一个Hero数组，那么需要传递一个Hero数组类型的对象给toArray()，这样toArray方法才知道，你希望转换为哪种类型的数组，否则只能转换为Object数组 Hero hs[] = (Hero[])heros.toArray(new Hero[]{}); // addAll把另一个容器里所有的元素（对象），都加入到当前容器里来 ArrayList anotherHeros = new ArrayList(); heros.addAll(anotherHeros); // clear清空一个ArrayList heros.clear(); ArrayList实现了接口List，常见的写法会把引用声明为接口List类型 不指定泛型的容器，可以存放任何类型的元素。指定了泛型的容器，只能存放指定类型的元素以及其子类 import java.util.List; // 接口引用指向子类对象（多态） List heros = new ArrayList(); //对于不使用泛型的容器，可以往里面放英雄，也可以往里面放物品 heros.add(new Hero(&quot;盖伦&quot;)); //本来用于存放英雄的容器，现在也可以存放物品了 heros.add(new Item(&quot;冰杖&quot;)); //对象转型会出现问题 Hero h1= (Hero) heros.get(0); //尤其是在容器里放的对象太多的时候，就记不清楚哪个位置放的是哪种类型的对象了 Hero h2= (Hero) heros.get(1); //引入泛型Generic //声明容器的时候，就指定了这种容器，只能放Hero，放其他的就会出错 List&lt;Hero&gt; genericheros = new ArrayList&lt;Hero&gt;(); genericheros.add(new Hero(&quot;盖伦&quot;)); //如果不是Hero类型，根本就放不进去 //genericheros.add(new Item(&quot;冰杖&quot;)); //除此之外，还能存放Hero的子类 genericheros.add(new APHero()); //并且在取出数据的时候，不需要再进行转型了，因为里面肯定是放的Hero或者其子类 Hero h = genericheros.get(0); List&lt;Hero&gt; genericheros = new ArrayList&lt;Hero&gt;(); // JDK7提供了一个可以略微减少代码量的泛型简写方式 List&lt;Hero&gt; genericheros2 = new ArrayList&lt;&gt;(); // 后面的泛型可以用&lt;&gt;来代替 import java.util.Iterator; // 迭代器的while写法 Iterator&lt;Hero&gt; it= heros.iterator(); //从最开始的位置（首位的前一位，空位置）判断&quot;下一个&quot;位置是否有数据（hasNext()方法） //如果有就通过next()取出来，并且把指针向下移动 //直到&quot;下一个&quot;位置没有数据 while(it.hasNext()){ Hero h = it.next(); System.out.println(h); } //迭代器的for写法 for (Iterator&lt;Hero&gt; iterator = heros.iterator(); iterator.hasNext();) { Hero hero = (Hero) iterator.next(); System.out.println(hero); } LinkedListLinkedList实现了List接口，还实现了双向链表结构Deque和Queue接口（队列） import java.util.LinkedList; import java.util.Queue; //LinkedList是一个双向链表结构的list LinkedList&lt;Hero&gt; ll =new LinkedList&lt;Hero&gt;(); //所以可以很方便的在头部和尾部插入数据 //在最后插入新的英雄 ll.addLast(new Hero(&quot;hero1&quot;)); //在最前面插入新的英雄 ll.addFirst(new Hero(&quot;heroX&quot;)); //查看最前面的英雄 System.out.println(ll.getFirst()); //查看最后面的英雄 System.out.println(ll.getLast()); //查看不会导致英雄被删除 //取出最前面的英雄 System.out.println(ll.removeFirst()); //取出最后面的英雄 System.out.println(ll.removeLast()); //取出会导致英雄被删除 //和ArrayList一样，LinkedList也实现了List接口 List ll =new LinkedList&lt;Hero&gt;(); //所不同的是LinkedList还实现了Deque，进而又实现了Queue这个接口 //Queue代表FIFO 先进先出的队列 Queue&lt;Hero&gt; q= new LinkedList&lt;Hero&gt;(); //加在队列的最后面 q.offer(new Hero(&quot;Hero1&quot;)); //取出第一个Hero，FIFO 先进先出 Hero h = q.poll(); //把第一个拿出来看一看，但是不取出来 h=q.peek(); ArrayList插入，删除数据慢。LinkedList插入，删除数据快。ArrayList是顺序结构，定位很快。LinkedList是链表结构，定位慢 二叉树public class Node { // 左子节点 public Node leftNode; // 右子节点 public Node rightNode; // 值 public Object value; // 插入 数据 public void add(Object v) { // 如果当前节点没有值，就把数据放在当前节点上 if (null == value) value = v; // 如果当前节点有值，就进行判断，新增的值与当前值的大小关系 else { // 新增的值，比当前值小或者相同 if ((Integer) v -((Integer)value) &lt;= 0) { if (null == leftNode) leftNode = new Node(); leftNode.add(v); } // 新增的值，比当前值大 else { if (null == rightNode) rightNode = new Node(); rightNode.add(v); } } } // 中序遍历所有的节点（此时遍历后的结果是从小到大的） public List&lt;Object&gt; values() { List&lt;Object&gt; values = new ArrayList&lt;&gt;(); // 左节点的遍历结果 if (null != leftNode) values.addAll(leftNode.values()); // 当前节点 values.add(value); // 右节点的遍历结果 if (null != rightNode) values.addAll(rightNode.values()); return values; } public static void main(String[] args) { int randoms[] = new int[] { 67, 7, 30, 73, 10, 0, 78, 81, 10, 74 }; Node roots = new Node(); for (int number : randoms) { roots.add(number); } System.out.println(roots.values()); } } 二叉树排序的第一个步骤是把数据插入到该二叉树中，小、相同的放左边，大的放右边，插入完之后，实际上就已经排好序了。二叉树的遍历分左序、中序和右序，左序即中间的数遍历后放在左边，中序即中间的数遍历后放在中间，右序即中间的数遍历后放在右边 HashMapimport java.util.HashMap; HashMap&lt;String, String&gt; dictionary = new HashMap&lt;&gt;(); dictionary.put(&quot;adc&quot;, &quot;物理英雄&quot;); System.out.printIn(dictionary.get(&quot;t&quot;)); // 清空map heroMap.clear(); 对于HashMap而言，key是唯一的，不可以重复的。以相同的key把不同的value插入到Map中会导致旧元素被覆盖，只留下最后插入的元素。不过，同一对象可以作为值插入到map中，只要对应的key不一样 import java.util.Hashtable; //HashMap和Hashtable都实现了Map接口，都是键值对保存数据的方式 HashMap&lt;String,String&gt; hashMap = new HashMap&lt;String,String&gt;(); //HashMap可以用null作key,作value hashMap.put(null, &quot;123&quot;); hashMap.put(&quot;123&quot;, null); Hashtable&lt;String,String&gt; hashtable = new Hashtable&lt;String,String&gt;(); //Hashtable不能用null作key，不能用null作value hashtable.put(null, &quot;123&quot;); hashtable.put(&quot;123&quot;, null); // Hashtable是线程安全的类，而HashMap不是 HashSetimport java.util.HashSet; HashSet&lt;String&gt; names = new HashSet&lt;String&gt;(); names.add(&quot;gareen&quot;); // 第二次插入同样的数据，是插不进去的，容器中只会保留一个 names.add(&quot;gareen&quot;); // Set不提供get方法来获取指定位置的元素 // numbers.get(0) // 遍历Set可以采用迭代器iterator for (Iterator&lt;Integer&gt; iterator = numbers.iterator(); iterator.hasNext();) { Integer i = (Integer) iterator.next(); System.out.println(i); } //或者采用增强型for循环 for (Integer i : numbers) { System.out.println(i); } Set中的元素，没有按照元素的插入顺序排列。HashSet的具体顺序也不是按照hashcode的顺序。同样是插入相同元素到HashSet中，在JVM的不同版本中，看到的顺序都是不一样的。因此开发的时候，不能依赖于某种臆测的顺序，这个顺序本身是不稳定的 HashSet自身并没有独立的实现，而是在里面封装了一个Map，HashSet是作为Map而存在的，而value是一个命名为PRESENT的static的Object对象，因为是一个类属性，所以只会有一个 Set中的数据不能够重复，判断标准是：先看hashcode是否相同，hashcode不同，则认为是不同数据。如果hashcode相同，再比较equals，如果equals相同，则是相同数据，否则是不同数据 import java.util.AbstractSet; import java.util.HashMap; import java.util.Iterator; import java.util.Set; public class HashSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements Set&lt;E&gt;, Cloneable, java.io.Serializable { //HashSet里封装了一个HashMap private HashMap&lt;E,Object&gt; map; private static final Object PRESENT = new Object(); //HashSet的构造方法初始化这个HashMap public HashSet() { map = new HashMap&lt;E,Object&gt;(); } //向HashSet中增加元素，其实就是把该元素作为key，增加到Map中 //value是PRESENT，静态，final的对象，所有的HashSet都使用这么同一个对象 public boolean add(E e) { return map.put(e, PRESENT)==null; } //HashSet的size就是map的size public int size() { return map.size(); } //清空Set就是清空Map public void clear() { map.clear(); } //迭代Set,就是把Map的键拿出来迭代 public Iterator&lt;E&gt; iterator() { return map.keySet().iterator(); } HashSet是无序的，LinkedHashSet是按照插入顺序排序的，TreeSet中的元素是按照从小到大排序的 import java.util.LinkedHashSet; import java.util.TreeSet; CollectionsCollection是Set、List、Queue和Deque的接口，Collection和Map之间没有关系，Collection是放一个一个对象的，Map是放键值对的，Deque继承Queue，间接的继承了Collection Collections是一个类，容器的工具类，就如同Arrays是数组的工具类 import java.util.Collections; // 初始化集合numbers List&lt;Integer&gt; numbers = new ArrayList&lt;&gt;(); // 使集合中的数据发生翻转 Collections.reverse(numbers); // 打乱集合中数据的顺序 Collections.shuffle(numbers); // 对集合中的数据进行排序 Collections.sort(numbers); // 交换集合中两个不同索引位置的数据 Collections.swap(numbers,0,5); // 将集合中的数据向右滚动指定单位的长度（闭环） Collections.rotate(numbers,2); // 把非线程安全的List转换为线程安全的List List&lt;Integer&gt; synchronizedNumbers = (List&lt;Integer&gt;) Collections.synchronizedList(numbers); HashCode所有的对象，都有一个对应的hashcode（散列值），不同对象可能有相同的hashcode，数组保存数据时，每个对象有一个hashcode类似于数组的索引，根据数组下标进行定位，是非常快速的，如果相同的hashcode上已经有一个对象了，那么就会创建一个链表，新对象接在旧对象的后面存放，通过hashcode定位后，再在链表里遍历比较，查询起来就非常快了，这是一种空间换时间的思维方式 Java API提供的String的hashcode生成方法是：（其中s[0]表示第一位字符，n表示字符串的长度） s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1] 比较器import java.util.Collections; import java.util.Comparator; import java.util.Random; Random r =new Random(); List&lt;Hero&gt; heros = new ArrayList&lt;Hero&gt;(); for (int i = 0; i &lt; 10; i++) { //通过随机值实例化hero的hp和damage heros.add(new Hero(&quot;hero &quot;+ i, r.nextInt(100), r.nextInt(100))); } //直接调用sort会出现编译错误，因为Hero有各种属性 //到底按照哪种属性进行比较，Collections也不知道，不确定，所以没法排 //Collections.sort(heros); //引入Comparator，指定比较的算法 Comparator&lt;Hero&gt; c = new Comparator&lt;Hero&gt;() { @Override public int compare(Hero h1, Hero h2) { //按照hp进行排序 if(h1.hp&gt;=h2.hp) return 1; //正数表示按从左到右的顺序，h1应该排在h2的后面（右侧） else return -1; // return (int) (h2.hp - h1.hp); } }; Collections.sort(heros,c); System.out.println(&quot;按照血量排序后的集合：&quot;); System.out.println(heros); // 使Hero类实现Comparable接口，在类里面提供比较算法，Collections.sort就有足够的信息进行排序了，也无需额外提供比较器Comparator（如果返回-1，就表示当前的更小，否则就是更大） public class Hero implements Comparable&lt;Hero&gt; { public Hero() {} @Override public int compareTo(Hero anotherHero) { if(damage &lt; anotherHero.damage) return 1; else return -1; } public static void main(String[] args) { //Hero类实现了接口Comparable，即自带比较信息。 //Collections直接进行排序，无需额外的Comparator Collections.sort(heros); } } // 聚合方式 String name =heros .stream() .sorted((h1,h2)-&gt;h1.hp&gt;h2.hp?-1:1) .skip(2) .map(h-&gt;h.getName()) .findFirst() .get(); System.out.println(&quot;通过聚合操作找出来的hp第三高的英雄名称是:&quot; + name); 泛型ArrayList默认接受Object类型的对象，所以所有对象都可以放进ArrayList中，不过需要进行强制类型转换才可以得到对应类型，但是需要记住存储时的特定类型，否则会出现类型转换异常 泛型的用法是在容器后面添加Type（类型），Type可以是类，抽象类，接口。泛型表示这种容器，只能存放Type类型 如果容器的泛型是一个类，那么这个类的子类都可以放进去 设计一个支持泛型的栈MyStack，设计这个类的时候，在类的声明上，加上一个&lt;&gt;，里面放T表示type（类型），表示该类支持泛型 public class MyStack&lt;T&gt; { LinkedList&lt;T&gt; values = new LinkedList&lt;T&gt;(); public void push(T t) { values.addLast(t); } public T pull() { return values.removeLast(); } public T peek() { return values.getLast(); } public static void main(String[] args) { //在声明这个Stack的时候，使用泛型&lt;Hero&gt;就表示该Stack只能放Hero MyStack&lt;Hero&gt; heroStack = new MyStack&lt;&gt;(); heroStack.push(new Hero()); //不能放Item heroStack.push(new Item()); ArrayList&lt;APHero&gt; apHeroList = new ArrayList&lt;APHero&gt;(); apHeroList.add(new APHero()); ArrayList&lt;? extends Hero&gt; heroList = apHeroList; //? extends Hero 表示这是一个Hero泛型的子类泛型 //heroList 的泛型可以是Hero //heroList 的泛型可以使APHero //heroList 的泛型可以使ADHero //可以确凿的是，从heroList取出来的对象，一定是可以转型成Hero的 Hero h= heroList.get(0); //但是，不能往里面放东西 heroList.add(new ADHero()); //编译错误，因为heroList的泛型 有可能是APHero ArrayList&lt;? super Hero&gt; heroList = new ArrayList&lt;Object&gt;(); //? super Hero 表示 heroList的泛型是Hero或者其父类泛型 //heroList 的泛型可以是Hero //heroList 的泛型可以是Object //所以就可以插入Hero heroList.add(new Hero()); //也可以插入Hero的子类 heroList.add(new APHero()); heroList.add(new ADHero()); //但是，不能从里面取数据出来,因为其泛型可能是Object,而Object是强转Hero会失败 Hero h= heroList.get(0); ArrayList&lt;APHero&gt; apHeroList = new ArrayList&lt;APHero&gt;(); //?泛型通配符，表示任意泛型 ArrayList&lt;?&gt; generalList = apHeroList; //?的缺陷1： 既然?代表任意泛型，那么换句话说，你就不知道这个容器里面是什么类型 //所以只能以Object的形式取出来 Object o = generalList.get(0); //?的缺陷2： 既然?代表任意泛型，那么既有可能是Hero,也有可能是Item //所以，放哪种对象进去，都有风险，结果就什么什么类型的对象，都不能放进去 generalList.add(new Item()); //编译错误 因为?代表任意泛型，很有可能不是Item generalList.add(new Hero()); //编译错误 因为?代表任意泛型，很有可能不是Hero generalList.add(new APHero()); //编译错误 因为?代表任意泛型，很有可能不是APHero 因此，如果希望只取出，不插入，就是用? extends Hero，如果希望只插入，不取出，就是用? super Hero，如果希望，又能插入，又能取出，就不要用通配符? 子类转父类是一定可以成功的，但是子类泛型不可以转换为父类泛型，父类泛型也不可以转换为子类泛型 ArrayList&lt;ADHero&gt; adhs = new ArrayList&lt;&gt;(); // 父类泛型转子类 adhs = hs; // adhs这个引用，实际上是指向的一个Hero泛型的容器 // 此时就变成了已经转型为Hero泛型的ADHero引用可以添加Hero、APHero及Hero的子类了 // 而ADHero泛型的容器里只可以存放ADHero类，这就有了矛盾 LambdaLambda引用private static void filter(List&lt;Hero&gt; heros, HeroChecker checker) { for (Hero hero : heros) { if (checker.test(hero)) System.out.print(hero); } } public static void main(String[] args) { // 匿名类的正常写法 HeroChecker c1 = new HeroChecker() { @Override public boolean test(Hero h) { return (h.hp &gt; 100 &amp;&amp; h.damage &lt; 50); } }; // 把new HeroChcekcer，方法名，方法返回类型信息去掉 // 只保留方法参数和方法体 // 参数和方法体之间加上符号 -&gt; HeroChecker c2 = (Hero h) -&gt; { return h.hp &gt; 100 &amp;&amp; h.damage &lt; 50; }; // 把return和{}去掉 HeroChecker c3 = (Hero h) -&gt; h.hp &gt; 100 &amp;&amp; h.damage &lt; 50; // 把 参数类型和圆括号去掉 HeroChecker c4 = h -&gt; h.hp &gt; 100 &amp;&amp; h.damage &lt; 50; // 把c4作为参数传递进去 filter(heros, c4); // 直接把表达式传递进去 filter(heros, h -&gt; h.hp &gt; 100 &amp;&amp; h.damage &lt; 50); } Lambda其实就是匿名方法，这是一种把方法作为参数进行传递的编程思想，Java会在背后，把这些Lambda都悄悄还原成匿名类方式 // 先给TestLambda添加一个静态方法 public static boolean testHero(Hero h) { return h.hp&gt;100 &amp;&amp; h.damage&lt;50; } System.out.println(&quot;在Lambda表达式中使用静态方法&quot;); filter(heros, h -&gt; TestLambda.testHero(h) ); System.out.println(&quot;直接引用静态方法&quot;); filter(heros, TestLambda::testHero); // 先给TestLambda添加一个对象方法 public boolean testHero(Hero h) { return h.hp&gt;100 &amp;&amp; h.damage&lt;50; } // 使用类的对象方法 // 传递方法时，需要一个对象的存在 TestLambda testLambda = new TestLambda(); filter(heros, testLambda::testHero); public boolean matched() { return this.hp&gt;100&amp;&amp;this.damage&lt;50; } System.out.println(&quot;Lambda表达式中调用容器中的对象的matched方法：&quot;); filter(heros,h-&gt; h.matched() ); System.out.println(&quot;引用容器中对象的方法 之过滤结果：&quot;); filter(heros, Hero::matched); import java.util.function.Supplier; // Supplier接口中的get方法会返回一个对象 public interface Supplier&lt;T&gt; { T get(); } public static List getList(Supplier&lt;List&gt; s) { return s.get(); } Supplier&lt;List&gt; s = new Supplier&lt;List&gt;() { public List get() { return new ArrayList(); } } // 匿名类 List list1 = getList(s); // Lambda表达式 List list2 = getList(()-&gt;new ArrayList()); // 引用构造器 List list3 = getList(ArrayList::new); 聚合操作Stream和Collection结构化的数据不一样，Stream是一系列的元素，管道指的是一系列的聚合操作。管道分为管道源、中间操作（每个中间操作会返回一个Stream，中间操作是“懒”操作，并不会真正进行遍历）和结束操作（当这个操作执行后，流就被使用“光”了，无法再被操作，所有这必定是流的最后一个操作。结束操作不会返回Stream，但是会返会int、float、String、Collection或者想forEach，什么都不返回，结束操作才进行真正的遍历行为，在遍历的时候，才会去进行中间操作的相关判断） 管道源List&lt;Hero&gt; heros = new ArrayList&lt;Hero&gt;(); // Collection切换成管道源很简单，调用stream()就行了 heros.stream(); // 数组没有stream()方法，需要使用 Arrays.stream(hs); // 或者 Stream.of(hs); List&lt;Hero&gt; heros = new ArrayList&lt;Hero&gt;(); //管道源是集合 heros .stream() .forEach(h-&gt;System.out.println(h.name)); //管道源是数组 Hero hs[] = heros.toArray(new Hero[heros.size()]); Arrays.stream(hs) //Stream.of() .forEach(h-&gt;System.out.println(h.name)); 中间操作public getHp() { return hp; } heros .stream() // .filter // 匹配 .distinct() // 去除重复（根据equals判断） // .sorted // 自然排序 // sorted(Comparator&lt;T&gt;) // 指定排序 .sorted((h1,h2)-&gt;h1.hp&gt;=h2.hp?1:-1) .limit(3) // 保留3个元素 .skip(3) // 忽略前3个元素 .mapToDouble(Hero::getHp) // 转换为double的Stream .map((h)-&gt; h.name + &quot; - &quot; + h.hp + &quot; - &quot; + h.damage) // 转换为任意类型的Stream .forEach(h-&gt;System.out.println(h)); 结束操作heros .stream() .forEach(h-&gt;System.out.print(h)); // 遍历每个元素 .toArray(); // 转换为数组 .min((h1, h2)-&gt;h1.damage-h2.damage); // 取最小的元素 .max((h1, h2)-&gt;h1.damage-h2.damage); // 取最大的元素 .count(); // 总数 .findFirst(); // 第一个元素 .get(); 多线程创建多线程 通过设计一个线程类继承Thread，并且重写run方法。然后通过实例化对应的线程类对象，并且调用其start方法来启动线程办法 创建一个类，实现Runnable接口，启动的时候，首先创建一个对应类的对象，然后根据该对象创建一个线程对象，并启动。因为该类对象实现了Runnable接口，所以会有run方法，但是直接调用run方法，并不会启动一个新的线程。必须借助一个线程对象的start()方法，才会启动一个新的线程。因此需要创建一个Thread对象，并把该类对象作为构造方法的参数传递进去，这个线程启动的时候，就会去执行类对象里定义的run()方法了 使用匿名类，继承Thread，重写run方法，直接在run方法中写业务代码 //匿名类 Thread t1= new Thread(){ public void run(){ //匿名类的一个好处是可以很方便地访问外部的局部变量 //匿名类中用到外部的局部变量，必须将其声明为final //但是在JDK7以后，就不是必须加final的了 while(!teemo.isDead()){ gareen.attackHero(teemo); } } }; t1.start(); 线程方法try { //Thread.sleep(1000);表示当前线程暂停1000毫秒，其他线程不受影响 Thread.sleep(1000); //Thread.sleep(1000);会抛出InterruptedException中断异常，因为当前线程sleep的时候，有可能被停止，这时就会抛出InterruptedException } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } 所有进程，至少会有一个线程即主线程，即main方法开始执行，就会有一个看不见的主线程存在 Thread t1= new Thread(){ public void run(){ while(!teemo.isDead()){ gareen.attackHero(teemo); } } }; //守护进程指的是，当一个进程里，所有的进程都是守护线程的时候，结束当前进程。守护线程通常会被用来做日志，性能统计等工作 t1.setDaemon(true); t1.start(); //代码执行到这里，一直是main线程在运行 try { //t1线程加入到main线程中来，只有t1线程运行结束，才会继续往下走 t1.join(); } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } Thread t2= new Thread(){ public void run(){ while(!leesin.isDead()){ bh.attackHero(leesin); } } }; //会观察到t1线程运行完后，主线程运行到这里，才运行t2线程 t2.start(); 当线程处于竞争关系的时候，优先级高的线程会有更大的几率获得CPU资源 t1.setPriority(Thread.MAX_PRIORITY); t2.setPriority(5); t1.start(); t2.start(); 当前线程，临时暂停，使得其他线程可以有更多机会占用CPU资源 Thread t2= new Thread(){ public void run(){ while(!leesin.isDead()){ //临时暂停，使得t1可以占用CPU资源 Thread.yield(); bh.attackHero(leesin); } } }; 同步多线程的同步问题指的是多个线程同时修改一个数据的时候，可能导致的问题，又叫Concurrency问题 synchronized表示当前线程，独占对象someObject，当前线程独占了对象someObject，如果有其他线程试图占有对象someObject，就会等待，直到当前线程释放对someObject的占用。为了达到同步的效果，必须使用同一个同步对象 释放同步对象的方式：synchronized块自然结束，或者有异常抛出。 既然任意对象都可以用来作为同步对象，那么可以将所有线程访问的同一个对象作为同步对象，也可以进一步在类的方法体内加上synchronized(this){}表示当前对象为同步对象，或者直接在方法前加上修饰符synchronized，其所对应的同步对象，就是this Object someObject = new Object(); synchronized(someObject){ //此处的代码只有占有了someObject后才可以执行 } 如果一个类，其方法都是有synchronized修饰的，那么该类就是线程安全的类，同一时间，只有一个线程能够进入这种类的一个实例去修改数据，进而保证了这个实例中的数据的安全（不会同时被多线程修改而变成脏数据），比如StringBuffer的方法都是由synchronized修饰的，而StringBuilder就不是线程安全的类。但是非线程安全的类会比线程安全的类的实例操作起来快，是因为不需要同步，节省了时间，因此，单线程的话可以采用非线程安全的类 ArrayList和Vector类的区别也只在于，后者是线程安全的类，而前者不是 List&lt;Integer&gt; list1 = new ArrayList&lt;&gt;(); //借助Collections.synchronizedList，可以把ArrayList转换成线程安全的List，与此类似的，还有HashSet,LinkedList,HashMap等等非线程安全的类，都可以通过工具类Collections转换为线程安全的 List&lt;Integer&gt; list2 = Collections.synchronizedList(list1); 死锁 线程1首先占有对象1，接着试图占用对象2 线程2首先占有对象2，接着试图占有对象1 线程1等待线程2释放对象2 与此同时，线程2等待线程1释放对象1就会，一直等待下去… Thread t1 = new Thread(){ public void run(){ //占有九尾妖狐 synchronized (ahri) { System.out.println(&quot;t1 已占有九尾妖狐&quot;); try { //停顿1000毫秒，另一个线程有足够的时间占有安妮 Thread.sleep(1000); } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } System.out.println(&quot;t1 试图占有安妮&quot;); System.out.println(&quot;t1 等待中 。。。。&quot;); synchronized (annie) { System.out.println(&quot;do something&quot;); } } } }; t1.start(); Thread t2 = new Thread(){ public void run(){ //占有安妮 synchronized (annie) { System.out.println(&quot;t2 已占有安妮&quot;); try { //停顿1000毫秒，另一个线程有足够的时间占有暂用九尾妖狐 Thread.sleep(1000); } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } System.out.println(&quot;t2 试图占有九尾妖狐&quot;); System.out.println(&quot;t2 等待中 。。。。&quot;); synchronized (ahri) { System.out.println(&quot;do something&quot;); } } } 交互使用循环的方式来解决线程间交互的问题，不是个好方法，因为会大量占用CPU，拖慢性能 public synchronized void recover() { hp = hp + 1; System.out.printf(&quot;%s 回血1点,增加血后，%s的血量是%.0f%n&quot;, name, name, hp); // 通知那些等待在this对象上的线程，可以醒过来了，如等待着的减血线程，苏醒过来 this.notify(); } public synchronized void hurt() { if (hp == 1) { try { // 让占有this的减血线程，暂时释放对this的占有，并等待 this.wait(); } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } } } wait方法和notify方法，并不是Thread线程上的方法，它们是Object上的方法。wait()让占用了这个同步对象的线程，临时释放当前的占用，并且等待。所以调用wait是有前提条件的，一定是在synchronized块里，否则就会出错。notify()通知一个等待在这个同步对象上的线程，你可以苏醒过来了，有机会重新占用当前对象了。notifyAll()通知所有等待在这个同步对象上的线程，你们可以苏醒过来了，有机会重新占用当前对象了 线程池每一个线程的启动和结束都是比较耗费时间和占用资源的，如果在系统中用到了很多的线程，大量的启动和结束动作会导致系统的性能变卡，响应变慢，因此可以引入线程池： 准备一个任务容器 一次性启动10个 消费者线程 刚开始任务容器是空的，所以线程都wait在上面。 直到一个外部线程往这个任务容器中扔了一个“任务”，就会有一个消费者线程被唤醒notify 这个消费者线程取出“任务”，并且执行这个任务，执行完毕后，继续等待下一次任务的到来。 如果短时间内，有较多的任务加入，那么就会有多个线程被唤醒，去执行这些任务。 在整个过程中，都不需要创建新的线程，而是循环使用这些已经存在的线程 public class ThreadPool { // 线程池大小 int threadPoolSize; // 任务容器 LinkedList&lt;Runnable&gt; tasks = new LinkedList&lt;Runnable&gt;(); // 试图消费任务的线程 public ThreadPool() { threadPoolSize = 10; // 启动10个任务消费者线程 synchronized (tasks) { for (int i = 0; i &lt; threadPoolSize; i++) { new TaskConsumeThread(&quot;任务消费者线程 &quot; + i).start(); } } } public void add(Runnable r) { synchronized (tasks) { tasks.add(r); // 唤醒等待的任务消费者线程 tasks.notifyAll(); } } class TaskConsumeThread extends Thread { public TaskConsumeThread(String name) { super(name); } Runnable task; public void run() { System.out.println(&quot;启动： &quot; + this.getName()); while (true) { synchronized (tasks) { while (tasks.isEmpty()) { //wait()方法暂停后，之后苏醒时，接着wait()后面的语句继续运行？ try { tasks.wait(); } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } } task = tasks.removeLast(); // 允许添加任务的线程可以继续添加任务 tasks.notifyAll(); } System.out.println(this.getName() + &quot; 获取到任务，并执行&quot;); task.run(); } } public static void main(String[] args) { ThreadPool pool = new ThreadPool(); for (int i = 0; i &lt; 5; i++) { Runnable task = new Runnable() { @Override public void run() { //System.out.println(&quot;执行任务&quot;); //任务可能是打印一句话 //可能是访问文件 //可能是做排序 } }; pool.add(task); try { Thread.sleep(1000); } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } } } } java自带的线程池类ThreadPoolExecutor在包java.util.concurrent下 import java.util.concurrent.LinkedBlockingQueue; import java.util.concurrent.ThreadPoolExecutor; import java.util.concurrent.TimeUnit; public static void main(String[] args) throws InterruptedException { ThreadPoolExecutor threadPool= new ThreadPoolExecutor(10, 15, 60, TimeUnit.SECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()); //第一个参数10表示这个线程池初始化了10个线程在里面工作 //第二个参数15表示如果10个线程不够用了，就会自动增加到最多15个线程 //第三个参数60结合第四个参数TimeUnit.SECONDS，表示经过60秒，多出来的线程还没有接到任务，就会被回收，最后保持线程池里只有10个线程 //第五个参数new LinkedBlockingQueue()是用来存放任务的集合 threadPool.execute(new Runnable(){ //execute方法用于添加新的任务 @Override public void run() { // TODO Auto-generated method stub System.out.println(&quot;任务1&quot;); } }); } Lock对象与synchronized(someObject)类似，lock()方法，表示当前线程占用lock对象，一旦占用，其他线程就不能占用了。与synchronized不同的是，一旦synchronized块结束，就会自动释放对someObject的占用。lock却必须调用unlock方法进行手动释放，为了保证释放的执行，往往会把unlock()放在finally中进行 synchronized是不占用到手不罢休的，会一直试图占用下去。与synchronized的钻牛角尖不一样，Lock接口还提供了一个trylock方法。trylock会在指定时间范围内试图占用，占用成功了，就执行业务。如果时间到了，还没成功占用，就放弃了（因为使用trylock有可能占用成功，也有可能失败，所以后面unlock释放的时候，需要判断是否占用成功了，如果没占用成功也调用unlock()，就会抛出异常） 类似于synchronized方式进行线程交互，用到的是同步对象的wait、notify和notifyAll方法。Lock也提供了类似的解决方法，首先通过lock对象得到一个Condition对象，然后分别调用这个Condition对象的：await、signal和signalAll方法（不是Condition对象的wait、notify和notifyAll方法） import java.text.SimpleDateFormat; import java.util.Date; import java.util.concurrent.locks.Lock; import java.util.concurrent.locks.ReentrantLock; import java.util.Condition; public static String now() { return new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()); } public static void log(String msg) { System.out.printf(&quot;%s %s %s %n&quot;, now() , Thread.currentThread().getName() , msg); } public static void main(String[] args) { Lock lock = new ReentrantLock(); Condition condition = lock.newCondition(); Thread t1 = new Thread() { public void run() { try { log(&quot;线程启动&quot;); log(&quot;试图占有对象：lock&quot;); lock.lock(); log(&quot;占有对象：lock&quot;); log(&quot;进行5秒的业务操作&quot;); Thread.sleep(5000); // log(&quot;临时释放对象 lock， 并等待&quot;); // condition.await(); // log(&quot;重新占有对象 lock，并进行5秒的业务操作&quot;); // Thread.sleep(5000); // locked = lock.tryLock(1,TimeUnit.SECONDS); // if(locked){ // log(&quot;占有对象：lock&quot;); // log(&quot;进行5秒的业务操作&quot;); // Thread.sleep(5000); // } // else{ // log(&quot;经过1秒钟的努力，还没有占有对象，放弃占有&quot;); // } } catch (InterruptedException e) { e.printStackTrace(); } finally { log(&quot;释放对象：lock&quot;); lock.unlock(); // if(locked){ // log(&quot;释放对象：lock&quot;); // lock.unlock(); // } } log(&quot;线程结束&quot;); } }; t1.setName(&quot;t1&quot;); t1.start(); try { //先让t1飞2秒 Thread.sleep(2000); } catch (InterruptedException e1) { // TODO Auto-generated catch block e1.printStackTrace(); } Thread t2 = new Thread() { public void run() { try { log(&quot;线程启动&quot;); log(&quot;试图占有对象：lock&quot;); lock.lock(); log(&quot;占有对象：lock&quot;); log(&quot;进行5秒的业务操作&quot;); Thread.sleep(5000); // log(&quot;唤醒等待中的线程&quot;); // condition.signal(); // locked = lock.tryLock(1,TimeUnit.SECONDS); // if(locked){ // log(&quot;占有对象：lock&quot;); // log(&quot;进行5秒的业务操作&quot;); // Thread.sleep(5000); // } // else{ // log(&quot;经过1秒钟的努力，还没有占有对象，放弃占有&quot;); // } } catch (InterruptedException e) { e.printStackTrace(); } finally { log(&quot;释放对象：lock&quot;); lock.unlock(); // if(locked){ // log(&quot;释放对象：lock&quot;); // lock.unlock(); // } } log(&quot;线程结束&quot;); } }; t2.setName(&quot;t2&quot;); t2.start(); } Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现，Lock是代码层面的实现 Lock可以选择性的获取锁，如果一段时间获取不到，可以放弃。synchronized不行，会一根筋一直获取下去。借助Lock的这个特性，就能够规避死锁，synchronized必须通过谨慎和良好的设计，才能减少死锁的发生 synchronized在发生异常和同步块结束的时候，会自动释放锁。而Lock必须手动释放，所以如果忘记了释放锁，一样会造成死锁 原子访问原子性操作即不可中断的操作，比如赋值操作。原子性操作本身是线程安全的。比如“i++”事实上由三个原子性操作组成，分别是取i的值、“i+1”和把新的值赋予i。但是合在一起“i++”就不是原子操作，就不是线程安全的，因为可能一个线程在执行完步骤1之后，还没来得及执行步骤2，另一个线程就开始执行步骤3了，也就是会出现同步问题 JDK6以后，新增加了一个包java.util.concurrent.atomic，里面有各种原子类，比如AtomicInteger。而AtomicInteger提供了各种自增，自减等方法，这些方法都是原子性的。换句话说，自增方法incrementAndGet是线程安全的，同一个时间，只有一个线程可以调用这个方法（int基本类型对应的是AtomicInteger，但是float基本类型没有对应的AtomicFloat） import java.util.concurrent.atomic.AtomicInteger; public static void main(String[] args) throws InterruptedException { AtomicInteger atomicI =new AtomicInteger();//类似于int变量初始化，值为0 int i = atomicI.decrementAndGet();//自减运算 int j = atomicI.incrementAndGet();//自增运算 int k = atomicI.addAndGet(3);//加法赋值运算（参数为负时即相当于减法赋值运算） System.out.println(aomicI.intValue());//类似于打印int变量的值 } JDBCJDBC（Java Data Base Connection）是指通过JAVA访问数据库 增删改查访问MySQL数据库需要用到第三方的类，因此需要为项目导入mysql的专用Jar包，通常项目用到的jar包统一放在项目的lib目录下，然后…（如果是IDEA下，可以通过右键lib目录-&gt;Add as Library…的方式添加jar到路径） import java.sql.Connection; import java.sql.DriverManager; import java.sql.SQLException; import java.sql.Statement; import java.sql.ResultSet; public static void main(String[] args) { Connection c = null; Statement s = null; try { //Class.forName(&quot;class&quot;)是把这个类class加载到JVM中，加载的时候，就会执行其中的静态初始化块，完成驱动的初始化的相关工作 //如果没有导入包含这个类的包，就会抛出ClassNotFoundException Class.forName(&quot;com.mysql.jdbc.Driver&quot;); // 建立与数据库的Connection连接 // 这里需要提供： // 数据库所处于的ip:127.0.0.1（本机） // 数据库的端口号：3306（mysql专用端口号） // 数据库名称 how2java // 编码方式 UTF-8 // 账号 root // 密码 admin c = DriverManager.getConnection(&quot;jdbc:mysql://127.0.0.1:3306/how2java?character=utf8&quot;, &quot;root&quot;, &quot;admin&quot;); //Statement用于执行SQL语句 s = c.createStatement(); String sql = &quot;insert into hero values(null,&quot; + &quot;&#39;提莫&#39;&quot; + &quot;,&quot; + 313.0f + &quot;,&quot; + 50 + &quot;)&quot;; //s.execute执行sql语句 s.execute(sql); } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (SQLException e) { e.printStackTrace(); } finally { //数据库的连接是有限资源，相关操作结束后，需要关闭数据库 if(s != null) { try { s.close(); } catch (SQLException e) { e.printStackTrace(); } } if(c != null) { try { c.close(); } catch (SQLException e) { e.printStackTrace(); } } } //可以使用try-with-resource的方式自动关闭连接，因为Connection和Statement都实现了AutoCloseable接口 try ( Connection c = DriverManager.getConnection(&quot;jdbc:mysql://127.0.0.1:3306/how2java?characterEncoding=UTF-8&quot;, &quot;root&quot;, &quot;admin&quot;); Statement s = c.createStatement(); ) { // String sql = &quot;insert into hero values(null,&quot; + &quot;&#39;提莫&#39;&quot; + &quot;,&quot; + 313.0f + &quot;,&quot; + 50 + &quot;)&quot;; //增 // String sql = &quot;delete from hero where id = 5&quot;; //删 // String sql = &quot;update hero set name = &#39;name 5&#39; where id = 3&quot;; //改 // s.execute(sql); String sql = &quot;select * from hero&quot;; // 执行查询语句，并把结果集返回给ResultSet ResultSet rs = s.executeQuery(sql); // 查询操作是基1的，即2就代表第二个 while(rs.next()) { int id = rs.getInt(&quot;id&quot;);//可以使用字段名 String name = rs.getString(2);//也可以使用字段的顺序 float hp = rs.getFloat(&quot;hp&quot;); int damage = rs.getInt(4); System.out.printf(&quot;%d\\t%s\\t%f\\t%d%n&quot;, id, name, hp, damage); } // 不一定要在这里关闭ResultSet，因为Statement关闭的时候，会自动关闭ResultSet // rs.close(); // 查询数据库时，应当是根据提供的数据到表里去找数据（调用SQL查询语句），而不是把数据库表中所有数据全部查到内存里，挨个进行比较，如果列表数据庞大，可能内存都不够用 // String name = &quot;dashen&quot;; // //正确的密码是：thisispassword // String password = &quot;thisispassword1&quot;; // String sql = &quot;select * from user where name = &#39;&quot; + name +&quot;&#39; and password = &#39;&quot; + password+&quot;&#39;&quot;; // // 执行查询语句，并把结果集返回给ResultSet // ResultSet rs = s.executeQuery(sql); // if(rs.next()) // System.out.println(&quot;账号密码正确&quot;); // else // System.out.println(&quot;账号密码错误&quot;); // 获取列表数据总量 // String sql = &quot;select count(*) from hero&quot;; // ResultSet rs = s.executeQuery(sql); // int total = 0; // while (rs.next()) { // total = rs.getInt(1); // } // System.out.println(&quot;表Hero中总共有:&quot; + total+&quot; 条数据&quot;); } catch (SQLException e) { // TODO Auto-generated catch block e.printStackTrace(); } } 预编译Statementimport java.sql.PreparedStatement; public static void main(String[] args) { String sql = &quot;insert into hero values(null,?,?,?)&quot;; try(Connection c = DriverManager.getConnection(&quot;jdbc:mysql://127.0.0.1:3306/how2java?character=utf8&quot;, &quot;root&quot;, &quot;admin&quot;); //根据sql语句创建PreparedStatement，PreparedStatement使用参数设置，可读性好，不易犯错 PreparedStatement ps = c.prepareStatement(sql);) { //设置参数 ps.setString(1, &quot;提莫&quot;); ps.setFloat(2, 313.0f); ps.setInt(3, 50); //执行 ps.execute(); //Statement执行多次，需要多次把SQL语句传输到数据库端 //数据库要对每一次来的SQL语句进行编译处理 //PreparedStatement执行多次，只需要1次把SQL语句传输到数据库端 //数据库对带?的SQL进行预编译 //每次执行，只需要传输参数到数据库端 //1. 网络传输量比Statement更小 //2. 数据库不需要再进行编译，响应更快 //且使用Statement就需要进行字符串拼接，容易导致SQL注入式攻击（比如一条SQL查询语句将数据库表中的数据全部查出来，会让数据库负载变高，CPU100%，内存消耗光，响应变得极其缓慢），而PreParedStatement使用的是参数设置，是预编译Statement，可以杜绝SQL注入 // String sql = &quot;select * from hero where name = ?&quot;; // try (Connection c = DriverManager.getConnection(&quot;jdbc:mysql://127.0.0.1:3306/how2java?character=utf8&quot;, &quot;root&quot;, &quot;admin&quot;); // PreparedStatement rs = c.prepareStatement(sql)) { // String name = &quot;&#39;盖伦&#39; OR 1=1&quot;; // ps.setString(1, name); // ResultSet rs = ps.executeQuery(); // //查不出数据来 // while (rs.next()) { // String heroName = rs.getString(&quot;name&quot;); // System.out.println(heroName); // } // } catch (SQLException e) { // e.printStackTrace(); // } } catch (SQLException e) { e.printStackTrace(); } } executeUpdateexecuteUpdate和execute相同点是：都可以执行增、删、改 //不同1：execute可以执行查询语句 //然后通过getResultSet，把结果集取出来 String sqlSelect = &quot;select * from hero&quot;; s.execute(sqlSelect); ResultSet rs = s.getResultSet(); //executeUpdate不能执行查询语句 //s.executeUpdate(sqlSelect); //不同2：execute返回boolean类型，true表示执行的是查询语句，false表示执行的是insert，delete，update等等 boolean isSelect = s.execute(sqlSelect); //executeUpdate返回的是int，表示有多少条数据受到了影响 String sqlUpdate = &quot;update hero set hp = 300 where id &lt; 100&quot;; int number = s.executeUpdate(sqlUpdate); 有时候MySQL会为新插入的数据分配一个自增长id，（前提是这个表的id设置为了自增长，MySQL创建表时，AUTO_INCREMENT就表示自增长）。有时候需要在定义PreparedStatement的时候，后面加上Statement.RETURN_GENERATED_KEYS参数，以确保会返回自增长ID try(Connection c = DriverManager.getConnection(&quot;jdbc:mysql://127.0.0.1:3306/how2java?character=utf8&quot;, &quot;root&quot;, &quot;admin&quot;); PreparedStatement ps = c.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS); Statement s = c.createStatement();) { //在执行完插入语句后，MySQL会为新插入的数据分配一个自增长id //JDBC通过getGeneratedKeys获取该id ResultSet rs = ps.getGeneratedKeys(); if (rs.next()) { int id = rs.getInt(1); //通过自增长id删除数据库列表中某条数据的上一条数据（他们的id可能不是连续的） while (true) { s.execute(&quot;select * from hero where id =&quot; + (--id)); ResultSet r = s.getResultSet(); if (r.next()) { s.execute(&quot;delete from hero where id = &quot; + id); break; } } } } catch (SQLException e) { e.printStackTrace(); } 元数据概念：和数据库服务器相关的数据，比如数据库版本，有哪些表，表有哪些字段，字段类型是什么等等 import java.sql.DatabaseMetaData; try (Connection c = DriverManager.getConnection(&quot;jdbc:mysql://127.0.0.1:3306/how2java?characterEncoding=UTF-8&quot;,&quot;root&quot;, &quot;admin&quot;);) { // 查看数据库层面的元数据 // 即数据库服务器版本，驱动版本，都有哪些数据库等等 DatabaseMetaData dbmd = c.getMetaData(); // 获取数据库服务器产品名称 System.out.println(&quot;数据库产品名称:\\t&quot;+dbmd.getDatabaseProductName()); // 获取数据库服务器产品版本号 System.out.println(&quot;数据库产品版本:\\t&quot;+dbmd.getDatabaseProductVersion()); // 获取数据库服务器用作类别和表名之间的分隔符 如test.user System.out.println(&quot;数据库和表分隔符:\\t&quot;+dbmd.getCatalogSeparator()); // 获取驱动版本 System.out.println(&quot;驱动版本:\\t&quot;+dbmd.getDriverVersion()); System.out.println(&quot;可用的数据库列表：&quot;); // 获取数据库名称 ResultSet rs = dbmd.getCatalogs(); while (rs.next()) { System.out.println(&quot;数据库名称:\\t&quot;+rs.getString(1)); } } catch (SQLException e) { // TODO Auto-generated catch block e.printStackTrace(); } 事务try (Connection c = DriverManager.getConnection(&quot;jdbc:mysql://127.0.0.1:3306/how2java?characterEncoding=UTF-8&quot;,&quot;root&quot;, &quot;admin&quot;); Statement s = c.createStatement();) { // 有事务的前提下 // 在事务中的多个操作，要么都成功，要么都失败 c.setAutoCommit(false); // 加血的SQL String sql1 = &quot;update hero set hp = hp +1 where id = 22&quot;; s.execute(sql1); // 减血的SQL // 不小心写错写成了 updata(而非update) String sql2 = &quot;updata hero set hp = hp -1 where id = 22&quot;; s.execute(sql2); // 手动提交 c.commit(); } catch (SQLException e) { // TODO Auto-generated catch block e.printStackTrace(); } 在Mysql中，只有当表的类型是INNODB的时候，才支持事务，所有需要把表的类型设置为INNODB，否则无法观察到事务 修改表的类型为INNODB的SQL： alter table hero ENGINE = innodb; 查看表的类型的SQL： show table status from how2java; 不过有个前提是，当前的MYSQL服务器本身要支持INNODB，如果不支持，需要先开启MYSQL INNODB ORM &amp; DAOORM（Object Relationship Database Mapping）是指对象和关系数据库的映射，简单说就是，一个对象，对应数据库里的一条记录 public class Hero { //增加id属性 public int id; ... public static Hero get(int id) { Hero hero = null; try { Class.forName(&quot;com.mysql.jdbc.Driver&quot;); } catch (ClassNotFoundException e) { e.printStackTrace(); } try (Connection c = DriverManager.getConnection(&quot;jdbc:mysql://127.0.0.1:3306/how2java?character=utf8&quot;, &quot;root&quot;, &quot;admin&quot;); Statement s = c.createStatement();) { String sql = &quot;select * from hero where id = &quot; + id; ResultSet rs = s.executeQuery(sql); //因为id是唯一的，ResultSet最多只能有一条记录 //所以使用if代替while if (rs.next()) { hero = new Hero(); String name = rs.getString(2); float hp = rs.getFloat(&quot;hp&quot;); int damage = rs.getInt(4); hero.name = name; hero.hp = hp; hero.damage = damage; hero.id = id; } } catch (SQLException e) { e.printStackTrace(); } return hero; } } DAO（Data Access Object）数据访问对象 public interface DAO{ //增加 public void add(Hero hero); //修改 public void update(Hero hero); //删除 public void delete(int id); //获取 public Hero get(int id); //查询 public List&lt;Hero&gt; list(); //分页查询 public List&lt;Hero&gt; list(int start, int count); } public class HeroDAO implements DAO{ //通常驱动初始化只需要执行一次，所以可以放在构造函数里 public HeroDAO() { try { Class.forName(&quot;com.mysql.jdbc.Driver&quot;); } catch (ClassNotFoundException e) { e.printStackTrace(); } } //所有的数据库操作都需要事先拿到一个数据库连接Connection，因此可以提供一个getConnection方法返回连接 public Connection getConnection() throws SQLException { return DriverManager.getConnection(&quot;jdbc:mysql://127.0.0.1:3306/how2java?character=utf8&quot;, &quot;root&quot;, &quot;admin&quot;); } } 数据库连接池当有多个线程，每个线程都需要连接数据库执行SQL语句的话，那么每个线程都会创建一个连接，并且在使用完毕后，关闭连接。创建连接和关闭连接的过程也是比较耗时的，当多线程并发的时候，系统就会变得很卡顿。同时，一个数据库同时支持的连接总数也是有限的，如果多线程并发量很大，那么数据库连接的总数就会被消耗光，后续线程发起的数据库连接就会失败 连接池在使用之前，就会创建好一定数量的连接。如果有任何线程需要使用连接，那么就从连接池里面借用，而不是自己重新创建，使用完毕后，又把这个连接归还给连接池供下一次或者其他线程使用。倘若发生多线程并发情况，连接池里的连接被借用光了，那么其他线程就会临时等待，直到有连接被归还回来，再继续使用。整个过程，这些连接都不会被关闭，而是不断地被循环使用，从而节约了启动和关闭连接的时间 public class ConnectionPool { List&lt;Connection&gt; cs = new ArrayList&lt;&gt;(); int size; public ConnectionPool(int size) { this.size = size; init(); } public void init() { //这里恰恰不能使用try-with-resource的方式，因为这些连接都需要是“活”的，不要被自动关闭了 try { Class.forName(&quot;com.mysql.jdbc.Driver&quot;); for (int i = 0; i &lt; size; i++) { Connection c = DriverManager.getConnection(&quot;jdbc:mysql://127.0.0.1:3306/how2java?characterEncoding=UTF-8&quot;, &quot;root&quot;, &quot;admin&quot;); cs.add(c); } } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (SQLException e) { e.printStackTrace(); } } public synchronized Connection getConnection() { while(cs.isEmpty()) { try { this.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } Connection c = cs.remove(0); return c; } public synchronized void returnConnection(Connection c) { cs.add(c); this.notifyAll(); } } //初始化一个有3条连接的数据库连接池 //创建100个线程，每个线程都会从连接池中借用连接，并且在借用之后，归还连接。拿到连接之后，执行一个耗时1秒的SQL语句 class WorkingThread extends Thread { private ConnectionPool cp; public WorkingThread(String name, ConnectionPool cp) { super(name); this.cp = cp; } public void run() { Connection c = cp.getConnection(); System.out.println(this.getName() + &quot;:\\t 获取了一条连接，并开始工作&quot;); try (Statement st = c.createStatement()) { Thread.sleep(1000); st.execute(&quot;select * from hero&quot;); } catch (SQLException e | InterruptedException e) { e.printStackTrace(); } cp.returnConnection(c); } } 网络编程IP地址和端口import java.net.InetAddress; import java.net.UnKnownHostException; public static void main(String[] args) throws UnknownHostException, IOException { InetAddress host = InetAddress.getLocalHost(); String ip = host.getHostAddress(); System.out.println(&quot;本机ip地址：&quot; + ip); //ping不是java的api，是windows中的一个小工具，用于判断一个地址的响应时间 //ping可以返回这个地址的响应时间 time&lt;1ms 表示很快，局域网一般就是这个响应时间 //ping返回 Request timed out 表示时间较久都没有响应返回，基本判断这个地址不可用 //借助 Runtime.getRuntime().exec() 可以运行一个windows的exe程序 Process p = Runtime.getRuntime().exec(&quot;ping&quot; + &quot;192.168.2.106&quot;); BufferedReader br = new BufferedReader(new InputStreamReader(p.getInputStream())); String line = null; StringBuilder sb = new StringBuilder(); while ((line = br.readLine()) != null) { if (line.length() != 0) { sb.append(line + &quot;\\r\\n&quot;); } System.out.println(sb.toString()); } } Socket服务端开启某一端口，并监听着，时刻等待着客户端的连接请求。客户端知道服务端的ip地址和监听端口号，发出请求到服务端（客户端的端口地址是系统分配的，通常都会大于1024），一旦建立了连接，服务端就会得到一个新的Socket对象，该对象负责与客户端进行通信（在开发调试的过程中，如果修改过了服务器的Server代码，要关闭启动的Server，否则新的Server不能启动，因为之前的端口被占用了） import java.net.ServerSocket; import java.net.Socket; import java.net.UnkownHostException; public class Server { public static void main(String[] args) { try { ServerSocket ss = new ServerSocket(8888); System.out.println(&quot;监听在端口号:8888&quot;); Socket s = ss.accept(); InputStream is = s.getInputStream(); //把输入流封装在DataInputStream DataInputStream dis = new DataInputStream(is); //使用readUTF读取字符串 String msg = dis.readUTF(); System.out.println(msg); dis.close(); s.close(); ss.close(); } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); } } } public class Client { public static void main(String[] args) { try { Socket s = new Socket(&quot;127.0.0.1&quot;, 8888); OutputStream os = s.getOutputStream(); DataOutputStream dos = new DataOutputStream(os); //使用Scanner读取控制台的输入，并发送到服务端 Scanner sc = new Scanner(System.in); String str = sc.next(); dos.writeUTF(str); dos.close(); s.close(); } catch (UnknownHostException e) { // TODO Auto-generated catch block e.printStackTrace(); } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); } } } java高级反射机制创建对象类对象，就是用于描述这种类，都有什么属性，什么方法的。获取类对象有几种方式： Class.forName Hero.class new Hero().getClass() 在一个JVM中，一种类，只会有一个类对象存在，所以几种方式取出来的类对象，都是一样的（准确的讲是一个ClassLoader下，一种类，只会有一个类对象存在。通常一个JVM下，只会有一个ClassLoader） 可以为类增加一个静态属性，并且在静态初始化块里进行初始化。无论以什么途径获取类对象，都会导致静态属性被初始化，并且只会执行一次（除了直接使用 Class c = Hero.class 的方式，这种方式不会导致静态属性被初始化） 如果在类方法前，加上修饰符synchronized，同步对象是类对象 import java.lang.reflect.Constructor; public static void main(String[] args) { try { //使用反射的方式创建对象 //反射机制，会先拿到Hero的“类对象”，然后通过类对象获取“构造器对象”，再通过构造器对象创建一个对象 String className = &quot;charactor.Hero&quot;; //类对象 Class pClass = Class.forName(className); //构造器 Constructor c = pClass.getConstructor(); //通过构造器实例化 Hero h2 = (Hero) c.newInstance(); } catch (Exception e) { e.printStackTrace(); } } 访问属性import java.lang.reflect.Field; public static void main(String[] args) { Hero h = new Hero(); //使用传统方式修改name的值为garen h.name = &quot;garen&quot;; try { //获取类Hero的名字叫做name的字段 Field f1 = h.getClass().getDeclaredField(&quot;name&quot;); //修改这个字段的值 f1.set(h, &quot;teemo&quot;); //例如修改private属性id //f1.setAccessible(true); //f1.set(h, 2); } catch (Exception e) { e.printStackTrace(); } } getField和getDeclaredField都是用于获取字段，但是getField只能获取public的，包括从父类继承来的字段。而getDeclaredField可以获取本类所有的字段，包括private的，但是不能获取继承来的字段（这里只能获取到private的字段，对于private修饰的成员，需要使用setAccessible(true)才能访问和修改） 调用方法import java.lang.reflect.Method; public static void main(String[] args) { Hero h = new hero(); try { //获取这个名字叫做setName，参数类型是String的方法 Method m = h.getClass().getMethod(&quot;setName&quot;, String.class); //对h对象，调用这个方法 m.invoke(h, &quot;盖伦&quot;); } } 反射的应用使用反射方式，准备一个配置文件，里面存放内容是类的名称，和调用的方法名，可以通过配置文件取出类名称和方法名，然后通过反射去调用这个方法，当需要从调用某个类的某个类的某个方法切换到调用到另一个类的某个方法时，不需要修改一行代码，也不需要重新编译，只需要修改配置文件，再运行即可 import java.util.Properties; @SuppressWarning({ &quot;rawtypes&quot;, &quot;unchecked&quot; }) public static void main(String[] args) throws Exception { File springConfigFile = new File(&quot;..&quot;); Properties springConfig = new Properties(); springConfig.load(new FileInputStream(springConfigFile)); String className = (String) springConfig.get(&quot;class&quot;); String methodName = (String) springConfig.get(&quot;method&quot;); //根据类名称获取类对象 Class clazz = Class.forName(className); //根据方法名称，获取方法对象 Method m = clazz.getMethod(methodName); //获取构造器 Constructor c = clazz.getConstructor(); //根据构造器，实例化出对象 Object service = c.newInstance(); //调用对象的指定方法 m.invoke(service); } 前端部分html DOMDOM把所有的html都转换成节点，整个文档是个节点，元素是节点，元素属性是节点，元素内容是节点，注释也是节点 获取节点&lt;html&gt; &lt;div id=&quot;d1&quot;&gt;hello HTML DOM&lt;/div&gt; &lt;script&gt; // 获取某个元素对应的元素节点对象 var div1 = document.getElementById(&quot;d1&quot;); document.write(div1) // 根据标签名称获取一个元素数组 var divs = document.getElementsByTagName(&quot;div&quot;); for(i=0;i&lt;divs.length;i++){ document.write(divs[i]); document.write(&quot;&lt;br&gt;&quot;); } // 根据class返回一个节点数组 var elements = document.getElementsByClassName(&quot;d&quot;); // 根据name属性的值，获取元素节点 var elements = document.getElementsByName(&quot;userName&quot;); // 如果div标签还没有加载，则无法获取该元素节点，因为javascript是解释语言，是顺序执行的 &lt;/script&gt; &lt;/html&gt; 通过元素节点的attributes获取其下所有的属性节点，属性节点以数组的形式返回出来 &lt;html&gt; &lt;div id=&quot;d1&quot; align=&quot;center&quot; class=&quot;abc&quot;&gt;hello HTML DOM&lt;/div&gt; &lt;script&gt; var div1 = document.getElementById(&quot;d1&quot;); var as = div1.attributes; document.write(&quot;div总共有&quot;+as.length +&quot; 个属性&quot;); document.write(&quot;分别是:&quot;); for(i = 0; i&lt; as.length; i++){ document.write(&quot;&lt;br&gt;&quot;); document.write(as[i].nodeName); document.write(&quot;:&quot;); document.write(as[i].nodeValue); } document.write(&quot;&lt;br&gt;&quot;); document.write(&quot;div的id属性值是：&quot;+ as[&quot;id&quot;].nodeValue); &lt;/script&gt; &lt;/html&gt; 通过元素节点的childNodes获取其所有的子节点。其中第一个子节点，就是其内容节点 &lt;html&gt; &lt;div id=&quot;d1&quot; align=&quot;center&quot; class=&quot;abc&quot;&gt;hello HTML DOM&lt;/div&gt; &lt;script&gt; var div1 = document.getElementById(&quot;d1&quot;); var content = div1.childNodes[0]; document.write(&quot;div的内容节点名是:&quot;+content.nodeName); document.write(&quot;&lt;br&gt;&quot;); document.write(&quot;div的内容节点值是:&quot;+content.nodeValue); &lt;/script&gt; &lt;/html&gt; 节点的属性nodeName表示一个节点的名字。document.nodeName（文档的节点名，是固定的#document），div1.nodeName（元素的节点名，是对应的标签名div），div1.attributes[0].nodeName（属性的节点名，是对应的属性名id），div1.childNodes[0].nodeName（内容的节点名，是固定的#text） nodeValue表示一个节点的值。document.nodeValue（文档的节点值，是null），div1.nodeValue（元素的节点值，是null），div1.attributes[0].nodeValue（属性的节点值，是对应的属性值d1），div1.childNodes[0].nodeValue（内容的节点值，是内容） nodeType表示一个节点的类型，不同的节点类型，对应的节点类型值是不一样的 元素类型 NodeType 元素 1 属性 2 文本 3 注释 8 文档 9 修改和获取内容的值可以通过childNodes[0].nodeValue进行，也可以通过innerHTML进行。 元素上的属性，比如id，value可以通过 . 直接访问，如果是自定义属性，可以通过getAttributes(“test”)、attributes[“test”].nodeValue获取 &lt;html&gt; &lt;div id=&quot;d1&quot;&gt;hello HTML DOM&lt;/div&gt; &lt;script&gt; function get(){ var input1 = document.getElementById(&quot;input1&quot;); var s = &quot;id=&quot;+input1.id + &quot;&lt;br&gt;&quot;; s += &quot;value=&quot;+input1.value + &quot;&lt;br&gt;&quot;; s += &quot;class=&quot;+input1.className + &quot;&lt;br&gt;&quot;; s += &quot;test=&quot;+input1.getAttribute(&quot;test&quot;)+ &quot;&lt;br&gt;&quot;; s += &quot;test=&quot;+input1.attributes[&quot;test&quot;].nodeValue+ &quot;&lt;br&gt;&quot;; document.getElementById(&quot;d1&quot;).innerHTML= s; } &lt;/script&gt; &lt;input id=&quot;input1&quot; class=&quot;class1 class2&quot; test=&quot;t1&quot; value=&quot;这是一个输入框&quot;&gt; &lt;br&gt; &lt;button onclick=&quot;get()&quot;&gt;获取input的属性&lt;/button&gt; &lt;div style=&quot;height:30px&quot;&gt;&lt;/div&gt; &lt;/html&gt; 一个元素节点的style属性即对应的css 节点关系 DIV[id=d1]-&gt;DIV[id=parentDiv]-&gt;body-&gt;html-&gt;documen（递归获取子节点的父节点） 通过parentNode获取父节点，通过previousSibling和nextSibling属性获取前一个，以及后一个同胞节点。如果两个同胞节点不是紧挨着的，标签之间有任何字符、空白、换行都会产生文本元素，此时获取到的节点是#text firstChild、lastChild和childNodes分别用于获取第一个子节点、最后一个子节点和所有子节点，firstNode如果父节点的开始标签和第一个元素的开始标签之间有文本、空格、换行，那么firstChild第一个子节点将会是文本节点，而不会是第一个元素节点，lastChild同理 childNodes和children都可以获取一个元素节点的子节点，但是childNodes会包含文本节点，chidren会排除文本节点 创建节点&lt;html&gt; &lt;div id=&quot;d&quot;&gt;Hello HTML DOM&lt;/div&gt; &lt;script&gt; function add(){ // 通过 createElement 创建一个新的元素节点 // 接着吧该元素节点，通过 appendChild 加入到另一个元素节点div1中 var hr=document.createElement(&quot;hr&quot;); var div1 = document.getElementById(&quot;d&quot;); div1.appendChild(hr); // 通过 createTextNode 创建一个内容节点 text // 然后 text 加入到 p，再把 p 加入到 div var p=document.createElement(&quot;p&quot;); var text = document.createTextNode(&quot;这是通过DOM创建出来的&lt;p&gt;&quot;); p.appendChild(text); var div1 = document.getElementById(&quot;d&quot;); div1.appendChild(p); // 通过 createAttribute 创建一个属性节点 href ，然后设置 href 的值，接着通过 setAttributeNode 把该属性设置到元素节点 a 上 var a=document.createElement(&quot;a&quot;); var content = document.createTextNode(&quot;http://12306.com&quot;); a.appendChild(content); var href = document.createAttribute(&quot;href&quot;); href.nodeValue=&quot;http://12306.com&quot;; a.setAttributeNode(href); var div1 = document.getElementById(&quot;d&quot;); div1.appendChild(a); } &lt;/script&gt; &lt;button onclick=&quot;add()&quot;&gt;在div中追加一个hr元素&lt;/button&gt; &lt;/html&gt; 删除节点&lt;script&gt; function removeDiv(){ var parentDiv = document.getElementById(&quot;parentDiv&quot;); var div2= document.getElementById(&quot;div2&quot;); // 删除某个元素节点：首先获取该元素的父节点，然后通过父节点，调用removeChild删除该节点 parentDiv.removeChild(div2); // 删除某个属性节点：首先获取该元素节点，元素节点调用 removeAttribute 删除指定属性节点 parentDiv.removeAttribute(&quot;id&quot;) } // 删除文本节点：可以通过 childNodes[0] 获取文本节点，然后通过removeChild删除该文本节点，但是这种方式比较麻烦，一般都是直接通过 innerHTML 设置为空即可，也可以通过 innerHTML=&quot;&quot;的方式，同样会导致文本子节点被删除 function removeDiv1(){ var parentDiv = document.getElementById(&quot;parentDiv&quot;); var textNode = parentDiv.childNodes[0]; parentDiv.removeChild(textNode); } function removeDiv2(){ var parentDiv = document.getElementById(&quot;parentDiv&quot;); parentDiv.innerHTML=&quot;&quot;; } function recover(){ var parentDiv = document.getElementById(&quot;parentDiv&quot;); parentDiv.innerHTML=&quot;这里是文本 &quot;; } &lt;/script&gt; &lt;div id=&quot;parentDiv&quot;&gt; &lt;div id=&quot;div1&quot;&gt;安全的div&lt;/div&gt; &lt;div id=&quot;div2&quot;&gt;即将被删除的div&lt;/div&gt; &lt;/div&gt; &lt;button onclick=&quot;removeDiv()&quot;&gt;删除第二个div&lt;/button&gt; 替换和插入节点&lt;div id=&quot;parentDiv&quot;&gt; &lt;div id=&quot;d1&quot;&gt;第一个div&lt;/div&gt; &lt;div id=&quot;d2&quot;&gt;第二个div&lt;/div&gt; &lt;div id=&quot;d3&quot;&gt;第三个div&lt;/div&gt; &lt;/div&gt; &lt;script&gt; function replaceDiv(){ var d4= document.createElement(&quot;div&quot;); var text = document.createTextNode(&quot;第四个div&quot;); d4.appendChild(text); var d3 = document.getElementById(&quot;d3&quot;); var parentDiv = document.getElementById(&quot;parentDiv&quot;); // 替换节点也需要先获取父节点，然后通过父节点替换子节点。replaceChild 的第一个参数是保留的节点，第二个参数被替换的节点 parentDiv.replaceChild(d4,d3); // 在指定位置插入节点，而不只是追加在后面 var d25 = document.createElement(&quot;div&quot;); var text = document.createTextNode(&quot;第二点五个div&quot;); d25.appendChild(text); // insertBefore 的第一个参数是新元素，第二个参数是插入位置（元素节点d3之前） parentDiv.insertBefore(d25, d3); } &lt;/script&gt; &lt;button onclick=&quot;replaceDiv()&quot;&gt;替换第3个div&lt;/button&gt; AJAX如果不使用AJAX，传统的方法需要通过提交数据刷新页面来获知用户名是否存在 使用method=”get”提交数据是常用的提交数据的方式，如果form元素没有提供method属性，默认就是get方式提交数据，get方式的特点是提交数据会在浏览器显示出来，不可以用于提交二进制数据，比如上传文件（如果通过一个超链访问某个地址，是get方式；如果在地址栏直接输入某个地址，是get方式）。 使用method=”post”也可以提交数据，post不会在地址栏显示提交的参数，如果要提交二进制数据，比如上传文件，必须采用post方式 &lt;form action=&quot;https://how2j.cn/study/checkName.jsp&quot;&gt; 输入账号 &lt;input name=&quot;name&quot; type=&quot;text&quot; value=&quot;abc&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;验证账号是否存在&quot;&gt; &lt;/form&gt; AJAX指的是网页中提交一个数据，但是页面不刷新 &lt;span&gt;输入账号：&lt;/span&gt; &lt;input id=&quot;name&quot; name=&quot;name&quot; onkeyup=&quot;check()&quot; type=&quot;text&quot;&gt; &lt;span id=&quot;checkResult&quot;&gt;&lt;/span&gt; &lt;script&gt; var xmlhttp; function check() { var name = document.getElementById(&quot;name&quot;).value; var url = &quot;https://how2j.cn/study/checkName.jsp?name=&quot;+name; // 创建XHR（XML Http Request）对象，它是一个javascript对象，可以在用户没有感觉的情况下，就像背后运行的一根小线程一般，悄悄地和服务器进行数据交互 xmlhttp = new XMLHttpRequest(); // XHR对象的作用是和服务器进行交互，所以既会发消息给服务器，也能接受服务器返回的响应 xmlhttp.onreadystatechange = checkResult; //设置响应函数 // 通过open函数设置背后的这个小线程，将要访问的页面url作为参数传递 xmlhttp.open(&quot;GET&quot;, url, true); //设置可以访问的页面 // 使用send函数进行实际的访问，null表示没有参数，因为参数已经通过“GET”方式，放在url里了，只有在用“POST”，并且需要发送参数的时候，才会使用到send，类似这样：xmlhttp.send(&quot;user=&quot;+username+&quot;&amp;password=&quot;+password) xmlhttp.send(null); //执行访问 } // 在checkResult函数中处理响应 function checkResult() { // xmlhttp.readyState 4 表示请求已完成 // xmlhttp.status 200 表示响应成功 // xmlhttp.responseText 用于获取服务端传回来的文本 if (xmlhttp.readyState == 4 &amp;&amp; xmlhttp.status == 200) document.getElementById(&quot;checkResult&quot;).innerHTML = xmlhttp.responseText; } &lt;/script&gt; 框架部分Spring","categories":[{"name":"生活","slug":"生活","permalink":"http://goodguyjameswin.github.io/categories/生活/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://goodguyjameswin.github.io/tags/学习笔记/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"http://goodguyjameswin.github.io/categories/生活/"}]},{"title":"yolo格式的数据标签转icdar格式","slug":"yolo_icdar","date":"2021-09-06T12:30:01.000Z","updated":"2021-10-10T12:40:20.848Z","comments":false,"path":"2021/09/06/yolo_icdar/","link":"","permalink":"http://goodguyjameswin.github.io/2021/09/06/yolo_icdar/","excerpt":"","text":"引言第一篇文章（水文）！研一参与的第一个项目，用yolo来检测（识别）图片中的喷码字符（生产日期），然后很长一段时间都在给数据打标签 问题在于用yolo去做逐字符的检测，输出的框顺序并不像我们所认知的那样，分行排列，从上至下，从左至右 yolo格式标签&lt;object-class&gt; &lt;x&gt; &lt;y&gt; &lt;width&gt; &lt;height&gt; x，y是检测框的中心坐标；width，height是检测框的宽和高。这些坐标是通过归一化的，其中x，width是使用原图的width进行归一化；而y，height是使用原图的height进行归一化 icdar格式标签path/to/img [{&quot;transcription&quot;: &quot;content&quot;, &quot;points&quot;: [[x1, y1], [x2, y2], [x3, y3], [x4, y4]]}, {...}] 标签是包含多个字典的list，字典中的 points 表示文本框的四个点的坐标(x, y)，从左上角的点开始顺时针排列。 transcription 表示当前文本框的内容 实现把问题转换为对yolo输出检测框的排序。已知量是每个检测框的横、纵坐标，思路是先把所有检测框按纵坐标分成不同行，每行再按横坐标排序 原先的项目数据里，待识别的图片样式基本不变，可以直接在界面里设置每行文本的字符个数，当时的代码就是直接根据这一条件来对检测框排序。然后就检测条形码和二维码去了 后来项目的数据样式变多了，感觉原来的方法行不通了，最近在用paddleocr做文本识别，需要把以前训练yolo的一些数据标签转成icdar格式，所以又要重新面对这个yolo检测框的排序问题，那就趁着这个机会把代码写清楚 自然断点法a = np.array([5, 35, 38, 41, 65, 68, 98, 99, 100, 99, 105, 106, 102, 104, 103, 100, 110, 69, 64, 70, 75, 71, 73, 72, 42, 46, 40, 36, 37, 6, 8, 11, 4, 15, 10, 9, 4, 8, 135]) 思路还是先把检测框按纵坐标分行，想了半天，放弃 后来在pycharm里边写代码边debug，发现对数组View as Array的时候有个Colored cells选项，可以把一维数组分块，联想到yolo检测框按纵坐标分行，然后上网去搜有没有一维数组的聚类方法 发现可以用python的机器学习算法库里一个叫核密度估计的方法，实现对多维数据分布规律的曲线模拟。那把一维数组扩充到多维不就好了？（大材小用），搜了下这个库的调用方法 a = np.array([5, 35, 38, 41, 65, 68, 98, 99, 100, 99, 105, 106, 102, 104, 103, 100, 110, 69, 64, 70, 75, 71, 73, 72, 42, 46, 40, 36, 37, 6, 8, 11, 4, 15, 10, 9, 4, 8, 135]).reshape(-1, 1) kde = KernelDensity(kernel=&#39;gaussian&#39;, bandwidth=3).fit(a[:, 0].reshape(-1, 1)) # 构造指定数据的核密度估计 s = np.linspace(0, 140) e = kde.score_samples(s.reshape(-1, 1)) # 在特定数据上用核函数拟合 观察了下拟合出来的曲线，确实求个极值就可以找到断点了 mi, ma = argrelextrema(e, np.less)[0], argrelextrema(e, np.greater)[0] # 计算数组指定轴的相对极值 Minima: [25.71428571 54.28571429 85.71428571 122.85714286] Maxima: [8.57142857 37.14285714 71.42857143 100. 134.28571429] 然后根据断点把一维数组分块，还行 [5 6 8 11 4 15 10 9 4 8] [35 38 41 42 46 40 36 37] [65 68 69 64 70 75 71 73 72] [98 99 100 99 105 106 102 104 103 100 110] [135] 后话最后整合到标签转换脚本里去，转换速度还行。。吧 这样就可以用上学长的data_maker了哈哈哈 虽然我个人倾向于用python的pillow库函数ImageFont来制作字符数据，但是喷码样式的字体文件着实不好搞，字符贴图的背景区域定位那块代码也一直想吐槽，之后抽个时间优化下吧，顺便再水一篇文章","categories":[{"name":"技术","slug":"技术","permalink":"http://goodguyjameswin.github.io/categories/技术/"}],"tags":[{"name":"开源项目","slug":"开源项目","permalink":"http://goodguyjameswin.github.io/tags/开源项目/"},{"name":"ocr","slug":"ocr","permalink":"http://goodguyjameswin.github.io/tags/ocr/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://goodguyjameswin.github.io/categories/技术/"}]}]}