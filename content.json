{"meta":{"title":"zt's blog","subtitle":null,"description":"没有记流水帐的习惯~","author":"Terry Joe","url":"http://goodguyjameswin.github.io"},"pages":[{"title":"","date":"2021-09-02T07:22:26.499Z","updated":"2021-09-02T07:21:51.283Z","comments":true,"path":"404.html","permalink":"http://goodguyjameswin.github.io/404.html","excerpt":"","text":"页面没有找到 | zt's Blog body { background: #00c4b6; } #not_found { position: fixed; top: 50%; left: 50%; transform: translateY(-50%) translateX(-50%) scale(1.2); width: 80%; height: auto; } (function () { var lastTime = 0; var vendors = ['ms', 'moz', 'webkit', 'o']; for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) { window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame']; window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] || window[vendors[x] + 'CancelRequestAnimationFrame']; } if (!window.requestAnimationFrame) window.requestAnimationFrame = function (callback, element) { var currTime = new Date().getTime(); var timeToCall = Math.max(0, 16 - (currTime - lastTime)); var id = window.setTimeout(function () { callback(currTime + timeToCall); }, timeToCall); lastTime = currTime + timeToCall; return id; }; if (!window.cancelAnimationFrame) window.cancelAnimationFrame = function (id) { clearTimeout(id); }; })(); //math2 utils var Math2 = {}; Math2.random = function (t, n) { return Math.random() * (n - t) + t; }, Math2.map = function (t, n, r, a, o) { return (o - a) * ((t - n) / (r - n)) + a; }, Math2.randomPlusMinus = function (t) { return t = t ? t : .5, Math.random() > t ? -1 : 1; }, Math2.randomInt = function (t, n) { return n += 1, Math.floor(Math.random() * (n - t) + t); }, Math2.randomBool = function (t) { return t = t ? t : .5, Math.random() < t ? !0 : !1; }, Math2.degToRad = function (t) { return rad = t * Math.PI / 180, rad; }, Math2.radToDeg = function (t) { return deg = 180 / (Math.PI * t), deg; }, Math2.rgbToHex = function (t) { function n(t) { return (\"0\" + parseInt(t).toString(16)).slice(-2); } t = t.match(/^rgb((d+),s*(d+),s*(d+))$/); var r = n(t[1]) + n(t[2]) + n(t[3]); return r.toUpperCase(); }, Math2.distance = function (t, n, r, a) { return Math.sqrt((r - t) * (r - t) + (a - n) * (a - n)); }; //mouse var mousePos = { x: 0, y: 0 }; window.onmousemove = function (e) { e = e || window.event; var pageX = e.pageX; var pageY = e.pageY; if (pageX === undefined) { pageX = e.clientX + document.body.scrollLeft + document.documentElement.scrollLeft; pageY = e.clientY + document.body.scrollTop + document.documentElement.scrollTop; } mousePos = { x: pageX, y: pageY }; }; var options = { width: window.innerWidth, height: window.innerHeight, keyword: \"404\", density: 10, densityText: 3, minDist: 20 }; // initialize canvas var canvas = document.createElement('canvas'); canvas.width = options.width; canvas.height = options.height; canvas.style.width = options.width / 2; canvas.style.height = options.height / 2; canvas.getContext('2d').scale(2, 2); var renderer = new PIXI.autoDetectRenderer(options.width, options.height, { transparent: true }); var stage = new PIXI.Stage(\"0X000000\", true); document.body.appendChild(renderer.view); renderer.view.id = \"not_found\"; var imageData = false; var particles = []; function init() { positionParticles(); positionText(); } function positionParticles() { var canvas = document.createElement(\"canvas\"); canvas.width = 500; canvas.height = 350; var context = canvas.getContext(\"2d\"); context.fillStyle = \"#000000\"; context.font = \"300px 'Arial', sans-serif\"; context.fillText(options.keyword, 0, 250); var imageData = context.getImageData(0, 0, 350, 500); data = imageData.data; // Iterate each row and column for (var i = 0; i < imageData.height; i += options.density) { for (var j = 0; j < imageData.width; j += options.density) { // Get the color of the pixel var color = data[j * (imageData.width * 4) + i * 4 - 1]; // If the color is black, draw pixels if (color == 255) { var newPar = particle(); newPar.setPosition(i, j); particles.push(newPar); stage.addChild(newPar); } } } } function positionText() { var canvas = document.createElement(\"canvas\"); canvas.width = 400; canvas.height = 200; var context = canvas.getContext(\"2d\"); context.fillStyle = \"#000000\"; context.font = \"80px 'Arial', sans-serif\"; context.fillText(\"Not Found\", 0, 80); var imageData = context.getImageData(0, 0, 400, 400); data = imageData.data; // Iterate each row and column for (var i = 0; i < imageData.height; i += options.densityText) { for (var j = 0; j < imageData.width; j += options.densityText) { // Get the color of the pixel var color = data[j * (imageData.width * 4) + i * 4 - 1]; // If the color is black, draw pixels if (color == 255) { var newPar = particle(true); newPar.setPosition(i, j); particles.push(newPar); stage.addChild(newPar); } } } } function particle(text) { $this = new PIXI.Graphics(); if (text == true) { $this.text = true; } $this.beginFill(0XFFFFFF); var radius; $this.radius = radius = $this.text ? Math.random() * 3.5 : Math.random() * 10.5; $this.drawCircle(0, 0, radius); $this.size = this.radius; $this.x = -this.width; $this.y = -this.height; $this.free = false; $this.timer = Math2.randomInt(0, 100); $this.v = Math2.randomPlusMinus() * Math2.random(.5, 1); $this.hovered = false; $this.alpha = Math2.randomInt(10, 100) / 100; $this.vy = -5 + parseInt(Math.random() * 10) / 2; $this.vx = -4 + parseInt(Math.random() * 8); $this.setPosition = function (x, y) { if ($this.text) { $this.x = x + (options.width / 2 - 180); $this.y = y + (options.height / 2 + 100); } else { $this.x = x + (options.width / 2 - 250); $this.y = y + (options.height / 2 - 175); } }; return $this; } function update() { renderer.render(stage); for (i = 0; i < particles.length; i++) { var p = particles[i]; if (mousePos.x > p.x && mousePos.x < p.x + p.size && mousePos.y > p.y && mousePos.y < p.y + p.size) { p.hovered = true; } p.scale.x = p.scale.y = scale = Math.max(Math.min(2.5 - Math2.distance(p.x, p.y, mousePos.x, mousePos.y) / 160, 160), 1); p.x = p.x + .2 * Math.sin(p.timer * .15); p.y = p.y + .2 * Math.cos(p.timer * .15); p.timer = p.timer + p.v; } window.requestAnimationFrame(update); } init(); update();"},{"title":"about","date":"2021-09-04T14:14:36.000Z","updated":"2021-09-08T00:52:21.259Z","comments":false,"path":"about/index.html","permalink":"http://goodguyjameswin.github.io/about/index.html","excerpt":"","text":"[WHUTのTerryJoe] 与&nbsp; Kirito&nbsp; （ Asuna ） 对话中... bot_ui_ini()","keywords":"关于我"},{"title":"music","date":"2021-09-04T15:14:28.000Z","updated":"2021-10-07T08:23:31.367Z","comments":false,"path":"music/index.html","permalink":"http://goodguyjameswin.github.io/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"rss","date":"2021-09-04T15:09:03.000Z","updated":"2021-09-08T00:53:21.547Z","comments":true,"path":"rss/index.html","permalink":"http://goodguyjameswin.github.io/rss/index.html","excerpt":"","text":""},{"title":"links","date":"2021-09-04T15:11:06.000Z","updated":"2021-10-07T02:55:28.044Z","comments":false,"path":"links/index.html","permalink":"http://goodguyjameswin.github.io/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"tags","date":"2021-09-05T15:13:48.000Z","updated":"2021-09-11T09:08:30.171Z","comments":false,"path":"tags/index.html","permalink":"http://goodguyjameswin.github.io/tags/index.html","excerpt":"","text":"","keywords":"标签云"},{"title":"categories","date":"2021-09-04T16:40:09.000Z","updated":"2021-09-11T09:08:23.098Z","comments":false,"path":"categories/index.html","permalink":"http://goodguyjameswin.github.io/categories/index.html","excerpt":"","text":"","keywords":"分类图"},{"title":"comment","date":"2021-09-04T15:13:48.000Z","updated":"2021-09-08T00:52:58.243Z","comments":true,"path":"comment/index.html","permalink":"http://goodguyjameswin.github.io/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"video","date":"2021-09-04T15:14:38.000Z","updated":"2021-09-08T00:53:48.250Z","comments":false,"path":"video/index.html","permalink":"http://goodguyjameswin.github.io/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"},{"title":"bangumi","date":"2021-09-04T13:32:48.000Z","updated":"2021-09-08T00:52:34.864Z","comments":false,"path":"bangumi/index.html","permalink":"http://goodguyjameswin.github.io/bangumi/index.html","excerpt":"","text":"","keywords":null}],"posts":[{"title":"mybatis-plus学习","slug":"mybatis-plus学习","date":"2022-04-08T08:16:21.000Z","updated":"2022-06-17T05:35:55.868Z","comments":false,"path":"2022/04/08/mybatis-plus学习/","link":"","permalink":"http://goodguyjameswin.github.io/2022/04/08/mybatis-plus学习/","excerpt":"","text":"构建工程Mybatis-Plus中文文档 入门新建Maven父工程，导入依赖： &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.24&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.h2database&lt;/groupId&gt; &lt;artifactId&gt;h2&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; resources目录下新建application.yml配置文件中添加H2数据库的相关配置： # DataSource Config spring: datasource: driver-class-name: org.h2.Driver schema: classpath:db/schema=h2.sql data: classpath:db/data-h2.sql url: jdbc:h2:mem:test username: root password: test 在 Spring Boot 启动类中添加 @MapperScan 注解，扫描 Mapper 文件夹： @SpringBootApplication @MapperScan(&quot;scan.your.mapper.package&quot;) public class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); } } Mapper包下的UserMapper接口只需要继承BaseMapper&lt;T&gt;类即可（泛型指定封装数据类型） 配置日志mybatis-plus: configuration: log-impl: org.apache.ibatis.logging.stdout.StdOutImpl 主键策略主键注解@TableId(&quot;AUTO&quot;)，设置数据库ID自增，用在实体类的主键字段，数据库对应列也应当设置为自增 自动填充功能注解填充字段 @TableField(.. fill = FieldFill.INSERT) public class User { @TableField(fill = FieldFill.INSERT) private String createTime; @TableField(fill = FieldFill.INSERT_UPDATE) private String updateTime; ... } 实现元对象处理器接口：com.baomidou.mybatisplus.core.handlers.MetaObjectHandler @Slf4j @Component public class MyMetaObjectHandler implements MetaObjectHandler { @Override public void insertFill(MetaObject metaObject) { log.info(&quot;start insert fill ....&quot;); this.setFieldValByName(&quot;createTime&quot;, new Date(), metaObject); this.setFieldValByName(&quot;updateTime&quot;, new Date(), metaObject) } @Override public void updateFill(MetaObject metaObject) { log.info(&quot;start update fill ....&quot;); this.setFieldValByName(&quot;updateTime&quot;, new Date(), metaObject) } } 乐观锁当要更新一条记录时，希望这条记录没有被别人更新，实现方式为： 去除记录时，获取当前version 更新时，带上这个 version 执行更新时， set version = newVersion where version = oldVersion 如果 version 不对，就更新失败 @Configuration @MapperScan(&quot;scan.your.mapper.package&quot;) public class MybatisPlusConfig { @Bean public MybatisPlusInterceptor mybatisPlusInterceptor() { MybatisPlusInterceptor mybatisPlusInterceptor = new MybatisPlusInterceptor(); mybatisPlusInterceptor.addInnerInterceptor(new OptimisticLockerInnerInterceptor()); return mybatisPlusInterceptor; } } 在对应的实体类字段上加上@Version注解即可 分页配置拦截器 @Configuration @MapperScan(&quot;scan.your.mapper.package&quot;) public class MybatisPlusConfig { /** * 新的分页插件,一缓和二缓遵循mybatis的规则,需要设置 MybatisConfiguration#useDeprecatedExecutor = false 避免缓存出现问题 */ @Bean public MybatisPlusInterceptor mybatisPlusInterceptor() { MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor(); interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.H2)); return interceptor; } @Bean public ConfigurationCustomizer configurationCustomizer() { return configuration -&gt; configuration.setUseDeprecatedExecutor(false); } } 直接使用Page对象即可 逻辑删除增加一个字段，标记用户对数据库中数据的删除操作，实际上数据库中的数据未被删除（实际上进行的是更新操作），类似于回收站，后续管理员可根据需要进行数据库的清理 配置application.yml或者编写配置类 mybatis-plus: global-config: db-config: logic-delete-field: flag # 全局逻辑删除的实体字段名(配置后可以忽略配置类) logic-delete-value: 1 # 逻辑已删除值(默认为 1) logic-not-delete-value: 0 # 逻辑未删除值(默认为 0) @Configuration @MapperScan(&quot;scan.your.mapper.package&quot;) public class MybatisPlusConfig { @Bean public ISqlInjector sqlInjector() { return new LogicSqlInjector(); } } 对应实体类字段上加上@TableLogic注解即可 性能分析SQL执行效率插件 @Configuration @MapperScan(&quot;scan.your.mapper.package&quot;) public class MybatisPlusConfig { @Bean @Profile({&quot;dev&quot;, &quot;test&quot;}) // 设置 dev test 环境开启，保证效率，注意在 SpringBoot 环境中配置 spring.profiles.active=dev/test public PerformanceInterceptor performanceInterceptor() { PerformanceInterceptor performanceInterceptor = new PerformanceInterceptor(); performanceInterceptor.setMaxTime(100); // ms 设置sql执行的最大时间，如果超过了则不执行 performanceInterceptor.setFormat(true); // 是否格式化代码 return performanceInterceptor; } } 条件构造器@Test void contextLoads() { QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;(); // 链式编程 wrapper .isNotNull(&quot;name&quot;) // name 不为空 .isNotNull(&quot;email&quot;) // 邮箱不为空 .ge(&quot;age&quot;, 12); // 年龄大于等于12 // wrapper // 模糊查询 // .notLike(&quot;name&quot;, &quot;e&quot;); // name NOT LIKE &#39;%e%&#39; // .likeRight(&quot;email&quot;, &quot;t&quot;); // email LIKE &#39;t%&#39; // wrapper // .inSql(&quot;id&quot;, &quot;select id from user where id &lt; 3&quot;) // 子查询 // .orderByDsc(&quot;id&quot;); // 根据 id 进行降序排序 userMapper.selectList(wrapper).forEach(System.out::println); } 代码生成器导入依赖 &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt; &lt;version&gt;最新版本&lt;/version&gt; &lt;/dependency&gt; FastAutoGenerator.create(&quot;url&quot;, &quot;username&quot;, &quot;password&quot;) .globalConfig(builder -&gt; { builder.author(&quot;baomidou&quot;) // 设置作者 .enableSwagger() // 开启 swagger 模式 .fileOverride() // 覆盖已生成文件 .outputDir(&quot;/src/main/java&quot;); // 指定输出目录 }) .packageConfig(builder -&gt; { builder.parent(&quot;com.baomidou.mybatisplus.samples.generator&quot;) // 设置父包名 .moduleName(&quot;system&quot;) // 设置父包模块名 .pathInfo(Collections.singletonMap(OutputFile.xml, &quot;D://&quot;)); // 设置mapperXml生成路径 }) .strategyConfig(builder -&gt; { builder.addInclude(&quot;user&quot;) // 设置需要生成的表名 .addTablePrefix(&quot;t_&quot;, &quot;c_&quot;); // 设置过滤表前缀 }) .templateEngine(new FreemarkerTemplateEngine()) // 使用Freemarker引擎模板，默认的是Velocity引擎模板 .execute();","categories":[{"name":"生活","slug":"生活","permalink":"http://goodguyjameswin.github.io/categories/生活/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://goodguyjameswin.github.io/tags/学习笔记/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"http://goodguyjameswin.github.io/categories/生活/"}]},{"title":"springboot学习","slug":"springboot学习","date":"2021-12-10T08:26:45.000Z","updated":"2022-06-17T05:36:07.357Z","comments":false,"path":"2021/12/10/springboot学习/","link":"","permalink":"http://goodguyjameswin.github.io/2021/12/10/springboot学习/","excerpt":"","text":"构建工程 查看解析 解析，代码块如下： class Solution { public static void main(String[] args) { System.out.println(&quot;hello, world!&quot;); } }","categories":[{"name":"生活","slug":"生活","permalink":"http://goodguyjameswin.github.io/categories/生活/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://goodguyjameswin.github.io/tags/学习笔记/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"http://goodguyjameswin.github.io/categories/生活/"}]},{"title":"springmvc学习","slug":"springmvc学习","date":"2021-11-15T03:35:02.000Z","updated":"2022-06-17T05:34:37.254Z","comments":false,"path":"2021/11/15/springmvc学习/","link":"","permalink":"http://goodguyjameswin.github.io/2021/11/15/springmvc学习/","excerpt":"","text":"构建工程xml配置方式开发新建Maven父工程，导入SpringMVC依赖： &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.3.20&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;4.0.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet.jsp-api&lt;/artifactId&gt; &lt;version&gt;2.3.3&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp.jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; 新建一个Module，添加web的支持： 确保附加库可被打包进web工程： 配置Tomcat： 配置web.xml，注册DispatcherServlet： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;!-- 配置DispatcherServlet --&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;!-- 关联 Spring 的配置文件 --&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;!-- 启动级别：随着服务器启动而启动 --&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!-- / 匹配所有的请求（不包括.jsp），/* 配置所有的请求（包括.jsp） --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!-- 配置 Spring MVC 的乱码过滤 --&gt; &lt;filter&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;/web-app&gt; resources目录下新建Spring的配置文件applicationContext.xml： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!-- 添加处理映射器 --&gt; &lt;bean class=&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;/&gt; &lt;!-- DispatchServlet 调用 HandlerMapping，HandlerMapping 根据请求 url 查找 Handler --&gt; &lt;!-- 添加处理器适配器 --&gt; &lt;bean class=&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;/&gt; &lt;!-- HandlerAdapter 按照特定的规则去执行 Handler，Handler 让具体的 Controller 执行，Controller 将具体的执行信息返回给 HandlerAdapter，HandlerAdapter 将模型视图（ModelAndView）传递给 DispatcherServlet --&gt; &lt;!--添加视图解析器--&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt; &lt;/bean&gt; &lt;!-- DispatcherServlet 调用视图解析器（ViewResolver）来解析 HandlerAdapter 传递的逻辑视图名，DispatcherServlet 调用具体的视图，最终呈现给用户 --&gt; &lt;!-- Handler --&gt; &lt;bean id=&quot;/hello&quot; class=&quot;controller.HelloController&quot;/&gt; &lt;!-- HandlerExecution 表示具体的 Handler，其根据 url 查找 Controller，然后将解析后的信息传递给 DispatcherServlet --&gt; &lt;/beans&gt; 新建Controller层： // 导入 SpringMVC 下的 Controller 接口 public class HelloController implements Controller { public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception{ ModelAndView mv = new ModelAndView(); mv.addObject(&quot;msg&quot;, &quot;HelloSpringMVC!&quot;); mv.setViewName(&quot;hello&quot;); // /WEB-INF/jsp/hello.jsp return mv; } } 注解方式开发修改applicationContext.xml文件： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!--1. 注解驱动--&gt; &lt;mvc:annotation-driven/&gt; &lt;!-- 在 spring 中一般采用 @RequestMapping 注解来完成映射关系，要想使 @RequestMapping 注解生效，必须向上下文中注册 DefaultAnnotationHandlerMapping 和一个 AnnotationMethodHandlerAdapter 实例，这两个实例分别在类级别和方法级别处理，而 annotation-driven 配置帮助我们自动完成上述两个实例的注入 --&gt; &lt;!--2. 静态资源过滤--&gt; &lt;mvc:default-servlet-handler/&gt; &lt;!--3. 扫描包：controller--&gt; &lt;context:component-scan base-package=&quot;controller&quot;/&gt; &lt;!--4. 视图解析器--&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt; &lt;/bean&gt; &lt;/beans&gt; 修改Controller层： @Controller public class HelloController { @RequestMapping(&quot;/hello&quot;) // 也可在类上注解，表示映射方法与映射类的路径拼接关系 public String hello(@RequestParam(&quot;username&quot;) String name, Model model) { // 接受前端用户传递的参数，判断参数的名字，假设名字一致，可以直接使用，假设传递的是一个对象，则匹配对象中的字段名，名字不一致则匹配不到，此时使用 @RequestParam 指定要接收传递的参数名 model.addAttribute(&quot;msg&quot;, &quot;Hello, SpringMVCAnnotation!&quot;); // 封装数据 return &quot;hello&quot;; // 会被视图解析器处理 // 不配置视图解析器的情况下 // return &quot;/WEB-INF/jsp/hello.jsp&quot; // 使用全限定路径表示转发 // return &quot;forward:/WEB-INF/jsp/hello.jsp&quot; // 转发（地址栏不变） // return &quot;redirect:/hello.jsp&quot; // 重定向（地址栏变化） } } // RestFul 风格 @Controller public class RestFulController { // 映射访问路径 @RequestMapping(value = &quot;/add/{a}/{b}&quot;, method = &quot;RequestMethod.POST&quot;) // @PostMapping(&quot;/add/{a}/{b}&quot;) // 方法级别的注解处理地址栏的指定请求方式 public String add(@PathVariable int a, @PathVariable String b, Model model) { // @PathVariable 注解让方法参数的值对应绑定到一个 URL 模板变量 int result = a + b; // Spring MVC 会自动实例化一个 Model 对象用于向视图中传值 model.addAtrribute(&quot;msg&quot;, &quot;结果：&quot; + result); return &quot;hello&quot;; } } json导入jackson依赖： &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.13.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;2.0.4&lt;/version&gt; &lt;/dependency&gt; 修改Controller层： @Controller // @RestController // 表示这个类下的所有方法都不会被视图解析器解析，而是直接返回 public class UserController { // 解决json数据乱码问题（不常用） @RequestMapping(value = &quot;/j1&quot;, produces = &quot;application/json;charset=utf-8&quot;) @ResponseBody // 这个方法被视图解析器解析，而是直接返回一个字符串，与 @RestController 效果相同 public String json() throws JsonProcessingException { // jackson ObjectMapper mapper = new ObjectMapper(); User user = new User(&quot;小明&quot;, 3, &quot;男&quot;); String str = mapper.writeValueAsString(user); // 方法将对象转换为json格式字符串 return str; // fastjson // str = JSON.toJSONString(user); // java 对象转 JSON 字符串 // User user_json = JSON.parseObject(str, User.class); // JSON 字符串转 java 对象 } } 为了解决json乱码问题，在applicationContext.xml文件中添加： &lt;mvc:annotation-driven&gt; &lt;mvc:message-converters register-defaults=&quot;true&quot;&gt; &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt; &lt;constructor-arg value=&quot;UTF-8&quot;/&gt; &lt;/bean&gt; &lt;bean class=&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;&gt; &lt;property name=&quot;objectMapper&quot;&gt; &lt;bean class=&quot;org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean&quot;&gt; &lt;property name=&quot;failOnEmptyBeans&quot; value=&quot;false&quot;/&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt; &lt;/mvc:annotation-driven&gt; 拦截器继承HandlerInterceptor接口： public class MyInterceptor implements HandlerInterceptor { // 请求处理的方法之前执行 // 如果返回 true，放行（如果有，执行下一个拦截器） // 如果返回 false，则拦截 public boolean preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) { System.out.pringln(&quot;-------处理前-------&quot;); return true; } public boolean postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) { System.out.pringln(&quot;-------处理后-------&quot;); } } 在applicationContext.xml文件中添加： &lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;!-- 包括这个请求下面的所有的请求 --&gt; &lt;mvc:mapping path=&quot;/**&quot;/&gt; &lt;bean class=&quot;interceptor.MyInterceptor&quot;/&gt; &lt;/mvc:interceptro&gt; &lt;/mvc:interceptors&gt; 文件上传导入依赖： &lt;!-- 文件上传 --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt; &lt;/dependency&gt; 在applicationContext.xml文件中添加： &lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt; &lt;!-- 请求的编码方式，必须和 jsp 的 pageEncoding 属性一致，以便正确读取表单内容，默认为 ISO-8859-1 --&gt; &lt;property name=&quot;defaultEncoding&quot; value=&quot;utf-8&quot;/&gt; &lt;/bean&gt; 修改Controller层: @RestController public class FileController { // @RequestParam(&quot;file&quot;) 将 name=file 控件得到的文件封装成 CommonsMultipartFile对象 @RequestMapping(&quot;/upload&quot;) public String fileUpload(@RequestParam(&quot;file&quot;) CommonsMultipartFile file, HttpServletRequest request) throws IOException { // 上传路径保存设置 String path = request.getServletContext().getRealPath(&quot;/upload&quot;); File realPath = new File(path); if (!realPath.exists()) { realPath.mkdir(); } // 上传文件地址 System.out.println(&quot;上传文件保存地址:&quot; + realPath); // 通过 CommonsMultipartFile 的方法直接写文件 file.transferTo(new File(realPath + &quot;/&quot; + file.getOriginalFilename())); return &quot;ok&quot;; } }","categories":[{"name":"生活","slug":"生活","permalink":"http://goodguyjameswin.github.io/categories/生活/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://goodguyjameswin.github.io/tags/学习笔记/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"http://goodguyjameswin.github.io/categories/生活/"}]},{"title":"spring学习","slug":"spring学习","date":"2021-11-05T06:53:05.000Z","updated":"2022-06-17T05:34:19.165Z","comments":false,"path":"2021/11/05/spring学习/","link":"","permalink":"http://goodguyjameswin.github.io/2021/11/05/spring学习/","excerpt":"","text":"IOCxml配置方式开发创建maven父工程，删去冗余目录，导入依赖： &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.3.20&lt;/version&gt; &lt;/dependency&gt; 创建maven子工程，在src目录下新建实体类，resources目录下新建applicationContext.xml文件，注册实体类： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:c=&quot;http://www.springframework.org/schema/c&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!-- 无参构造 --&gt; &lt;!-- 默认为单例模式（singleton），而原型模式（prototype）指每次从容器中get的时候，都会产生一个新对象 --&gt; &lt;bean id=&quot;exampleBean&quot; class=&quot;examples.ExampleBean&quot; name=&quot;example1, example2,...&quot; scope=&quot;singleton, prototype&quot; autowire=&quot;byName, byType&quot;&gt; &lt;!-- 普通值注入 --&gt; &lt;property name=&quot;prop1&quot; value=&quot;1&quot;/&gt; &lt;!-- Bean注入 --&gt; &lt;property name=&quot;prop2&quot; ref=&quot;exampleBean2&quot;/&gt; &lt;!-- instead of using a reference to a target bean, simply define the target bean inline --&gt; &lt;property name=&quot;target&quot;&gt; &lt;bean class=&quot;com.example.Person&quot;&gt; &lt;!-- this is the inner bean --&gt; &lt;property name=&quot;name&quot; value=&quot;Fiona Apple&quot;/&gt; &lt;property name=&quot;age&quot; value=&quot;25&quot;/&gt; &lt;/bean&gt; &lt;/property&gt; &lt;!-- additional collaborators and configuration for this bean go here --&gt; &lt;/bean&gt; &lt;bean id=&quot;exampleBean2&quot; class=&quot;examples.ExampleBean2&quot;/&gt; &lt;!-- p命名空间注入，p指properties --&gt; &lt;bean name=&quot;john-modern&quot; class=&quot;com.example.Person&quot; p:name=&quot;John Doe&quot; p:spouse-ref=&quot;jane&quot;/&gt; &lt;!-- more bean definitions go here --&gt; &lt;!-- c命名空间注入，c指constructor-args --&gt; &lt;bean id=&quot;beanOne&quot; class=&quot;x.y.ThingOne&quot; c:thingTwo-ref=&quot;beanTwo&quot; c:thingThree-ref=&quot;beanThree&quot; c:email=&quot;something@somewhere.com&quot;/&gt; &lt;!-- 取别名 --&gt; &lt;alias name=&quot;exampleBean&quot; alias=&quot;aliasBean&quot;/&gt; &lt;!-- 导入多个配置文件 --&gt; &lt;import resource=&quot;beans1.xml&quot;/&gt; &lt;import resource=&quot;beans2.xml&quot;/&gt; &lt;/beans&gt; 对象交由 Spring 来创建，管理和装配，在配置文件加载的时候，容器中管理的对象就已经初始化了： // create and configure beans ApplicationContext context = new ClassPathXmlApplicationContext(&quot;services.xml&quot;, &quot;daos.xml&quot;); // retrieve configured instance PetStoreService service = context.getBean(&quot;petStore&quot;, PetStoreService.class); // use configured instance List&lt;String&gt; userList = service.getUsernameList(); 有参构造注入： &lt;!-- 有参构造 --&gt; &lt;!-- 参数名 --&gt; &lt;bean id=&quot;exampleBean&quot; class=&quot;examples.ExampleBean&quot;&gt; &lt;constructor-arg name=&quot;years&quot; value=&quot;7500000&quot;/&gt; &lt;constructor-arg name=&quot;ultimateAnswer&quot; value=&quot;42&quot;/&gt; &lt;/bean&gt; &lt;!-- 类型 --&gt; &lt;bean id=&quot;exampleBean&quot; class=&quot;examples.ExampleBean&quot;&gt; &lt;constructor-arg type=&quot;int&quot; value=&quot;7500000&quot;/&gt; &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;42&quot;/&gt; &lt;/bean&gt; &lt;!-- 下标索引 --&gt; &lt;bean id=&quot;exampleBean&quot; class=&quot;examples.ExampleBean&quot;&gt; &lt;constructor-arg index=&quot;0&quot; value=&quot;7500000&quot;/&gt; &lt;constructor-arg index=&quot;1&quot; value=&quot;42&quot;/&gt; &lt;/bean&gt; setter注入： &lt;bean id=&quot;moreComplexObject&quot; class=&quot;example.ComplexObject&quot;&gt; &lt;!-- results in a setAdminEmails(java.util.Properties) call --&gt; &lt;property name=&quot;adminEmails&quot;&gt; &lt;props&gt; &lt;prop key=&quot;administrator&quot;&gt;administrator@example.org&lt;/prop&gt; &lt;prop key=&quot;support&quot;&gt;support@example.org&lt;/prop&gt; &lt;prop key=&quot;development&quot;&gt;development@example.org&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;!-- results in a setSomeList(java.util.List) call --&gt; &lt;property name=&quot;someList&quot;&gt; &lt;list&gt; &lt;value&gt;a list element followed by a reference&lt;/value&gt; &lt;ref bean=&quot;myDataSource&quot; /&gt; &lt;/list&gt; &lt;/property&gt; &lt;!-- results in a setSomeMap(java.util.Map) call --&gt; &lt;property name=&quot;someMap&quot;&gt; &lt;map&gt; &lt;entry key=&quot;an entry&quot; value=&quot;just some string&quot;/&gt; &lt;entry key=&quot;a ref&quot; value-ref=&quot;myDataSource&quot;/&gt; &lt;/map&gt; &lt;/property&gt; &lt;!-- results in a setSomeSet(java.util.Set) call --&gt; &lt;property name=&quot;someSet&quot;&gt; &lt;set&gt; &lt;value&gt;just some string&lt;/value&gt; &lt;ref bean=&quot;myDataSource&quot; /&gt; &lt;/set&gt; &lt;/property&gt; &lt;property name=&quot;email&quot;&gt; &lt;null/&gt; &lt;/property&gt; &lt;/bean&gt; 注解方式开发修改applicationContext.xml配置文件： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!-- 开启注解驱动支持 --&gt; &lt;context:annotation-config/&gt; &lt;!-- 指定要扫描的包（全限定名），这个包下的注解就会生效 --&gt; &lt;context:component:scan base-package=&quot;...&quot;&gt; &lt;/beans&gt; @Autowired默认通过byType方式实现自动装配，参数required置为false与@Nullable效果相同，@Qualifier指定装配的bean，也可使用javax下的@Resource注解实现前两者的组合： public class MovieRecommender { private final CustomerPreferenceDao customerPreferenceDao; @Autowired(required = false) @Qualifier(&quot;...&quot;) private MovieCatalog movieCatalog; @Autowired public MovieRecommender(@Qualifier(&quot;...&quot;) CustomerPreferenceDao customerPreferenceDao) { this.customerPreferenceDao = customerPreferenceDao; } @Resource(name=&quot;...&quot;) public void setMovieCatalogs(Map&lt;String, MovieCatalog&gt; movieCatalogs) { this.movieCatalogs = movieCatalogs; } // ... } @Component（与@Repository、@Service和@Controller功能相同，后三者在springmvc中使用）将实体类注册到Spring中，@value注入简单参数： @Component @Scope(&quot;prototype&quot;) public class User{ public String name; @Value(&quot;...&quot;) public void setName(String name) { this.name = name; } } 通过JavaConfig方式实现（完全去掉applicationContext.xml配置文件），@Import导入其他配置类： // 配置类 @Configuration @ComponentScan(basePackages=&quot;...&quot;) @Import(...) public class AppConfig { // 等价于 &lt;bean id=&quot;myService&quot; class=&quot;com.acme.services.MyServiceImpl&quot;/&gt; @Bean public MyService myService() { return new MyServiceImpl(); } } // 测试类 public static void main(String[] args) { ApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class); MyService myService = ctx.getBean(MyService.class); myService.doStuff(); } AOP动态代理使用jdk反射库里的Proxy类和InvocationHandler类实现： public class ProxyInvocationHandler implements InvocationHandler { // 被代理的接口 private Object target; public void setTarget(Object target) { this.target = target}; // 生成得到代理类 public Object getProxy() { return Proxy.newProxyInstance(this.getClass().getClassLoader(), target.getClass().getInterfaces(), this); } // 处理代理实例，并返回结果： public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { log(method.getName()); Object result = method.invoke(target, args); return result; } public void log(String msg) { System.out.println(&quot;执行了&quot; + msg + &quot;方法&quot;); } } 原生 Spring API 接口和自定义类导入依赖： &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.8&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; 切入点（PoingCut）是通知执行的“地点”的定义；通知（Advice）指切面必须要完成的工作，它是类中的一个方法： public interface MethodBeforeAdvice extends BeforeAdvice { void before(Method m, Object[] args, Object target) throws Throwable; } public class CountingBeforeAdvice implements MethodBeforeAdvice { private int count; public void before(Method m, Object[] args, Object target) throws Throwable { ++count; } public int getCount() { return count; } } 切面（Aspect）指横切关注点被模块化的特殊对象，它是一个类： public class ConcurrentOperationExecutor implements Ordered { private static final int DEFAULT_MAX_RETRIES = 2; private int maxRetries = DEFAULT_MAX_RETRIES; private int order = 1; public void setMaxRetries(int maxRetries) { this.maxRetries = maxRetries; } public int getOrder() { return this.order; } public void setOrder(int order) { this.order = order; } public Object doConcurrentOperation(ProceedingJoinPoint pjp) throws Throwable { int numAttempts = 0; PessimisticLockingFailureException lockFailureException; do { numAttempts++; try { return pjp.proceed(); } catch(PessimisticLockingFailureException ex) { lockFailureException = ex; } } while(numAttempts &lt;= this.maxRetries); throw lockFailureException; } } 注解实现AOP： import org.aspectj.lang.annotation.Aspect; import org.aspectj.lang.annotation.Before; @Aspect public class BeforeExample { @Before(&quot;com.xyz.myapp.CommonPointcuts.dataAccessOperation()&quot;) public void doAccessCheck() { // ... } @Around(&quot;com.xyz.myapp.CommonPointcuts.businessService()&quot;) public Object doBasicProfiling(ProceedingJoinPoint pjp) throws Throwable { // start stopwatch Object retVal = pjp.proceed(); // stop stopwatch return retVal; } } resoureces下新建配置文件applicationContext.xml： &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;!-- 方式一：使用原生 Spring API 接口 --&gt; &lt;!-- this is the object that will be proxied by Spring&#39;s AOP infrastructure --&gt; &lt;bean id=&quot;personService&quot; class=&quot;x.y.service.DefaultPersonService&quot;/&gt; &lt;!-- this is the actual advice itself --&gt; &lt;bean id=&quot;beforeAdvice&quot; class=&quot;x.y.CountingBeforeAdvice&quot;/&gt; &lt;aop:config&gt; &lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* x.y.service.DefaultPersonService.*(..))&quot;/&gt; &lt;!-- 增加执行环绕 --&gt; &lt;aop:advisor advice-ref=&quot;beforeAdvice&quot; pointcut-ref=&quot;pointcut&quot;&gt; &lt;/aop:config&gt; &lt;!-- 方式二：自定义类（切面） --&gt; &lt;aop:config&gt; &lt;aop:aspect id=&quot;concurrentOperationRetry&quot; ref=&quot;concurrentOperationExecutor&quot;&gt; &lt;aop:pointcut id=&quot;idempotentOperation&quot; expression=&quot;execution(* com.xyz.myapp.service.*.*(..))&quot;/&gt; &lt;aop:around pointcut-ref=&quot;idempotentOperation&quot; method=&quot;doConcurrentOperation&quot;/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; &lt;bean id=&quot;concurrentOperationExecutor&quot; class=&quot;com.xyz.myapp.service.impl.ConcurrentOperationExecutor&quot;&gt; &lt;property name=&quot;maxRetries&quot; value=&quot;3&quot;/&gt; &lt;property name=&quot;order&quot; value=&quot;100&quot;/&gt; &lt;/bean&gt; &lt;!-- 方式三：注解 --&gt; &lt;bean id=&quot;BeforeExample&quot; class=&quot;x.y.BeforeExample&quot;/&gt; &lt;!-- 开启注解支持 JDK（默认 proxy-target-class=&quot;false&quot;，cglib（proxy-target-class=&quot;true&quot;））--&gt; &lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot;/&gt; &lt;/beans&gt; 整合MybatisMybatis-Spring中文文档 导入依赖： &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.3.20&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.7&lt;/version&gt; &lt;/dependency&gt; 新建applicationContext.xml配置文件： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx https://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt; &lt;!-- 使用Spring-JDBC提供的数据源 --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;!-- 绑定Mybatis配置文件 --&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt; &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath*:sample/config/mappers/**/*.xml&quot; /&gt; &lt;/bean&gt; &lt;!-- 方式一：SqlSessionTemplate --&gt; &lt;!-- SqlSessionTemplate 对应 SqlSession --&gt; &lt;bean id=&quot;sqlSession&quot; class=&quot;org.mybatis.spring.SqlSessionTemplate&quot;&gt; &lt;!-- 只能使用构造器注入sqlSessionFactory，因为它没有set方法 --&gt; &lt;constructor-arg index=&quot;0&quot; ref=&quot;sqlSessionFactory&quot; /&gt; &lt;/bean&gt; &lt;!-- 注入到DAO bean中 --&gt; &lt;bean id=&quot;userDao&quot; class=&quot;org.mybatis.spring.sample.dao.UserDaoImpl&quot;&gt; &lt;property name=&quot;sqlSession&quot; ref=&quot;sqlSession&quot; /&gt; &lt;/bean&gt; &lt;!-- 方式二：SqlSessionDaoSupport --&gt; &lt;bean id=&quot;userDao&quot; class=&quot;org.mybatis.spring.sample.dao.UserDaoImpl&quot;&gt; &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot; /&gt; &lt;/bean&gt; &lt;!-- 方式三：配置 Dao 接口扫描包，动态实现 Dao 接口注入到 Spring 容器中 --&gt; &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;!-- 注入 sqlSessionFactory --&gt; &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;/&gt; &lt;!-- 要扫描的 Dao 包 --&gt; &lt;property name=&quot;basePackage&quot; value=&quot;org.mybatis.spring.sample.dao&quot;/&gt; &lt;/bean&gt; &lt;!-- 配置声明式事务 --&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;constructor-arg ref=&quot;dataSource&quot; /&gt; &lt;/bean&gt; &lt;!-- 配置事务通知 --&gt; &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt; &lt;!-- 给哪些方法配置事务，配置事务的传播特性 --&gt; &lt;tx:attributes&gt; &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!-- 配置事务织入 --&gt; &lt;aop:config&gt; &lt;aop:pointcut id=&quot;txPointCut&quot; expression=&quot;execution(* x.y.service.DefaultPersonService.*(..))&quot;/&gt; &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;txPointCut&quot;&gt; &lt;/aop:config&gt; &lt;/beans&gt; 新建Dao层实现类： // 方式一 public class UserDaoImpl implements UserDao { private SqlSession sqlSession; public void setSqlSession(SqlSession sqlSession) { this.sqlSession = sqlSession; } public User getUser(String userId) { return sqlSession.selectOne(&quot;org.mybatis.spring.sample.mapper.UserMapper.getUser&quot;, userId); } } // 方式二 public class UserDaoImpl extends SqlSessionDaoSupport implements UserDao { public User getUser(String userId) { return getSqlSession().selectOne(&quot;org.mybatis.spring.sample.mapper.UserMapper.getUser&quot;, userId); } } 新建测试类： public class MyTest { @Test public void test() throws IOException { ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); UserMapper userMapper = context.getBean(&quot;userDao&quot;, UserDao.class); System.out.println(userMapper.selectUser(0)); } }","categories":[{"name":"生活","slug":"生活","permalink":"http://goodguyjameswin.github.io/categories/生活/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://goodguyjameswin.github.io/tags/学习笔记/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"http://goodguyjameswin.github.io/categories/生活/"}]},{"title":"rotated_data_maker","slug":"rotated-data-maker","date":"2021-10-27T13:30:45.000Z","updated":"2022-06-03T08:11:08.080Z","comments":false,"path":"2021/10/27/rotated-data-maker/","link":"","permalink":"http://goodguyjameswin.github.io/2021/10/27/rotated-data-maker/","excerpt":"","text":"简介一个用于数据增广的脚本，实验室的深度学习方案，针对性的真实数据永远都只有几张图，可是网络模型的性能本身就是建立在数据集的多样性上面，合成数据只能在一定程度上缓解数据量不足的问题，而且过度依赖合成数据容易导致模型过拟合，且无法从根本上提高模型的鲁棒性 用于生成可以训练多角度目标检测的网络的合成训练数据， 需要背景图和模板图 然后合成的图片大概长这个样子，也没打算再去做进一步的美化了 合成图片的过程中，将位置信息也记录下来，格式是DOTA数据集的标签样式 因为确实没什么实用性，写了一两天感觉也只是为了完成任务，细节的话，有兴趣可以看看这个贴图脚本","categories":[{"name":"技术","slug":"技术","permalink":"http://goodguyjameswin.github.io/categories/技术/"}],"tags":[{"name":"开源项目","slug":"开源项目","permalink":"http://goodguyjameswin.github.io/tags/开源项目/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://goodguyjameswin.github.io/categories/技术/"}]},{"title":"mybatis学习","slug":"mybatis学习","date":"2021-10-25T01:50:37.000Z","updated":"2022-06-17T05:33:54.928Z","comments":false,"path":"2021/10/25/mybatis学习/","link":"","permalink":"http://goodguyjameswin.github.io/2021/10/25/mybatis学习/","excerpt":"","text":"构建工程Mybatis中文文档 入门新建Maven父工程，导入依赖： &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.9&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.29&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Maven中静态资源过滤 --&gt; &lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt; 从xml文件中构建SqlSessionFactory： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt; &lt;configuration&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;${driver}&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;${url}&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;${username}&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;${password}&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=&quot;org/mybatis/example/BlogMapper.xml&quot;/&gt; &lt;/mappers&gt; &lt;/configuration&gt; 新建工具类： public class MabatisUtils() { private String resource; public MybatisUtils(String resouce) { this.resource = resource; } public static SqlSessionFactory getSqlSessionFactory() { InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); return sqlSessionFactory; } } 从xml文件中构建映射器（Mappers）： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; &lt;mapper namespace=&quot;org.mybatis.example.BlogMapper&quot;&gt; &lt;select id=&quot;selectBlog&quot; resultType=&quot;Blog&quot;&gt; select * from Blog where id = #{id} &lt;/select&gt; &lt;/mapper&gt; 或者使用注解： package org.mybatis.example; public interface BlogMapper { @Select(&quot;SELECT * FROM blog WHERE id = #{id}&quot;) Blog selectBlog(int id); } 新建测试类： import MybatisUtils; public class Test() { public static void main(String[] args) { SqlSessionFactory sqlSessionFactory = MybatisUtils.getSqlSessionFactory(); try (SqlSession session = sqlSessionFactory.openSession()) { BlogMapper mapper = session.getMapper(BlogMapper.class); Blog blog = mapper.selectBlog(101); } } } 结果映射&lt;resultMap id=&quot;userResultMap&quot; type=&quot;User&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;user_id&quot; /&gt; &lt;result property=&quot;username&quot; column=&quot;user_name&quot;/&gt; &lt;result property=&quot;password&quot; column=&quot;hashed_password&quot;/&gt; &lt;/resultMap&gt; &lt;select id=&quot;selectUsers&quot; resultMap=&quot;userResultMap&quot;&gt; select user_id, user_name, hashed_password from some_table where id = #{id} &lt;/select&gt; 关联（多对一） &lt;resultMap id=&quot;blogResult&quot; type=&quot;Blog&quot;&gt; &lt;association property=&quot;author&quot; column=&quot;author_id&quot; javaType=&quot;Author&quot; select=&quot;selectAuthor&quot;/&gt; &lt;/resultMap&gt; &lt;select id=&quot;selectBlog&quot; resultMap=&quot;blogResult&quot;&gt; SELECT * FROM BLOG WHERE ID = #{id} &lt;/select&gt; &lt;select id=&quot;selectAuthor&quot; resultType=&quot;Author&quot;&gt; SELECT * FROM AUTHOR WHERE ID = #{id} &lt;/select&gt; 集合（一对多） &lt;resultMap id=&quot;blogResult&quot; type=&quot;Blog&quot;&gt; &lt;collection property=&quot;posts&quot; javaType=&quot;ArrayList&quot; column=&quot;id&quot; ofType=&quot;Post&quot; select=&quot;selectPostsForBlog&quot;/&gt; &lt;/resultMap&gt; &lt;select id=&quot;selectBlog&quot; resultMap=&quot;blogResult&quot;&gt; SELECT * FROM BLOG WHERE ID = #{id} &lt;/select&gt; &lt;select id=&quot;selectPostsForBlog&quot; resultType=&quot;Post&quot;&gt; SELECT * FROM POST WHERE BLOG_ID = #{id} &lt;/select&gt; 动态SQL根据条件包含 where 子句的一部分，使用 if 标签： &lt;select id=&quot;findActiveBlogLike&quot; resultType=&quot;Blog&quot;&gt; SELECT * FROM BLOG WHERE state = ‘ACTIVE’ &lt;if test=&quot;title != null&quot;&gt; AND title like #{title} &lt;/if&gt; &lt;if test=&quot;author != null and author.name != null&quot;&gt; AND author_name like #{author.name} &lt;/if&gt; &lt;/select&gt; 从多个条件中选择一个，使用 choose、when、otherwise 标签： &lt;select id=&quot;findActiveBlogLike&quot; resultType=&quot;Blog&quot;&gt; SELECT * FROM BLOG WHERE state = ‘ACTIVE’ &lt;choose&gt; &lt;when test=&quot;title != null&quot;&gt; AND title like #{title} &lt;/when&gt; &lt;when test=&quot;author != null and author.name != null&quot;&gt; AND author_name like #{author.name} &lt;/when&gt; &lt;otherwise&gt; AND featured = 1 &lt;/otherwise&gt; &lt;/choose&gt; &lt;/select&gt; trim 用于定制元素的功能： &lt;select id=&quot;findActiveBlogLike&quot; resultType=&quot;Blog&quot;&gt; SELECT * FROM BLOG &lt;where&gt; &lt;if test=&quot;state != null&quot;&gt; state = #{state} &lt;/if&gt; &lt;if test=&quot;title != null&quot;&gt; AND title like #{title} &lt;/if&gt; &lt;if test=&quot;author != null and author.name != null&quot;&gt; AND author_name like #{author.name} &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; &lt;update id=&quot;updateAuthorIfNecessary&quot;&gt; update Author &lt;set&gt; &lt;if test=&quot;username != null&quot;&gt;username=#{username},&lt;/if&gt; &lt;if test=&quot;password != null&quot;&gt;password=#{password},&lt;/if&gt; &lt;if test=&quot;email != null&quot;&gt;email=#{email},&lt;/if&gt; &lt;if test=&quot;bio != null&quot;&gt;bio=#{bio}&lt;/if&gt; &lt;/set&gt; where id=#{id} &lt;/update&gt; &lt;trim prefix=&quot;WHERE&quot; prefixOverrides=&quot;AND |OR &quot;&gt; ... &lt;/trim&gt; &lt;trim prefix=&quot;SET&quot; suffixOverrides=&quot;,&quot;&gt; ... &lt;/trim&gt; 对集合进行遍历： &lt;select id=&quot;selectPostIn&quot; resultType=&quot;domain.blog.Post&quot;&gt; SELECT * FROM POST P &lt;where&gt; &lt;foreach item=&quot;item&quot; index=&quot;index&quot; collection=&quot;list&quot; open=&quot;ID in (&quot; separator=&quot;,&quot; close=&quot;)&quot; nullable=&quot;true&quot;&gt; #{item} &lt;/foreach&gt; &lt;/where&gt; &lt;/select&gt;","categories":[{"name":"生活","slug":"生活","permalink":"http://goodguyjameswin.github.io/categories/生活/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://goodguyjameswin.github.io/tags/学习笔记/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"http://goodguyjameswin.github.io/categories/生活/"}]},{"title":"yolov5-dota-obb","slug":"yolov5-dota-obb","date":"2021-10-09T02:19:20.000Z","updated":"2022-06-03T08:00:38.192Z","comments":false,"path":"2021/10/09/yolov5-dota-obb/","link":"","permalink":"http://goodguyjameswin.github.io/2021/10/09/yolov5-dota-obb/","excerpt":"","text":"简介最近出于项目需要，针对旋转目标检测的任务，做一个深度学习方案。浏览过程中看到一个国内大佬，针对yolov5做了修改，引入了长边表示法对旋转矩形检测框的定义，感觉效果还不错，标签的格式也比较好懂，准备上手尝试 好家伙，还是离不开DOTA_devkit的编译，今年四月份左右想入这个坑，就被windows上各种第三方库的编译给劝退了，然后发现旋转目标检测，基本都离不开对这个工具包的编译，因为旋转目标检测网络目前基本都是用DOTA数据集作benchmark，这个工具包可以很好的处理DOTA数据集 后来发现其实编译这个工具包，目的是调用其中有关多边形（旋转矩形框）做NMS（非极大值抑制）的方法，好说，我记得python有个shapely的库，也可以做多边形的IOU（重叠面积占比）运算。 挖坑踩坑这个工程，训练的时候跟原本的yolov5生态环境是一样的，方法调用不需要其他第三方库的支持，比如经典的mosaic数据增强，但是有几个坑 比如原作者的长边表示法是针对opencv4.2以前的版本中minAreaRect这一函数所返回的旋转矩形框所定义的角度做的优化，在高版本的opencv（比如opencv4.5以上）就不支持了。还有就是高版本的pytorch需要针对错误“torch.nn.modules.module.ModuleAttributeError: ‘Hardswish’ object has no attribute ‘inplace’”，找到pytorch的源码部分并做修改 def __init__(self, inplace : bool = False) -&gt; None: super(Hardwish, self).__init__() self.inplace = inplace def forward(self, input : Tensor) -&gt; Tensor: # 源码如下： # return F.hardwish(input, self.inplace) # 修改如下： return F.hardwish(input) 然后重点就是预测的时候，因为需要对经过网络前向推理后的结果（旋转矩形检测框）做NMS，这里需要调用DOTA_devkit工具包里编译好的iou_poly及poly_nms方法，用shapely库重写这一块 from shapely.geometry import Polygon, MultiPoint def iou_rotated_rect(line1, line2): a = np.array(line1).reshape(4, 2) poly1 = Polygon(a).convex_hull b = np.array(line2).reshape(4, 2) poly2 = Polygon(b).convex_hull union_poly = np.concatenate((a, b)) if not poly1.intersects(poly2): # if there is no intersection between two polygons iou = 0 else: inter_area = poly1.intersection(poly2).area # intersection area print(inter_area) union_area = MultiPoint(union_poly).convex_hull.area print(union_area) if union_area == 0: iou = 0 iou = float(inter_area) / union_area return iou def nms_rotated_rect(dets, scores, thresh): obbs = dets[:, 0:-1] x1 = np.min(obbs[:, 0::2], axis=1) y1 = np.min(obbs[:, 1::2], axis=1) x2 = np.max(obbs[:, 0::2], axis=1) y2 = np.max(obbs[:, 1::2], axis=1) areas = (x2 - x1 + 1) * (y2 - y1 + 1) polys = [] for i in range(len(dets)): tm_polygon = [dets[i][0], dets[i][1], dets[i][2], dets[i][3], dets[i][4], dets[i][5], dets[i][6], dets[i][7]] polys.append(tm_polygon) order = scores.argsort()[::-1] keep = [] while order.size &gt; 0: i = order[0] keep.append(i) xx1 = np.maximum(x1[i], x1[order[1:]]) yy1 = np.maximum(y1[i], y1[order[1:]]) xx2 = np.minimum(x2[i], x2[order[1:]]) yy2 = np.minimum(y2[i], y2[order[1:]]) w = np.maximum(0.0, xx2 - xx1) h = np.maximum(0.0, yy2 - yy1) hbb_inter = w * h hbb_ovr = hbb_inter / (areas[i] + areas[order[1:]] - hbb_inter) h_inds = np.where(hbb_ovr &gt; 0)[0] tmp_order = order[h_inds + 1] for j in range(tmp_order.size): iou = iou_rotated_rect(polys[i], polys[tmp_order[j]]) hbb_ovr[h_inds[j]] = iou inds = np.where(hbb_ovr &lt;= thresh)[0] order = order[inds + 1] return keep 然后去掉原工程下detect.py中数据后处理部分对DOTA_devkit工具包的依赖 def rotate_non_max_suppression(...): ... # 源码如下： # i = np.array(py_cpu_nms_poly_fast(np.array(rects), np.array(scores.cpu()), iou_thres)) # 修改如下： i = np.array(nms_rotated_rect(np.array(rects), np.array(scores.cpu()), iou_thres)) ... 修改完毕，用“纯净版”的YOLOv5_DOTA_OBB跑一下demo，发现模型可以正常预测，性能好像也没有损失 然后开始制作自己的数据集，训练并测试，这里我用的是以前用过的标注工具labelimg2 不过输出的格式是voc格式，所以我修改了下源码，让它能生成DOTA数据集格式的标签，在原工程的libs/labelFile.py里添加如下代码，会在当前目录下生成一个labels文件夹，里面存放对应标注图片的DOTA格式标签 label_dir = os.path.join(imgFolderPath, &quot;labels&quot;) if not os.path.exists(label_dir): os.makedirs(label_dir) label_file = os.path.join(label_dir, os.path.splitext(imgFileName)[0] + &#39;.txt&#39;) with open(label_file, &#39;w&#39;) as l: for shape in shapes: points = shape[&#39;points&#39;] label = shape[&#39;label&#39;] l.write(&#39; &#39;.join([str(points[0][0]), str(points[0][1]), str(points[1][0]), str(points[1][1]), str(points[2][0]), str(points[2][1]), str(points[3][0]), str(points[3][1]), label]) + &#39;\\n&#39;) 这里调用我自己修改的脚本，参考原项目，可以设置一下每张图片（标注好的）的增强次数，以及各类数据增强方法的参数 接着根据原作者提供的工具，将带DOTA格式标签的数据转换为“长边表示法”格式的标签数据，对应的格式转换代码如下 def dota2LongSideFormat(imgpath, txtpath, dstpath, extractclassname): if os.path.exists(dstpath): shutil.rmtree(dstpath) # delete output folder os.makedirs(dstpath) # make new output folder filelist = GetFileFromThisRootDir(txtpath) # fileist=[&#39;/.../P0005.txt&#39;, ..., /.../P000?.txt] for fullname in filelist: # fullname=&#39;/.../P000?.txt&#39; objects = parse_dota_poly(fullname) name = os.path.splitext(os.path.basename(fullname))[0] # name=&#39;P000?&#39; img_fullname = os.path.join(imgpath, name + &#39;.jpg&#39;) # img_fullname=&#39;/.../P000?.png&#39; img = Image.open(img_fullname) img_w, img_h = img.size # print img_w,img_h with open(os.path.join(dstpath, name + &#39;.txt&#39;), &#39;w&#39;) as f_out: num_gt = 0 for i, obj in enumerate(objects): num_gt = num_gt + 1 # 为当前有效gt计数 poly = obj[&#39;poly&#39;] # poly=[(x1,y1),(x2,y2),(x3,y3),(x4,y4)] poly = np.float32(np.array(poly)) # 四点坐标归一化 poly[:, 0] = poly[:, 0] / img_w poly[:, 1] = poly[:, 1] / img_h rect = cv2.minAreaRect(poly) # 得到最小外接矩形的（中心(x,y), (宽,高), 旋转角度） c_x = rect[0][0] c_y = rect[0][1] w = rect[1][0] h = rect[1][1] theta = rect[-1] # Range for angle is [-90，0) trans_data = cvminAreaRect2longsideformat(c_x, c_y, w, h, theta) if not trans_data: if theta != 90: # Θ=90说明wh中有为0的元素，即gt信息不完整，无需提示异常，直接删除 print(&#39;opencv表示法转长边表示法出现异常,已将第%d个box排除,问题出现在该图片中:%s&#39; % (i, img_fullname)) num_gt = num_gt - 1 continue else: # range:[-180，0) c_x, c_y, longside, shortside, theta_longside = trans_data bbox = np.array((c_x, c_y, longside, shortside)) if (sum(bbox &lt;= 0) + sum(bbox[:2] &gt;= 1)) &gt;= 1: # 0&lt;xy&lt;1, 0&lt;side&lt;=1 print(&#39;bbox[:2]中有&gt;= 1的元素,bbox中有&lt;= 0的元素,已将第%d个box排除,问题出现在该图片中:%s&#39; % (i, img_fullname)) print(&#39;出问题的longside形式数据:[%.16f, %.16f, %.16f, %.16f, %.1f]&#39; % ( c_x, c_y, longside, shortside, theta_longside)) num_gt = num_gt - 1 continue if (obj[&#39;name&#39;] in extractclassname): id = extractclassname.index(obj[&#39;name&#39;]) # id=类名的索引 比如&#39;plane&#39;对应id=0 else: print(&#39;预定类别中没有类别:%s;已将该box排除,问题出现在该图片中:%s&#39; % (obj[&#39;name&#39;], fullname)) num_gt = num_gt - 1 continue theta_label = int(theta_longside + 180.5) # range int[0,180] 四舍五入 if theta_label == 180: # range int[0,179] theta_label = 179 # outline=&#39;id x y longside shortside Θ&#39; # final check if id &gt; 15 or id &lt; 0: print(&#39;id problems,问题出现在该图片中:%s&#39; % (i, img_fullname)) print(&#39;出问题的longside形式数据:[%.16f, %.16f, %.16f, %.16f, %.1f]&#39; % ( c_x, c_y, longside, shortside, theta_longside)) if theta_label &lt; 0 or theta_label &gt; 179: print(&#39;id problems,问题出现在该图片中:%s&#39; % (i, img_fullname)) print(&#39;出问题的longside形式数据:[%.16f, %.16f, %.16f, %.16f, %.1f]&#39; % ( c_x, c_y, longside, shortside, theta_longside)) outline = str(id) + &#39; &#39; + &#39; &#39;.join(list(map(str, bbox))) + &#39; &#39; + str(theta_label) f_out.write(outline + &#39;\\n&#39;) # 写入txt文件中并加上换行符号 \\n if num_gt == 0: os.remove(os.path.join(dstpath, name + &#39;.txt&#39;)) # os.remove(img_fullname) os.remove(fullname) print(&#39;%s 图片对应的txt不存在有效目标,已删除对应图片与txt&#39; % img_fullname) print(&#39;已完成文件夹内DOTA数据形式到长边表示法的转换&#39;) def cvminAreaRect2longsideformat(x_c, y_c, width, height, theta): if theta == 0: theta = -90 buffer_width = width width = height height = buffer_width if theta &gt; 0: if theta != 90: # Θ=90说明wh中有为0的元素，即gt信息不完整，无需提示异常，直接删除 print(&#39;θ计算出现异常，当前数据为：%.16f, %.16f, %.16f, %.16f, %.1f;超出opencv表示法的范围：[-90,0)&#39; % ( x_c, y_c, width, height, theta)) return False if theta &lt; -90: print( &#39;θ计算出现异常，当前数据为：%.16f, %.16f, %.16f, %.16f, %.1f;超出opencv表示法的范围：[-90,0)&#39; % (x_c, y_c, width, height, theta)) return False if width != max(width, height): # 若width不是最长边 longside = height shortside = width theta_longside = theta - 90 else: # 若width是最长边(包括正方形的情况) longside = width shortside = height theta_longside = theta if longside &lt; shortside: print(&#39;旋转框转换表示形式后出现问题：最长边小于短边;[%.16f, %.16f, %.16f, %.16f, %.1f]&#39; % ( x_c, y_c, longside, shortside, theta_longside)) return False if (theta_longside &lt; -180 or theta_longside &gt;= 0): print(&#39;旋转框转换表示形式时出现问题:θ超出长边表示法的范围：[-180,0);[%.16f, %.16f, %.16f, %.16f, %.1f]&#39; % ( x_c, y_c, longside, shortside, theta_longside)) return False return x_c, y_c, longside, shortside, theta_longside 有了数据集，接下来就是训练调参了，一开始训练采用的原作者的默认配置，后来loss就是降不下来，测试效果也就肉眼可见的差，翻了翻评论区，结合自己的一点点对超参数的理解，修改hyp_scratch.yaml文件中各部分loss的权重，以及根据评论区原作者建议，调低了mosaic数据增强的启用概率，然后象征性地打开了mixup数据增强 由于原作者使用“长边表示法”表示旋转矩形框的算法具有局限性，标签在高版本opencv上无法成功从DOTA格式转换为longsideformat格式，宽高不等的图片无法作为数据正常送入网络进行训练，这是由于作者是先对图像宽高进行归一化之后再转换标签格式，然后在longsideformat格式下进行图片像素坐标的去归一化（会导致标签由旋转矩形框变成类平行四边形框），有一个好的解决方案是对图片归一化时，宽高都针对两者中的较大值作为归一化的分母做归一化，这样转换标签格式后，图片像素坐标去归一化的分母还是一样的，不会产生标签偏移，最好的解决办法是修改标签转换部分代码以及整个深度学习工程的像素坐标归一化与去归一化过程，但是这样修改起来工作量较大，且可行性得不到验证，因此目前仍建议采用宽高相等的图片作为训练数据 如果数据增强的时候，开启了多种增强方式（如旋转，平移，裁剪），建议训练的时候，将角度、box和置信度的loss权重调高，若不是做多分类，分类部分的loss权重可以调低，生成的训练数据集比较复杂的情况下，mosaic和mixup数据增强方式的启用概率可以适当调低，并且为了保证网络收敛，建议调高epochs，并且采用Adam优化算法 忙活了半天，终于训练出来一个还不错的效果了 640*640的图片，gpu单张预测时间在0.1s左右","categories":[{"name":"技术","slug":"技术","permalink":"http://goodguyjameswin.github.io/categories/技术/"}],"tags":[{"name":"开源项目","slug":"开源项目","permalink":"http://goodguyjameswin.github.io/tags/开源项目/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://goodguyjameswin.github.io/categories/技术/"}]},{"title":"yolact","slug":"yolact","date":"2021-10-07T03:34:57.000Z","updated":"2021-10-10T13:34:20.468Z","comments":false,"path":"2021/10/07/yolact/","link":"","permalink":"http://goodguyjameswin.github.io/2021/10/07/yolact/","excerpt":"","text":"简介奉老师之命，调试一个实例分割的网络，用来做缺陷检测，至于为什么用实例分割网络做缺陷检测，我也不清楚，反正他老人家的意思是要能够在c++那头部署，好让人家写界面封装。话不多说，开始做数据！ 踩坑挖坑盯上了一个可以用ncnn部署的实例分割网络yolact，先考虑能否使用opencv的dnn库进行网络的部署，参考项目，使用official版yolact工程里自带的训练.pth权重，先转换成.onnx格式。这里有一个坑，貌似低版本的opencv，会报错，安装高版本（如opencv4.5）可以解决权重转换报错。其次就是，训练时使用的pytorch，一定要和.pth权重文件转.onnx格式时使用的pytorch版本对应 然后在c++端进行推理，发现可以成功，300*300的demo图片cpu推理时间在700ms左右，坚定了调试yolact工程的决心 然后去踩yolact网络训练测试的坑，发现同样是opencv版本低带来的坑，读训练图片的时候会报错，升级一下opencv版本就好了 用labelme工具标注图片分割数据，产生的json格式标签，同样的用脚本扩充一下数据集，验证一下标签转换是否正确 然后把标注并且增广后的数据及json格式标签，转换为COCO格式数据集 def main(): parser = argparse.ArgumentParser( formatter_class=argparse.ArgumentDefaultsHelpFormatter ) parser.add_argument(&quot;input_dir&quot;, help=&quot;input annotated directory&quot;) parser.add_argument(&quot;output_dir&quot;, help=&quot;output dataset directory&quot;) parser.add_argument(&quot;--labels&quot;, help=&quot;labels file&quot;, required=True) parser.add_argument( &quot;--noviz&quot;, help=&quot;no visualization&quot;, action=&quot;store_true&quot; ) args = parser.parse_args() if osp.exists(args.output_dir): print(&quot;Output directory already exists:&quot;, args.output_dir) sys.exit(1) os.makedirs(args.output_dir) os.makedirs(osp.join(args.output_dir, os.path.basename(args.input_dir) + &quot;_JPEGImages&quot;)) if not args.noviz: os.makedirs(osp.join(args.output_dir, &quot;Visualization&quot;)) print(&quot;Creating dataset:&quot;, args.output_dir) now = datetime.datetime.now() data = dict( info=dict( description=None, url=None, version=None, year=now.year, contributor=None, date_created=now.strftime(&quot;%Y-%m-%d %H:%M:%S.%f&quot;), ), licenses=[dict(url=None, id=0, name=None,)], images=[ # license, url, file_name, height, width, date_captured, id ], type=&quot;instances&quot;, annotations=[ # segmentation, area, iscrowd, image_id, bbox, category_id, id ], categories=[ # supercategory, id, name ], ) class_name_to_id = {} for i, line in enumerate(open(args.labels).readlines()): class_id = i - 1 # starts with -1 class_name = line.strip() if class_id == -1: assert class_name == &quot;__ignore__&quot; continue class_name_to_id[class_name] = class_id data[&quot;categories&quot;].append( dict(supercategory=None, id=class_id, name=class_name,) ) out_ann_file = osp.join(args.output_dir, os.path.basename(args.input_dir) + &quot;.json&quot;) label_files = glob.glob(osp.join(args.input_dir, &quot;*.json&quot;)) for image_id, filename in enumerate(label_files): print(&quot;Generating dataset from:&quot;, filename) label_file = labelme.LabelFile(filename=filename) base = osp.splitext(osp.basename(filename))[0] out_img_file = osp.join(args.output_dir, os.path.basename(args.input_dir) + &quot;_JPEGImages&quot;, base + &quot;.jpg&quot;) img = labelme.utils.img_data_to_arr(label_file.imageData) imgviz.io.imsave(out_img_file, img) data[&quot;images&quot;].append( dict( license=0, url=None, file_name=osp.relpath(out_img_file, osp.dirname(out_ann_file)), height=img.shape[0], width=img.shape[1], date_captured=None, id=image_id, ) ) masks = {} # for area segmentations = collections.defaultdict(list) # for segmentation for shape in label_file.shapes: points = shape[&quot;points&quot;] label = shape[&quot;label&quot;] group_id = shape.get(&quot;group_id&quot;) shape_type = shape.get(&quot;shape_type&quot;, &quot;polygon&quot;) mask = labelme.utils.shape_to_mask( img.shape[:2], points, shape_type ) if group_id is None: group_id = uuid.uuid1() instance = (label, group_id) if instance in masks: masks[instance] = masks[instance] | mask else: masks[instance] = mask if shape_type == &quot;rectangle&quot;: (x1, y1), (x2, y2) = points x1, x2 = sorted([x1, x2]) y1, y2 = sorted([y1, y2]) points = [x1, y1, x2, y1, x2, y2, x1, y2] else: points = np.asarray(points).flatten().tolist() segmentations[instance].append(points) segmentations = dict(segmentations) for instance, mask in masks.items(): cls_name, group_id = instance if cls_name not in class_name_to_id: continue cls_id = class_name_to_id[cls_name] mask = np.asfortranarray(mask.astype(np.uint8)) mask = pycocotools.mask.encode(mask) area = float(pycocotools.mask.area(mask)) bbox = pycocotools.mask.toBbox(mask).flatten().tolist() data[&quot;annotations&quot;].append( dict( id=len(data[&quot;annotations&quot;]), image_id=image_id, category_id=cls_id, segmentation=segmentations[instance], area=area, bbox=bbox, iscrowd=0, ) ) if not args.noviz: labels, captions, masks = zip( *[ (class_name_to_id[cnm], cnm, msk) for (cnm, gid), msk in masks.items() if cnm in class_name_to_id ] ) viz = imgviz.instances2rgb( image=img, labels=labels, masks=masks, captions=captions, font_size=15, line_width=2, ) out_viz_file = osp.join( args.output_dir, &quot;Visualization&quot;, base + &quot;.jpg&quot; ) imgviz.io.imsave(out_viz_file, viz) with open(out_ann_file, &quot;w&quot;) as f: json.dump(data, f) 简单配置训练信息，开始训练！ 训练完毕，先在python这边测试一下效果，马马虎虎 然后关键是，能否在c++端部署并成功预测，这里又有一个坑，如果是训练自己的数据集，得到的.pth权重文件在转换.onnx文件时，需要保证网络结构部分读取张量的尺寸能对齐（一般来说是图片尺寸通道数或者训练测试类别数的不一致会导致报错） 训练的模型也比较简单，看了下中间过程的mask图，这边生成的分割图还是不够准确，对模型的训练效果要求还是比较高，貌似效果和python那边预测的有点差距，初步估计是网络前向推理后的数据后处理部分还是有区别吧，留个坑，以后有时间再填~","categories":[{"name":"技术","slug":"技术","permalink":"http://goodguyjameswin.github.io/categories/技术/"}],"tags":[{"name":"开源项目","slug":"开源项目","permalink":"http://goodguyjameswin.github.io/tags/开源项目/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://goodguyjameswin.github.io/categories/技术/"}]},{"title":"PaddleOCR","slug":"PaddleOcr","date":"2021-10-07T02:20:57.000Z","updated":"2022-06-04T13:45:14.262Z","comments":false,"path":"2021/10/07/PaddleOcr/","link":"","permalink":"http://goodguyjameswin.github.io/2021/10/07/PaddleOcr/","excerpt":"","text":"简介由于项目需求，直接调用PaddleOCR官方训练好的中英文通用检测识别权重，把检测字符和识别串联的代码结构合并了一下，然后修改了分行的判别机制 原项目 修改前： 修改后： cpu串联推理结合mkldnn设置，速度大概提升了30%","categories":[{"name":"技术","slug":"技术","permalink":"http://goodguyjameswin.github.io/categories/技术/"}],"tags":[{"name":"开源项目","slug":"开源项目","permalink":"http://goodguyjameswin.github.io/tags/开源项目/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://goodguyjameswin.github.io/categories/技术/"}]},{"title":"data-augtools","slug":"data-augtools","date":"2021-09-26T07:14:03.000Z","updated":"2021-10-16T07:28:16.732Z","comments":false,"path":"2021/09/26/data-augtools/","link":"","permalink":"http://goodguyjameswin.github.io/2021/09/26/data-augtools/","excerpt":"","text":"简介在原项目的基础上，添加了针对标注工具labelimg2的数据增强 在labelme的数据增强部分添加了旋转和裁剪处理，并做了标签增强 修改后","categories":[{"name":"技术","slug":"技术","permalink":"http://goodguyjameswin.github.io/categories/技术/"}],"tags":[{"name":"开源项目","slug":"开源项目","permalink":"http://goodguyjameswin.github.io/tags/开源项目/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://goodguyjameswin.github.io/categories/技术/"}]},{"title":"text_generator","slug":"text-generator","date":"2021-09-22T04:37:14.000Z","updated":"2022-06-04T13:45:12.820Z","comments":false,"path":"2021/09/22/text-generator/","link":"","permalink":"http://goodguyjameswin.github.io/2021/09/22/text-generator/","excerpt":"","text":"引言用pillow的ImageFont模块去生成可供ocr模型训练的文本检测和识别训练数据，原项目暂时没找到。。 修改引入背景roi 就像上面这张图，有时候场景文本检测和识别任务中，文字只会出现在场景图片特定的语义区域中。因此在制作文本数据时，就需要限定文本出现的范围 调用opencv-python里的api： import cv2 class UseCv: def __init__(self): self.path = &#39;bg.jpg&#39; def cut(self): img = cv2.imread(self.path, flags=cv2.IMREAD_COLOR) bbox = cv2.selectROI(img, False) cut = img[bbox[1]:bbox[1] + bbox[3], bbox[0]:bbox[0] + bbox[2]] cv2.imwrite(&#39;bg_cut.jpg&#39;, cut) 更改： self.roi = cv2.selectROI(cv2.imread(self.bg, 1), False) if x + w &gt; (self.roi[0] + self.roi[2] - 10) or y + h &gt; (self.roi[1]+ self.roi[3] - 10): return draw, (w, h), False tl_x = random.randrange(self.roi[0], self.roi[0] + self.roi[2]) # 字体位置 tl_y = random.randrange(self.roi[1], self.roi[1] + self.roi[3]) 使用命令行调用生成语料： 9CHCAV1 6TXYQ WNVKWX 9OMKKCM5Y X4EPT1J- 9ZG4GB HUTTQRF KDB6TFFP 1ZNKT45E ULR26VPJE 选择roi 运行 结果","categories":[{"name":"技术","slug":"技术","permalink":"http://goodguyjameswin.github.io/categories/技术/"}],"tags":[{"name":"开源项目","slug":"开源项目","permalink":"http://goodguyjameswin.github.io/tags/开源项目/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://goodguyjameswin.github.io/categories/技术/"}]},{"title":"shape_based_matching","slug":"shape_based_matching","date":"2021-09-15T02:13:12.000Z","updated":"2021-10-10T12:31:17.306Z","comments":false,"path":"2021/09/15/shape_based_matching/","link":"","permalink":"http://goodguyjameswin.github.io/2021/09/15/shape_based_matching/","excerpt":"","text":"环境配置新建VS空工程，然后在VS-视图-属性管理器，配置opencv环境，VC++目录-包含目录添加： ..\\opencv\\build\\include ..\\opencv\\build\\include\\opencv ..\\opencv\\build\\include\\opencv2 VC++目录-库目录添加： ..\\opencv\\build\\x64\\vc15\\lib 链接器-输入-附加依赖项添加： opencv_world346d.lib 将原工程根目录下的源文件和头文件添加到新建VS工程里，修改fusion.h和line2Dup.h文件里的路径： #include &quot;MIPP/mipp.h&quot; // for SIMD in different platforms 修改test.cpp里的prefix变量路径，指向资源文件： static std::string prefix = &quot;../test/&quot;; api调用原作者分别对模板做了角度、尺度方面的测试，以及noise_test（NMS筛选）。这里假设模板是工业器件，且由于拍摄角度和器件摆放位置的随机性，需要简单写个my_test函数来调用api void my_test(string mode = &quot;test&quot;, bool use_rot = true) { int num_feature = 16; // 特征点数量 line2Dup::Detector detector(num_feature, { 4, 8 }); if (mode != &quot;test&quot;) { Mat img = imread(prefix + &quot;case3/train.jpg&quot;); // 训练图片 assert(!img.empty() &amp;&amp; &quot;check your img path&quot;); // crop the template from the original train image Rect roi(90, 35, 65, 35); img = img(roi).clone(); Mat mask = Mat(img.size(), CV_8UC1, { 255 }); // padding to avoid rotating out int padding = 25; cv::Mat padded_img = cv::Mat(img.rows + 2 * padding, img.cols + 2 * padding, img.type(), cv::Scalar::all(0)); img.copyTo(padded_img(Rect(padding, padding, img.cols, img.rows))); cv::Mat padded_mask = cv::Mat(mask.rows + 2 * padding, mask.cols + 2 * padding, mask.type(), cv::Scalar::all(0)); mask.copyTo(padded_mask(Rect(padding, padding, img.cols, img.rows))); shape_based_matching::shapeInfo_producer shapes(padded_img, padded_mask); shapes.angle_range = { 0, 360 }; // 模板库尺度范围 shapes.angle_step = 1; // 模板库尺度步长 shapes.scale_range = { 0.5f, 1.5f }; // 模板库角度范围 shapes.scale_step = 0.1f; // 模板库角度步长 //shapes.scale_range = { 1.0f }; shapes.produce_infos(); std::vector&lt;shape_based_matching::shapeInfo_producer::Info&gt; infos_have_templ; string class_id = &quot;gongjian&quot;; // 模板类名 bool is_first = true; // for other scales you want to re-extract points: // set shapes.scale_range then produce_infos; set is_first = false; int first_id = 0; float first_angle = 0; float first_scale = 0; for (auto&amp; info : shapes.infos) { Mat to_show = shapes.src_of(info); /********************/ // 通用场景 std::cout &lt;&lt; &quot;\\ninfo.angle: &quot; &lt;&lt; info.angle &lt;&lt; std::endl; int templ_id = detector.addTemplate(shapes.src_of(info), class_id, shapes.mask_of(info), int(num_feature * info.scale)); // todo: 模板图尺度没有变化的场景 //（第一次需要成功记录模板，尽量保证模板完整，轮廓层次分明） //（如果报错数组越界，先尝试改善模板图片质量，不行再尝试调小num_feature的值，但建议至少为8） /*std::cout &lt;&lt; &quot;\\ninfo.angle: &quot; &lt;&lt; info.angle &lt;&lt; std::endl; int templ_id; if (is_first) { templ_id = detector.addTemplate(shapes.src_of(info), class_id, shapes.mask_of(info), int(num_feature * info.scale)); first_id = templ_id; first_angle = info.angle; first_scale = info.scale; if (use_rot) is_first = false; } else { templ_id = detector.addTemplate_rotate(class_id, first_id, info.angle - first_angle, { shapes.src.cols / 2.0f, shapes.src.rows / 2.0f }); }*/ /********************/ std::cout &lt;&lt; &quot;templ_id: &quot; &lt;&lt; templ_id &lt;&lt; std::endl; if (templ_id != -1) { auto templ = detector.getTemplates(&quot;gongjian&quot;, templ_id); for (int i = 0; i &lt; templ[0].features.size(); i++) { auto feat = templ[0].features[i]; cv::circle(to_show, { feat.x + templ[0].tl_x, feat.y + templ[0].tl_y }, 3, { 0, 0, 255 }, -1); } infos_have_templ.push_back(info); // will be faster if not showing this imshow(&quot;train&quot;, to_show); waitKey(1); } if (fabs(info.scale - first_scale) &gt; 0.002f) { is_first = true; std::cout &lt;&lt; &quot;info_scale: &quot; &lt;&lt; info.scale &lt;&lt; std::endl; } } detector.writeClasses(prefix + &quot;case3/%s_templ.yaml&quot;); // 模板库 shapes.save_infos(infos_have_templ, prefix + &quot;case3/gongjian_info.yaml&quot;); // 模板信息 std::cout &lt;&lt; &quot;train end&quot; &lt;&lt; std::endl &lt;&lt; std::endl; } else if (mode == &quot;test&quot;) { std::vector&lt;std::string&gt; ids; ids.push_back(&quot;gongjian&quot;); detector.readClasses(ids, prefix + &quot;case3/%s_templ.yaml&quot;); // angle &amp; scale are saved here, fetched by match id auto infos = shape_based_matching::shapeInfo_producer::load_infos(prefix + &quot;case3/gongjian_info.yaml&quot;); Mat test_img = imread(prefix + &quot;case3/ori.jpg&quot;); // 测试图片 assert(!test_img.empty() &amp;&amp; &quot;check your img path&quot;); // padding to avoid rotating out int padding = 150; cv::Mat padded_img = cv::Mat(test_img.rows + 2 * padding, test_img.cols + 2 * padding, test_img.type(), cv::Scalar::all(0)); test_img.copyTo(padded_img(Rect(padding, padding, test_img.cols, test_img.rows))); int stride = 32; int n = padded_img.rows / stride; int m = padded_img.cols / stride; Rect roi(0, 0, stride * m, stride * n); Mat img = padded_img(roi).clone(); assert(img.isContinuous()); // cvtColor(img, img, CV_BGR2GRAY); // todo:训练模板用灰度图，测试图片也用灰度图，然后观察推理速度和效果 std::cout &lt;&lt; &quot;test img size: &quot; &lt;&lt; img.rows * img.cols &lt;&lt; std::endl &lt;&lt; std::endl; // check time span auto start_time = GetTickCount(); //Timer timer; auto matches = detector.match(img, 90, ids); // 匹配阈值 //timer.out(); std::cout &lt;&lt; &quot;matches.size(): &quot; &lt;&lt; matches.size() &lt;&lt; std::endl; vector&lt;Rect&gt; boxes; vector&lt;float&gt; scores; vector&lt;int&gt; idxs; for (auto match : matches) { Rect box; box.x = match.x; box.y = match.y; auto templ = detector.getTemplates(&quot;gongjian&quot;, match.template_id); box.width = templ[0].width; box.height = templ[0].height; boxes.push_back(box); scores.push_back(match.similarity); } cv_dnn::NMSBoxes(boxes, scores, 90, 0, idxs); // 筛选阈值 auto end_time = GetTickCount(); cout &lt;&lt; &quot;匹配算法耗时：&quot; &lt;&lt; (end_time - start_time) &lt;&lt; &quot;ms.&quot; &lt;&lt; endl; if (img.channels() == 1) cvtColor(img, img, CV_GRAY2BGR); for (auto idx : idxs) { auto match = matches[idx]; /*size_t top5 = 10; if (top5 &gt; matches.size()) top5 = matches.size(); for (size_t i = 0; i &lt; top5; i++) { auto match = matches[i];*/ auto templ = detector.getTemplates(&quot;gongjian&quot;, // 读取训练好的模板类 match.template_id); // 65 is width of template image, 35 is height of template image // 25 is padding when training // tl_x/y: template croping topleft corner when training float x_scaled = 60 / 2.0f * infos[match.template_id].scale; float y_scaled = 35 / 2.0f * infos[match.template_id].scale; // scaling won&#39;t affect this, because it has been determined by warpAffine // cv::warpAffine(src, dst, rot_mat, src.size()); last param float train_img_half_width = 60 / 2.0f + 25; float train_img_half_height = 35 / 2.0f + 25; // center x,y of train_img in test img float x = match.x - templ[0].tl_x + train_img_half_width; float y = match.y - templ[0].tl_y + train_img_half_height; cv::Vec3b randColor; randColor[0] = rand() % 155 + 100; randColor[1] = rand() % 155 + 100; randColor[2] = rand() % 155 + 100; for (int i = 0; i &lt; templ[0].features.size(); i++) { auto feat = templ[0].features[i]; cv::circle(img, { feat.x + match.x, feat.y + match.y }, 3, randColor, -1); } cv::putText(img, to_string(int(round(match.similarity))), Point(match.x + x_scaled - 10, match.y - 3), FONT_HERSHEY_PLAIN, 2, randColor); cv::RotatedRect rotatedRectangle({ x, y }, { 2 * x_scaled, 2 * y_scaled }, -infos[match.template_id].angle); cv::Point2f vertices[4]; rotatedRectangle.points(vertices); for (int i = 0; i &lt; 4; i++) { int next = (i + 1 == 4) ? 0 : (i + 1); cv::line(img, vertices[i], vertices[next], randColor, 2); } std::cout &lt;&lt; &quot;\\nmatch.template_id: &quot; &lt;&lt; match.template_id &lt;&lt; std::endl; std::cout &lt;&lt; &quot;match.similarity: &quot; &lt;&lt; match.similarity &lt;&lt; std::endl; } imshow(&quot;img&quot;, img); waitKey(0); std::cout &lt;&lt; &quot;test end&quot; &lt;&lt; std::endl &lt;&lt; std::endl; } } 效果训练 测试","categories":[{"name":"技术","slug":"技术","permalink":"http://goodguyjameswin.github.io/categories/技术/"}],"tags":[{"name":"开源项目","slug":"开源项目","permalink":"http://goodguyjameswin.github.io/tags/开源项目/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://goodguyjameswin.github.io/categories/技术/"}]},{"title":"yolo_icdar","slug":"yolo_icdar","date":"2021-09-06T12:30:01.000Z","updated":"2022-06-04T13:45:11.056Z","comments":false,"path":"2021/09/06/yolo_icdar/","link":"","permalink":"http://goodguyjameswin.github.io/2021/09/06/yolo_icdar/","excerpt":"","text":"引言第一篇文章（水文）！研一参与的第一个项目，用yolo来检测（识别）图片中的喷码字符（生产日期），然后很长一段时间都在给数据打标签 问题在于用yolo去做逐字符的检测，输出的框顺序并不像我们所认知的那样，分行排列，从上至下，从左至右 yolo格式标签&lt;object-class&gt; &lt;x&gt; &lt;y&gt; &lt;width&gt; &lt;height&gt; x，y是检测框的中心坐标；width，height是检测框的宽和高。这些坐标是通过归一化的，其中x，width是使用原图的width进行归一化；而y，height是使用原图的height进行归一化 icdar格式标签path/to/img [{&quot;transcription&quot;: &quot;content&quot;, &quot;points&quot;: [[x1, y1], [x2, y2], [x3, y3], [x4, y4]]}, {...}] 标签是包含多个字典的list，字典中的 points 表示文本框的四个点的坐标(x, y)，从左上角的点开始顺时针排列。 transcription 表示当前文本框的内容 实现把问题转换为对yolo输出检测框的排序。已知量是每个检测框的横、纵坐标，思路是先把所有检测框按纵坐标分成不同行，每行再按横坐标排序 原先的项目数据里，待识别的图片样式基本不变，可以直接在界面里设置每行文本的字符个数，当时的代码就是直接根据这一条件来对检测框排序。然后就检测条形码和二维码去了 后来项目的数据样式变多了，感觉原来的方法行不通了，最近在用paddleocr做文本识别，需要把以前训练yolo的一些数据标签转成icdar格式，所以又要重新面对这个yolo检测框的排序问题，那就趁着这个机会把代码写清楚 自然断点法a = np.array([5, 35, 38, 41, 65, 68, 98, 99, 100, 99, 105, 106, 102, 104, 103, 100, 110, 69, 64, 70, 75, 71, 73, 72, 42, 46, 40, 36, 37, 6, 8, 11, 4, 15, 10, 9, 4, 8, 135]) 思路还是先把检测框按纵坐标分行，想了半天，放弃 后来在pycharm里边写代码边debug，发现对数组View as Array的时候有个Colored cells选项，可以把一维数组分块，联想到yolo检测框按纵坐标分行，然后上网去搜有没有一维数组的聚类方法 发现可以用python的机器学习算法库里一个叫核密度估计的方法，实现对多维数据分布规律的曲线模拟。那把一维数组扩充到多维不就好了？（大材小用），搜了下这个库的调用方法 a = np.array([5, 35, 38, 41, 65, 68, 98, 99, 100, 99, 105, 106, 102, 104, 103, 100, 110, 69, 64, 70, 75, 71, 73, 72, 42, 46, 40, 36, 37, 6, 8, 11, 4, 15, 10, 9, 4, 8, 135]).reshape(-1, 1) kde = KernelDensity(kernel=&#39;gaussian&#39;, bandwidth=3).fit(a[:, 0].reshape(-1, 1)) # 构造指定数据的核密度估计 s = np.linspace(0, 140) e = kde.score_samples(s.reshape(-1, 1)) # 在特定数据上用核函数拟合 观察了下拟合出来的曲线，确实求个极值就可以找到断点了 mi, ma = argrelextrema(e, np.less)[0], argrelextrema(e, np.greater)[0] # 计算数组指定轴的相对极值 Minima: [25.71428571 54.28571429 85.71428571 122.85714286] Maxima: [8.57142857 37.14285714 71.42857143 100. 134.28571429] 然后根据断点把一维数组分块，还行 [5 6 8 11 4 15 10 9 4 8] [35 38 41 42 46 40 36 37] [65 68 69 64 70 75 71 73 72] [98 99 100 99 105 106 102 104 103 100 110] [135] 后话最后整合到标签转换脚本里去，转换速度还行。。吧 这样就可以用上学长的data_maker了哈哈哈 虽然我个人倾向于用python的pillow库函数ImageFont来制作字符数据，但是喷码样式的字体文件着实不好搞，字符贴图的背景区域定位那块代码也一直想吐槽，之后抽个时间优化下吧，顺便再水一篇文章","categories":[{"name":"技术","slug":"技术","permalink":"http://goodguyjameswin.github.io/categories/技术/"}],"tags":[{"name":"开源项目","slug":"开源项目","permalink":"http://goodguyjameswin.github.io/tags/开源项目/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://goodguyjameswin.github.io/categories/技术/"}]}]}