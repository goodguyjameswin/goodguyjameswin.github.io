{"meta":{"title":"zt's blog","subtitle":null,"description":"没有记流水帐的习惯~","author":"Terry Joe","url":"http://goodguyjameswin.github.io"},"pages":[{"title":"","date":"2021-09-02T07:22:26.499Z","updated":"2021-09-02T07:21:51.283Z","comments":true,"path":"404.html","permalink":"http://goodguyjameswin.github.io/404.html","excerpt":"","text":"页面没有找到 | zt's Blog body { background: #00c4b6; } #not_found { position: fixed; top: 50%; left: 50%; transform: translateY(-50%) translateX(-50%) scale(1.2); width: 80%; height: auto; } (function () { var lastTime = 0; var vendors = ['ms', 'moz', 'webkit', 'o']; for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) { window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame']; window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] || window[vendors[x] + 'CancelRequestAnimationFrame']; } if (!window.requestAnimationFrame) window.requestAnimationFrame = function (callback, element) { var currTime = new Date().getTime(); var timeToCall = Math.max(0, 16 - (currTime - lastTime)); var id = window.setTimeout(function () { callback(currTime + timeToCall); }, timeToCall); lastTime = currTime + timeToCall; return id; }; if (!window.cancelAnimationFrame) window.cancelAnimationFrame = function (id) { clearTimeout(id); }; })(); //math2 utils var Math2 = {}; Math2.random = function (t, n) { return Math.random() * (n - t) + t; }, Math2.map = function (t, n, r, a, o) { return (o - a) * ((t - n) / (r - n)) + a; }, Math2.randomPlusMinus = function (t) { return t = t ? t : .5, Math.random() > t ? -1 : 1; }, Math2.randomInt = function (t, n) { return n += 1, Math.floor(Math.random() * (n - t) + t); }, Math2.randomBool = function (t) { return t = t ? t : .5, Math.random() < t ? !0 : !1; }, Math2.degToRad = function (t) { return rad = t * Math.PI / 180, rad; }, Math2.radToDeg = function (t) { return deg = 180 / (Math.PI * t), deg; }, Math2.rgbToHex = function (t) { function n(t) { return (\"0\" + parseInt(t).toString(16)).slice(-2); } t = t.match(/^rgb((d+),s*(d+),s*(d+))$/); var r = n(t[1]) + n(t[2]) + n(t[3]); return r.toUpperCase(); }, Math2.distance = function (t, n, r, a) { return Math.sqrt((r - t) * (r - t) + (a - n) * (a - n)); }; //mouse var mousePos = { x: 0, y: 0 }; window.onmousemove = function (e) { e = e || window.event; var pageX = e.pageX; var pageY = e.pageY; if (pageX === undefined) { pageX = e.clientX + document.body.scrollLeft + document.documentElement.scrollLeft; pageY = e.clientY + document.body.scrollTop + document.documentElement.scrollTop; } mousePos = { x: pageX, y: pageY }; }; var options = { width: window.innerWidth, height: window.innerHeight, keyword: \"404\", density: 10, densityText: 3, minDist: 20 }; // initialize canvas var canvas = document.createElement('canvas'); canvas.width = options.width; canvas.height = options.height; canvas.style.width = options.width / 2; canvas.style.height = options.height / 2; canvas.getContext('2d').scale(2, 2); var renderer = new PIXI.autoDetectRenderer(options.width, options.height, { transparent: true }); var stage = new PIXI.Stage(\"0X000000\", true); document.body.appendChild(renderer.view); renderer.view.id = \"not_found\"; var imageData = false; var particles = []; function init() { positionParticles(); positionText(); } function positionParticles() { var canvas = document.createElement(\"canvas\"); canvas.width = 500; canvas.height = 350; var context = canvas.getContext(\"2d\"); context.fillStyle = \"#000000\"; context.font = \"300px 'Arial', sans-serif\"; context.fillText(options.keyword, 0, 250); var imageData = context.getImageData(0, 0, 350, 500); data = imageData.data; // Iterate each row and column for (var i = 0; i < imageData.height; i += options.density) { for (var j = 0; j < imageData.width; j += options.density) { // Get the color of the pixel var color = data[j * (imageData.width * 4) + i * 4 - 1]; // If the color is black, draw pixels if (color == 255) { var newPar = particle(); newPar.setPosition(i, j); particles.push(newPar); stage.addChild(newPar); } } } } function positionText() { var canvas = document.createElement(\"canvas\"); canvas.width = 400; canvas.height = 200; var context = canvas.getContext(\"2d\"); context.fillStyle = \"#000000\"; context.font = \"80px 'Arial', sans-serif\"; context.fillText(\"Not Found\", 0, 80); var imageData = context.getImageData(0, 0, 400, 400); data = imageData.data; // Iterate each row and column for (var i = 0; i < imageData.height; i += options.densityText) { for (var j = 0; j < imageData.width; j += options.densityText) { // Get the color of the pixel var color = data[j * (imageData.width * 4) + i * 4 - 1]; // If the color is black, draw pixels if (color == 255) { var newPar = particle(true); newPar.setPosition(i, j); particles.push(newPar); stage.addChild(newPar); } } } } function particle(text) { $this = new PIXI.Graphics(); if (text == true) { $this.text = true; } $this.beginFill(0XFFFFFF); var radius; $this.radius = radius = $this.text ? Math.random() * 3.5 : Math.random() * 10.5; $this.drawCircle(0, 0, radius); $this.size = this.radius; $this.x = -this.width; $this.y = -this.height; $this.free = false; $this.timer = Math2.randomInt(0, 100); $this.v = Math2.randomPlusMinus() * Math2.random(.5, 1); $this.hovered = false; $this.alpha = Math2.randomInt(10, 100) / 100; $this.vy = -5 + parseInt(Math.random() * 10) / 2; $this.vx = -4 + parseInt(Math.random() * 8); $this.setPosition = function (x, y) { if ($this.text) { $this.x = x + (options.width / 2 - 180); $this.y = y + (options.height / 2 + 100); } else { $this.x = x + (options.width / 2 - 250); $this.y = y + (options.height / 2 - 175); } }; return $this; } function update() { renderer.render(stage); for (i = 0; i < particles.length; i++) { var p = particles[i]; if (mousePos.x > p.x && mousePos.x < p.x + p.size && mousePos.y > p.y && mousePos.y < p.y + p.size) { p.hovered = true; } p.scale.x = p.scale.y = scale = Math.max(Math.min(2.5 - Math2.distance(p.x, p.y, mousePos.x, mousePos.y) / 160, 160), 1); p.x = p.x + .2 * Math.sin(p.timer * .15); p.y = p.y + .2 * Math.cos(p.timer * .15); p.timer = p.timer + p.v; } window.requestAnimationFrame(update); } init(); update();"},{"title":"about","date":"2021-09-04T14:14:36.000Z","updated":"2021-09-08T00:52:21.259Z","comments":false,"path":"about/index.html","permalink":"http://goodguyjameswin.github.io/about/index.html","excerpt":"","text":"[WHUTのTerryJoe] 与&nbsp; Kirito&nbsp; （ Asuna ） 对话中... bot_ui_ini()","keywords":"关于我"},{"title":"categories","date":"2021-09-04T16:40:09.000Z","updated":"2021-09-11T09:08:23.098Z","comments":false,"path":"categories/index.html","permalink":"http://goodguyjameswin.github.io/categories/index.html","excerpt":"","text":"","keywords":"分类图"},{"title":"bangumi","date":"2021-09-04T13:32:48.000Z","updated":"2021-09-08T00:52:34.864Z","comments":false,"path":"bangumi/index.html","permalink":"http://goodguyjameswin.github.io/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"comment","date":"2021-09-04T15:13:48.000Z","updated":"2021-09-08T00:52:58.243Z","comments":true,"path":"comment/index.html","permalink":"http://goodguyjameswin.github.io/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"links","date":"2021-09-04T15:11:06.000Z","updated":"2021-10-07T02:55:28.044Z","comments":false,"path":"links/index.html","permalink":"http://goodguyjameswin.github.io/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"music","date":"2021-09-04T15:14:28.000Z","updated":"2021-10-07T08:23:31.367Z","comments":false,"path":"music/index.html","permalink":"http://goodguyjameswin.github.io/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"rss","date":"2021-09-04T15:09:03.000Z","updated":"2021-09-08T00:53:21.547Z","comments":true,"path":"rss/index.html","permalink":"http://goodguyjameswin.github.io/rss/index.html","excerpt":"","text":""},{"title":"video","date":"2021-09-04T15:14:38.000Z","updated":"2021-09-08T00:53:48.250Z","comments":false,"path":"video/index.html","permalink":"http://goodguyjameswin.github.io/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"},{"title":"tags","date":"2021-09-05T15:13:48.000Z","updated":"2021-09-11T09:08:30.171Z","comments":false,"path":"tags/index.html","permalink":"http://goodguyjameswin.github.io/tags/index.html","excerpt":"","text":"","keywords":"标签云"}],"posts":[{"title":"贪心","slug":"贪心","date":"2022-06-23T13:24:26.000Z","updated":"2022-08-07T01:39:46.065Z","comments":false,"path":"2022/06/23/贪心/","link":"","permalink":"http://goodguyjameswin.github.io/2022/06/23/贪心/","excerpt":"","text":"贪心算法贪心算法总假设问题具有最优子结构和贪心选择性质（从子问题的局部最优解可以通过递推得到全局最优解），贪心算法往往不会像回溯算法与动态规划那样尝试枚举每一步可能的操作，并且比较所有可能的方案的结果。 问题选讲经典问题：给定长度为2n的整数数组nums，你的任务是将这些数分成n对，例如(a1, b1), (a2, b2), ..., (an, bn)，使得从 1 到 n 的min(ai, bi)总和最大。返回该最大总和。 输入：nums = [6,2,6,5,1,2] 输出：9 解释：最优的分法为 (2, 1), (2, 5), (6, 6). min(2, 1) + min(2, 5) + min(6, 6) = 1 + 2 + 6 = 9 // 贪心算法的直觉：配对的两个数里，较大的数会被「消去」，所以输入数组里最大的数一定会被消去，为了得到「配对以后取最小、最小值的和最大」的结果，需要让「倒数第二大的数」和「最大的数」配对，好让「倒数第二大的数」作为一个加法项被保留 public class Solution { public int arrayPairSum(int[] nums) { int len = nums.length; // 输入数组长度为偶数，因此可以对输入数组升序排列，然后相邻位置「两两配对」 Arrays.sort(nums); int res = 0; for (int i = 0; i &lt; len; i += 2) { res += nums[i]; } return res; } } 经典问题：老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。你需要按照以下要求，帮助老师给这些孩子分发糖果： 每个孩子至少分配到 1 个糖果。 相邻的孩子中，评分高的孩子必须获得更多的糖果。 那么这样下来，老师至少需要准备多少颗糖果呢？ 输入: [1,0,2] 输出: 5 解释: 你可以分别给这三个孩子分发 2、1、2 颗糖果。 // 贪心思路：一次遍历，我们每看到一个元素的时候，就需要想是不是可以只根据之前看到的数据决定当前需要的糖果数 public class Solution { public int candy(int[] ratings) { int len = ratings.length; if (len == 0) { return 0; } int res = 1; // 最近的、处于上升区间里的最后一个元素的值 int up = 0; // 下降区间的元素的长度 int down = 0; // 上升区间里，循环变量 i 的左边一个位置的小朋友得到的糖果数 int prev = 0; for (int i = 1; i &lt; len; i++) { if (ratings[i - 1] &lt; ratings[i]) { up++; down = 0; prev = up; res += (up + 1); } else if (ratings[i - 1] == ratings[i]) { // 不管处于上升区间还是下降区间，这三个变量都重置为 0 up = 0; prev = 0; down = 0; // 不管处于上升区间还是下降区间，此时都只贪心地给当前小朋友 1 颗糖果 res += 1; } else { // 此时处于下降区间 up = 0; down++; if (down &lt;= prev) { res += down; } else { res += down + 1; } } } return res; } } 经典问题：给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。 可以认为区间的终点总是大于它的起点。 区间[1,2]和[2,3]的边界相互“接触”，但没有相互重叠。 输入: [ [1,2], [2,3], [3,4], [1,3] ] 输出: 1 解释: 移除 [1,3] 后，剩下的区间没有重叠。 // 贪心思路：图中的所有区间按照右端点升序排序，然后我们遍历这些区间，每一次选择结束较早的、且与之前的区间不重合的区间，留给后面富裕的区间长度就更长，这样才能保留更多不重合的区间 public class Solution { public int eraseOverlapIntervals(int[][] intervals) { int len = intervals.length; if (len == 0) { return 0; } Arrays.sort(intervals, Comparator.comparingInt(interval -&gt; interval[1])); int end = intervals[0][1]; int maxLen = 1; for (int i = 1; i &lt; len; ++i) { if (end &lt;= intervals[i][0]) { maxLen++; end = intervals[i][1]; } } return len - maxLen; } } 力扣253：给你一个会议时间安排的数组intervals，每个会议时间都会包括开始和结束的时间intervals[i] = [start_i, end_i]，为避免会议冲突，同时要考虑充分利用会议室资源，请你计算至少需要多少间会议室，才能满足这些会议安排 输入：intervals = [[0,30],[5,10],[15,20]] 输出：2 查看解析 // 贪心思路：总是希望之前的会议越早结束越好，这是因为 如果一个会议结束得越早，那么后面的会议可以开始且不同时进行的概率就会越大 public class Solution { public int minMeetingRooms(int[][] intervals) { int len = intervals.length; if (len &lt; 2) { return len; } Arrays.sort(intervals, Comparator.comparingInt(o -&gt; o[0])); // 但问题要求的其实是：可以同时进行的会议有多少个；因此需要关注每个会议结束的时间 PriorityQueue&lt;Integer&gt; minHeap = new PriorityQueue&lt;&gt;(); int res = 0; for (int[] interval : intervals) { // 这个过程很可能会弹出很多会议，因此使用 while while (!minHeap.isEmpty() &amp;&amp; interval[0] &gt;= minHeap.peek()) { minHeap.poll(); } minHeap.add(interval[1]); res = Math.max(res, minHeap.size()); } return res; } } 经典问题：给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个位置。 输入: [2,3,1,1,4] 输出: true 解释: 从位置 0 到 1 跳 1 步, 然后跳 3 步到达最后一个位置。 public class Solution { public boolean canJump(int[] nums) { int len = nums.length; if (len == 1) { return true; } int maxReached = 0; // 数组的最后一个值可以不看 for (int i = 0; i &lt; len - 1; i++) { // 判断当前位置是否能达到 if (i &gt; maxReached) { return false; } // 读取 nums[i] 更新 maxReached maxReached = Math.max(maxReached, i + nums[i]); if (maxReached &gt;= len - 1) { return true; } } return false; } } 思考：假设你总是可以到达数组的最后一个位置，最少的跳跃次数是多少？ 查看解析 // 除了关心「当前步骤可以跳到的最远的位置」以外，还需要关心「下一步跳跃可以到达的最远的位置」 public class Solution { public int jump(int[] nums) { int len = nums.length; int currMaxReached = 0; int nextMaxReached = 0; int res = 0; // 最后一个位置不用看 for (int i = 0; i &lt; len - 1; i++) { nextMaxReached = Math.max(nextMaxReached, nums[i] + i); if (i == currMaxReached) { // 遇到这一步可以到达的最远边界，就更新为下一步可以达到的最远边界，并且最少步数加一 currMaxReached = nextMaxReached; res++; } } return res; } } 力扣402：给你一个以字符串表示的非负整数num和一个整数k，移除这个数中的k位数字，使得剩下的数字最小。请你以字符串形式返回这个最小的数字。 输入：num = “1432219”, k = 3 输出：”1219” 解释：移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219 。 查看解析 public class Solution { public String removeKdigits(String num, int k) { int len = num.length(); if (len == k) { return &quot;0&quot;; } int remaining = len - k; char[] charArray = num.toCharArray(); Deque&lt;Character&gt; stack = new ArrayDeque&lt;&gt;(); for (char c : charArray) { while (k &gt; 0 &amp;&amp; !stack.isEmpty() &amp;&amp; stack.peekLast() &gt; c) { stack.removeLast(); k--; } stack.addLast(c); } // 针对单调不减的用例，只取前面剩下的部分，针对 String num = &quot;112&quot;; int k = 1; 这种用例 while (stack.size() &gt; remaining) { stack.pollLast(); } // 去掉前导 0 while (!stack.isEmpty() &amp;&amp; stack.peekFirst() == &#39;0&#39;) { // 恰好 Deque 有提供 removeFirst() 实现 stack.removeFirst(); } // 栈为空，说明已从原数字移除所有的数字，返回数字就是0 if (stack.isEmpty()) { return &quot;0&quot;; } // 此时栈内从栈底到栈顶拼接成的字符串就是题目要求的结果 int size = stack.size(); StringBuilder stringBuilder = new StringBuilder(); for (int i = 0; i &lt; size; i++) { stringBuilder.append(stack.removeFirst()); } return stringBuilder.toString(); } } 经典问题：数轴上放置了一些筹码，每个筹码的位置存在数组chips当中。你可以对任何筹码执行下面两种操作之一（不限操作次数，0 次也可以）： 将第 i 个筹码向左或者右移动 2 个单位，代价为 0。 将第 i 个筹码向左或者右移动 1 个单位，代价为 1。 最开始的时候，同一位置上也可能放着两个或者更多的筹码。返回将所有筹码移动到同一位置（任意位置）上所需要的最小代价。 输入：chips = [1,2,3] 输出：1 解释：第二个筹码移动到位置三的代价是 1，第一个筹码移动到位置三的代价是 0，总代价为 1。 // 贪心思路：既然「不限操作次数」，且「将第 i 个筹码向左或者右移动 2 个单位，代价为 0」，就可以尽量多地使用这种操作，将 所有的 筹码放在 相邻的 两个位置上 // 然后再使用「将第 i 个筹码向左或者右移动 1 个单位，代价为 1」 操作，将其中一个位置上的所有筹码移动到另一个位置上，为了使得代价最少，我们将数量较少的筹码堆的所有筹码移动到数量较多的筹码堆。 public class Solution { public int minCostToMoveChips(int[] position) { // 统计输入数组里奇数的个数 int odd = 0; // 统计输入数组里偶数的个数 int even = 0; for (int p : position) { if ((p % 2) == 0) { even++; } else { odd++; } } return Math.min(odd, even); } } 力扣1247：有两个长度相同的字符串s1和s2，且它们其中只含有字符&quot;x&quot;和&quot;y&quot;，你需要通过「交换字符」的方式使这两个字符串相同。 每次「交换字符」的时候，你都可以在两个字符串中各选一个字符进行交换。 交换只能发生在两个不同的字符串之间，绝对不能发生在同一个字符串内部。也就是说，我们可以交换s1[i]和s2[j]，但不能交换s1[i]和s1[j]。 最后，请你返回使s1和s2相同的最小交换次数，如果没有方法能够使得这两个字符串相同，则返回-1。 输入：s1 = “xy”, s2 = “yx” 输出：2 解释： 交换 s1[0] 和 s2[0]，得到 s1 = “yy”，s2 = “xx” 。 交换 s1[0] 和 s2[1]，得到 s1 = “xy”，s2 = “xy” 。 注意，你不能交换 s1[0] 和 s1[1] 使得 s1 变成 “yx”，因为我们只能交换属于两个不同字符串的字符。 查看解析 当s1 = &quot;xx&quot;，s2 = &quot;yy&quot;时，只需交换一次，就可以使两个字符串相等 当s1 = &quot;xy&quot;，s2 = &quot;yx&quot;时，需要交换两次才可以使两个字符串相等 遍历比较两个字符串，如果s1[i] = s2[i]则不用交换 xy 表示s1[i] = x，s2[i] = y的次数 yx 表示s1[i] = y，s2[i] = x的次数 因为需要每两组字符才可以进行交换，如果xy+yx为奇数，必定有一组字符不能交换，返回-1 优先交换所有的&quot;xx&quot; &quot;yy&quot;和&quot;yy&quot; &quot;xx&quot;，因为只需一次交换。若还剩一组&quot;xy&quot; &quot;yx&quot;则再加2即可 class Solution { public int minimumSwap(String s1, String s2) { int xy = 0, yx = 0; char[] c1 = s1.toCharArray(); char[] c2 = s2.toCharArray(); for(int i = 0; i &lt; c1.length; i++){ if(c1[i] == c2[i]) continue; if(c1[i] == &#39;x&#39;) xy++; else yx++; } if(((xy + yx) &amp; 1) != 0) return -1; return xy / 2 + yx / 2 + (xy % 2 * 2); } } .center { width: auto; display: table; margin-left: auto; margin-right: auto; }","categories":[{"name":"生活","slug":"生活","permalink":"http://goodguyjameswin.github.io/categories/生活/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://goodguyjameswin.github.io/tags/学习笔记/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"http://goodguyjameswin.github.io/categories/生活/"}]},{"title":"并查集","slug":"并查集","date":"2022-06-17T10:43:27.000Z","updated":"2022-07-26T09:48:05.578Z","comments":false,"path":"2022/06/17/并查集/","link":"","permalink":"http://goodguyjameswin.github.io/2022/06/17/并查集/","excerpt":"","text":"并查集并查集也是建立在数组上的树形结构，是一颗完全二叉树。结点的个数通常是确定的，特点是由该子结点指向父亲结点，从而形成一条边。 并查集的quick-find实现quick-find基于id的思想：给每一个组一个编号，这个编号称为id，如果两个元素的id一样，就认为它们同属于一个集合，时间复杂度为O(1)。要想合并两个组，就需要将它们的id设置成一样，最坏情况需要修改整个数组元素的id，因此查询快，合并慢。 public class UnionFind { /** * 每个结点的 id 标识，id 标识一样，表示被分在一个组 */ private int[] id; /** * 连通分量的个数 */ private int count; private int N; public int getCount() { return count; } public UnionFind(int N) { this.N = N; this.count = N; this.id = new int[N]; for (int i = 0; i &lt; N; i++) { id[i] = i; } } public int find(int x) { return id[x]; } public void union(int x, int y) { int xid = find(x); int yid = find(y); // 合并之前先做判断 if (xid == yid) { return; } // 这里需要遍历，时间复杂度为 $O(N)$ for (int i = 0; i &lt; N; i++) { if (id[i] == xid) { id[i] = yid; } } count--; } } 并查集的quick-union实现为每一个不相交的集合设置一个代表元素来标识这个元素。一开始和quick-find一样，所有的元素都是独立的。只要有发生合并，不是修改标识，而是把其中一个元素的根结点的链接指向另一个元素的根结点，其设计思想是：为每一个集合选出一个代表元素，这个代表元素位于这棵树的根结点，因此也叫代表元法。 public class UnionFind { /** * 在查找的过程中，总是从下到上查找，每个结点的父结点是我们关心的，因此把这个数组命名为 parent */ private int[] parent; // 以i为根节点的子树的个数 // private int[] size; // 以i为根节点的子树的高度 private int[] rank; private int count; private int N; public int getCount() { return count; } public UnionFind(int N) { this.N = N; this.count = N; this.parent = new int[N]; // 初始化的时候，每个元素指向它自己，即：单独的一个结点是一棵树 for (int i = 0; i &lt; N; i++) { parent[i] = i; } // 初始化的时候，每个结点都是一棵树，只有1个结点 // Arrays.fill(size, 1); // 初始化的时候，每个结点的高度为1 Arrays.fill(rank, 1); } public int find(int x) { // 在查找过程中，使得树的高度变得更低 while (x != parent[x]) { // 路径压缩：隔代压缩 parent[x] = parent[parent[x]]; // 让查询过程中经历的部分结点指向它的父亲结点的父亲结点 x = parent[x]; } return x; // // 路径压缩：完全压缩 // if (x != parent[x]) { // // find(parent[x]) 会返回树的根结点， // // parent[x] = find(parent[x]) 会将沿途经过的结点的父亲结点都指向根结点 // parent[x] = find(parent[x]); // } // // 输入 x 没有发生变化，应返回 x 的父亲结点，才表示树根结点 // return parent[x]; } public void union(int x, int y) { int rootX = find(x); int rootY = find(y); if (rootX == rootY) { return; } // // 按size合并：把结点个数较少的树的根结点指向结点个数较多的树的根结点 // if (size[rootX] == size[rootY]) { // // 将其中一棵树的根结点指向另一棵树的根结点即可，两个根结点不分彼此 // parent[rootX] = rootY; // size[rootY] += size[rootX]; // } else if (size[rootX] &lt; size[rootY]) { // parent[rootX] = rootY; // // 此时以 rootY 为根结点的子树多了 size[rootX] 这么多结点 // // 需要维护定义 // size[rootY] += size[rootX]; // } else { // parent[rootY] = rootX; // // 此时以 rootY 为根结点的子树多了 size[rootX] 这么多结点 // // 需要维护定义 // size[rootX] += size[rootY]; // } // 按秩合并：将高度较低树的根节点指向高度较高的树的根节点，这样合并以后不会增加树的高度（合并之前两棵树高度相等的情况，合并以后其中一个树的高度增加 1） if (rank[rootX] == rank[rootY]) { parent[rootX] = rootY; // 此时以 rootY 为根节点的树的高度仅增加了1 rank[rootY] += 1; } else if (rank[rootX] &lt; rank[rootY]) { parent[rootX] = rootY; // 此时以rootY为根节点的树的高度不变 } else { // 同理，此时以rootX为根节点的树的高度不变 parent[rootY] = rootX; } count--; } } 力扣128：给定一个未排序的整数数组nums，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。请你设计并实现时间复杂度为O(n)的算法解决此问题。 输入：nums = [100,4,200,1,3,2] 输出：4 解释：最长数字连续序列是 [1,2,3,4]。它的长度为4。 查看解析 class Solution { public int longestConsecutive(int[] nums) { // 用Map进行一个下标和值的对应，进行重复元素的排除，且可快速判断当前并查集中已有元素 Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); UF uf = new UF(nums.length); for (int i = 0; i &lt; nums.length; i++) { // 存在重复元素，跳过 if (map.containsKey(nums[i])) continue; // 与相邻元素相连 if (map.containsKey(nums[i] - 1)) { uf.union(i, map.get(nums[i] - 1)); } if (map.containsKey(nums[i] + 1)) { uf.union(i, map.get(nums[i] + 1)); } map.put(nums[i], i); } return uf.getMaxConnectSize(); } class UF { private int[] parent; private int[] size; public UF(int n) { parent = new int[n]; size = new int[n]; for (int i = 0; i &lt; n; i++) { parent[i] = i; size[i] = 1; } } public void union(int p, int q) { int rootP = find(p); int rootQ = find(q); if (rootP == rootQ) return; parent[rootP] = rootQ; // 注意 别写反了 size[rootQ] += size[rootP]; } // get root id private int find(int x) { // 路径压缩 if (parent[x] != x) { parent[x] = find(parent[x]); } return parent[x]; } public int getMaxConnectSize() { int maxSize = 0; for (int i = 0; i &lt; parent.length; i++) { if (i == parent[i]) { maxSize = Math.max(maxSize, size[i]); } } return maxSize; } } } 力扣959：在由1*1方格组成的n*n网格grid中，每个1*1方块由&#39;/&#39;、&#39;\\&#39;或空格构成。这些字符会将方块划分为一些共边的区域。给定网格grid表示为一个字符串数组，返回区域的数量。请注意，反斜杠字符是转义的，因此&#39;\\&#39;用&#39;\\\\&#39;表示。 输入：grid = [“/\\“, “\\/“] 输出：5 查看解析 public class Solution { public int regionsBySlashes(String[] grid) { int N = grid.length; int size = 4 * N * N; UnionFind unionFind = new UnionFind(size); for (int i = 0; i &lt; N; i++) { char[] row = grid[i].toCharArray(); for (int j = 0; j &lt; N; j++) { // 二维网格转换为一维表格，index 表示将单元格拆分成 4 个小三角形以后，编号为 0 的小三角形的在并查集中的下标 int index = 4 * (i * N + j); char c = row[j]; // 单元格内合并 if (c == &#39;/&#39;) { // 合并 0、3，合并 1、2 unionFind.union(index, index + 3); unionFind.union(index + 1, index + 2); } else if (c == &#39;\\\\&#39;) { // 合并 0、1，合并 2、3 unionFind.union(index, index + 1); unionFind.union(index + 2, index + 3); } else { unionFind.union(index, index + 1); unionFind.union(index + 1, index + 2); unionFind.union(index + 2, index + 3); } // 单元格间合并 // 向右合并：1（当前）、3（右一列） if (j + 1 &lt; N) { unionFind.union(index + 1, 4 * (i * N + j + 1) + 3); } // 向下合并：2（当前）、0（下一行） if (i + 1 &lt; N) { unionFind.union(index + 2, 4 * ((i + 1) * N + j)); } } } return unionFind.getCount(); } private class UnionFind { private int[] parent; private int count; public int getCount() { return count; } public UnionFind(int n) { this.count = n; this.parent = new int[n]; for (int i = 0; i &lt; n; i++) { parent[i] = i; } } public int find(int x) { while (x != parent[x]) { parent[x] = parent[parent[x]]; x = parent[x]; } return x; } public void union(int x, int y) { int rootX = find(x); int rootY = find(y); if (rootX == rootY) { return; } parent[rootX] = rootY; count--; } } } 带权并查集经典问题：给你一个变量对数组equations和一个实数值数组values作为已知条件，其中equations[i]=[Ai,Bi]和values[i]共同表示等式Ai/Bi=values[i]。每个Ai或Bi是一个表示单个变量的字符串。 另有一些以数组queries表示的问题，其中queries[j]=[Cj,Dj]表示第j个问题，请你根据已知条件找出Cj/Dj=?的结果作为答案。 返回所有问题的答案。如果存在某个无法确定的答案，则用-1.0替代这个答案。如果问题中出现了给定的已知条件中没有出现的字符串，也需要用-1.0替代这个答案。（注意输入总是有效的） 输入：equations = [[“a”,”b”],[“b”,”c”]], values = [2.0,3.0], queries = [[“a”,”c”],[“b”,”a”],[“a”,”e”],[“a”,”a”],[“x”,”x”]] 输出：[6.00000,0.50000,-1.00000,1.00000,-1.00000] 解释： 条件：a / b = 2.0, b / c = 3.0 问题：a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ? 结果：[6.0, 0.5, -1.0, 1.0, -1.0] 查看解析 public class Solution { public double[] calcEquation(List&lt;List&lt;String&gt;&gt; equations, double[] values, List&lt;List&lt;String&gt;&gt; queries) { int equationsSize = equations.size(); // 最极端情况下，每一个等式的两边的变量都不同，因此并查集底层数组开 2 倍的 equations 的长度即可 UnionFind unionFind = new UnionFind(2 * equationsSize); // 第 1 步：预处理，将变量的值与 id 进行映射，使得并查集的底层使用数组实现，方便编码 Map&lt;String, Integer&gt; hashMap = new HashMap&lt;&gt;(); int id = 0; for (int i = 0; i &lt; equationsSize; i++) { List&lt;String&gt; equation = equations.get(i); String var1 = equation.get(0); String var2 = equation.get(1); if (!hashMap.containsKey(var1)) { hashMap.put(var1, id); id++; } if (!hashMap.containsKey(var2)) { hashMap.put(var2, id); id++; } unionFind.union(hashMap.get(var1), hashMap.get(var2), values[i]); } // 第 2 步：做查询 int queriesSize = queries.size(); double[] res = new double[queriesSize]; for (int i = 0; i &lt; queriesSize; i++) { // 对每一个 query 查询变量对应的 id String var1 = queries.get(i).get(0); String var2 = queries.get(i).get(1); Integer id1 = hashMap.get(var1); Integer id2 = hashMap.get(var2); // 两个变量只要其中一个不在以前出现过的变量集合中，返回 -1 if (id1 == null || id2 == null) { res[i] = -1.0; } else { // 对并查集进行查询，如果在一个集合中，返回「权值商」 // 如果不在一个集合中，返回 -1 res[i] = unionFind.isConnected(id1, id2); } } return res; } private class UnionFind { private int[] parent; /** * 把父结点作为分母时的商（重点维护） */ private double[] weight; public UnionFind(int n) { this.parent = new int[n]; this.weight = new double[n]; for (int i = 0; i &lt; n; i++) { parent[i] = i; // 单独一个结点的时候，自己除以自己，商为 1 weight[i] = 1.0d; } } public void union(int x, int y, double value) { int rootX = find(x); int rootY = find(y); parent[rootX] = rootY; // 需要列方程计算 weight[rootX] = weight[y] * value / weight[x]; } public int find(int x) { // 这里只能使用完全压缩 if (x != parent[x]) { // 注意：这里维护 weight 的定义 int origin = parent[x]; parent[x] = find(parent[x]); // 先更新较浅层结点的权值，较深层结点的权值需要根据较浅层结点的权值进行更新 weight[x] *= weight[origin]; } return parent[x]; } public double isConnected(int x, int y) { int rootX = find(x); int rootY = find(y); // 注意：由于 find 执行了「完全压缩」的路径压缩优化，两个 find 执行完成以后 // 如果 x 和 y 在同一个集合中，此时它们的父亲结点已经指向同一个根结点了 if (rootX == rootY) { // 在一个集合中，返回权值商 return weight[x] / weight[y]; } else { // 不在一个集合中，返回 -1 return -1.0d; } } } } 力扣685：在本问题中，有根树指满足以下条件的有向图。该树只有一个根节点，所有其他节点都是该根节点的后继。该树除了根节点之外的每一个节点都有且只有一个父节点，而根节点没有父节点。 输入一个有向图，该图由一个有着n个节点（节点值不重复，从1到n）的树及一条附加的有向边构成。附加的边包含在1到n中的两个不同顶点间，这条附加的边不属于树中已存在的边。 结果图是一个以边组成的二维数组edges。每个元素是一对[ui, vi]，用以表示有向图中连接顶点ui和顶点vi的边，其中ui是vi的一个父节点。 返回一条能删除的边，使得剩下的图是有n个节点的有根树。若有多个答案，返回最后出现在给定二维数组的答案。 输入：edges = [[1,2],[2,3],[3,4],[4,1],[1,5]] 输出：[4,1] 查看解析 // 树中的每个节点都有一个父节点，除了根节点没有父节点。在多了一条附加的边之后： // 1、附加的边指向根节点，则包括根节点在内的每个节点都有一个父节点，此时图中一定有环路 // 2、附加的边指向非根节点，则恰好有一个节点（即被附加的边指向的节点）有两个父节点，此时图中可能有环路也可能没有环路 class Solution { public int[] findRedundantDirectedConnection(int[][] edges) { int n = edges.length; UnionFind uf = new UnionFind(n + 1); int[] parent = new int[n + 1]; for (int i = 1; i &lt;= n; ++i) { parent[i] = i; } int conflict = -1; int cycle = -1; for (int i = 0; i &lt; n; ++i) { int[] edge = edges[i]; int node1 = edge[0], node2 = edge[1]; if (parent[node2] != node2) { // 说明 node2 有两个父结点，标记为导致冲突的边 conflict = i; } else { parent[node2] = node1; if (uf.find(node1) == uf.find(node2)) { // 祖先相同，标记为导致环路出现的边 cycle = i; } else { uf.union(node1, node2); } } } // 同一条边不可能同时被记为导致冲突的边和导致环路出现的边。如果访问到的边确实同时导致冲突和环路出现，则这条边被记为导致冲突的边 if (conflict &lt; 0) { // 如果没有导致冲突的边，说明附加的边一定导致环路出现，而且是在环路中的最后一条被访问到的边，因此附加的边即为导致环路出现的边 int[] redundant = {edges[cycle][0], edges[cycle][1]}; return redundant; } else { int[] conflictEdge = edges[conflict]; if (cycle &gt;= 0) { // 如果有导致环路的边，则附加的边不可能是已经被标记为导致冲突的边 int[] redundant = {parent[conflictEdge[1]], conflictEdge[1]}; return redundant; } else { // 如果没有导致环路的边，则附加的边是后被访问到的边 int[] redundant = {conflictEdge[0], conflictEdge[1]}; return redundant; } } } } class UnionFind { int[] ancestor; public UnionFind(int n) { ancestor = new int[n]; for (int i = 0; i &lt; n; ++i) { ancestor[i] = i; } } public void union(int index1, int index2) { ancestor[find(index1)] = find(index2); } public int find(int index) { if (ancestor[index] != index) { ancestor[index] = find(ancestor[index]); } return ancestor[index]; } } 最小生成树Prim算法集合V保存未加入到最小生成树中的节点，最开始，所有的图节点都在集合V中；集合Vnew保存已经加入到最小生成树中的节点，如果一个节点加入到了最小生成树中，则将该节点加入到Vnew（即最小生成树） Prim算法主要维护两个数组： lowcost数组，表示V中的节点，保存V中每个节点离集合Vnew中所有节点的最短距离。如果节点已经加入到了集合Vnew中，则置为-1 v数组，表示V中节点的访问情况，最开始全部为0，表示未加入到Vnew中，若某节点加入到了集合Vnew中，则将其置为-1 步骤： 随机选择一个起点，将其加入到Vnew中。同时，更新此时的数组lowcost和数组v 遍历lowcost，寻找lowcost中的最小值min（假设索引为j，j为Vnew中离V最近的点），将与索引j相对应的节点加入到Vnew中，并更新数组lowcost[j]和数组v[j] 找到lowcost中的最小值j后，此时数组lowcost中的所有结点都要更新，因为此时集合Vnew中的节点增加了，集合V中的结点离Vnew的最近距离可能会缩短 根据新加入集合Vnew中的结点j，更新所有的lowcost 重复步骤2，直到访问了所有的结点 最后需要计算的最小生成树中所有结点之间的距离之和 便是每一步迭代时求得得lowcost中得最小值min的和 public class Prim { // 存在横切边的数据结构 private final Queue&lt;int[]&gt; pq; // 记录已经成为最小生成树的节点 private boolean[] inMST; // 记录最小生成树的权重和 private Integer weightSum = 0; // graph 是用邻接表表示的一幅图 // graph[s] 记录节点 s 所有相邻的边 // 三元组 int[]{from, to, weight} 表示一条边 private final List&lt;int[]&gt;[] graph; public Prim(List&lt;int[]&gt;[] graph) { this.graph = graph; // 按照边的权重从小到大排序 this.pq = new PriorityQueue&lt;&gt;(Comparator.comparingInt(a -&gt; a[2])); // 图中有 n 个节点 int n = graph.length; this.inMST = new boolean[n]; // 随便从一个点开始切分都可以，我们不妨从节点 0 开始 inMST[0] = true; cut(0); // 不断进行切分，向最小生成树中添加边 while (!pq.isEmpty()) { int[] edge = pq.poll(); int to = edge[1]; int weight = edge[2]; if (inMST[to]) { // 节点 to 已经在最小生成树中，跳过 // 否则这条边会产生环 continue; } // 将边 edge 加入最小生成树 weightSum += weight; inMST[to] = true; // 节点 to 加入后，进行新一轮切分，会产生更多横切边 cut(to); } } // 将 s 的横切边加入优先队列 private void cut(int x) { // 遍历 s 的邻边 for (int[] edge : graph[x]) { int to = edge[1]; if (inMST[to]) { // 相邻接点 to 已经在最小生成树中，跳过 // 否则这条边会产生环 continue; } // 加入横切边队列 pq.offer(edge); } } // 最小生成树的权重和 public int weightSum() { return this.weightSum; } // 判断最小生成树是否包含图中的所有节点 public boolean allConnected() { for (int i = 0; i &lt; graph.length; i++) { if (!inMST[i]) { return false; } } return true; } } Kruskal算法以边为基础，每次从边集合中寻找最小的边（不管两个顶点属于V还是Vnew），然后判断该边的两个顶点是否同源（属于同一个连通分量），Kruskal需要对所有的边进行排序，然后从小到大，依次遍历每条边，同时判断每条边是否同源，如果同源，跳过；如果不同源，将两个连通分量合并，直到所有顶点属于同一个连通分量，算法结束 步骤： 初始化：将图（邻接矩阵或邻接表）转换成点-边式，并对点-边式按边的长度进行排序。同时，初始化并查集 依次遍历所有的点-边式，每次取最小值 如果该点-边式的两个顶点同源，跳过；如果该点-边式的两个顶点不同源，则将这两个源（连通分量）合并 重复步骤2，知道存在一个连通分量，包含了图中所有的结点 class Solution { public int minimumCost(int n, int[][] edges) { // 编号为 0...n UnionFind uf = new UnionFind(n + 1); // 对所有边按照权重从小到大排序 Arrays.sort(edges, (a, b) -&gt; (a[2] - b[2])); // 记录最小生成树的权重之和 int mst = 0; for (int[] edge : edges) { int u = edge[0]; int v = edge[1]; int weight = edge[2]; // 若这条边会产生环，则不能加入 mst if (uf.connected(u, v)) { continue; } // 若这条边不会产生环，则属于最小生成树 mst += weight; uf.union(u, v); } // 保证所有节点都被连通 // uf.count() == 1 说明所有节点被连通 return uf.count() == 1 ? mst : -1; } class UnionFind { // ... } } 力扣1168：村里面一共有n栋房子。我们希望通过建造水井和铺设管道来为所有房子供水。 对于每个房子i，我们有两种可选的供水方案：一种是直接在房子内建造水井，成本为wells[i-1]（注意-1，因为索引从0开始）；另一种是从另一口井铺设管道引水，数组pipes给出了在房子间铺设管道的成本，其中每个pipes[j]=[house1j,house2j,costj]代表用管道将house1j和house2j连接在一起的成本。连接是双向的。请返回为所有房子都供水的最低总成本。 输入：n = 3, wells = [1,2,2], pipies = [[1,2,1],[2,3,1]] 输出：3 解释： 上图展示了铺设管道连接房屋的成本。 最好的策略是在第一个房子里建造水井（成本为1），然后将其他房子铺设管道连起来（成本为2），所以总成本为3 查看解析 class Solution { public int minCostToSupplyWater(int n, int[] wells, int[][] pipes) { int res = 0; var uf = new UnionFind(n + 1); var edges = new ArrayList&lt;int[]&gt;(); for (int i = 0; i &lt; n; ++i) { edges.add(new int[]{0, i + 1, wells[i]}); } for (int[] pipe : pipes) { edges.add(pipe); } Collections.sort(edges, (a, b) -&gt; a[2] - b[2]); for (int[] edge : edges) { int from = edge[0]; int to = edge[1]; if (!uf.isConnected(from, to)) { res += edge[2]; uf.union(from, to); } } return res; } class UnionFind { int[] parent; int[] rank; public UnionFind(int n) { parent = new int[n]; rank = new int[n]; for (int i = 0; i &lt; n; ++i) { parent[i] = i; rank[i] = 1; } } public int find(int x) { if (x != parent[x]) { parent[x] = find(parent[x]); } return parent[x]; } public void union(int x, int y) { int rootX = find(x); int rootY = find(y); if (rootX == rootY) { return; } if (rank[rootX] == rank[rootY]) { parent[rootX] = rootY; rank[rootX] += 1; } else if (rank[rootX] &lt; rank[rootY]) { parent[rootX] = rootY; } else { parent[rootY] = rootX; } } public boolean isConnected(int x, int y) { return find(x) == find(y); } } } .center { width: auto; display: table; margin-left: auto; margin-right: auto; }","categories":[{"name":"生活","slug":"生活","permalink":"http://goodguyjameswin.github.io/categories/生活/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://goodguyjameswin.github.io/tags/学习笔记/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"http://goodguyjameswin.github.io/categories/生活/"}]},{"title":"shape_based_matching","slug":"shape_based_matching","date":"2022-06-15T02:13:12.000Z","updated":"2022-07-18T04:18:06.919Z","comments":false,"path":"2022/06/15/shape_based_matching/","link":"","permalink":"http://goodguyjameswin.github.io/2022/06/15/shape_based_matching/","excerpt":"","text":"环境配置新建VS空工程，然后在VS-视图-属性管理器，配置opencv环境，VC++目录-包含目录添加： ..\\opencv\\build\\include ..\\opencv\\build\\include\\opencv ..\\opencv\\build\\include\\opencv2 VC++目录-库目录添加： ..\\opencv\\build\\x64\\vc15\\lib 链接器-输入-附加依赖项添加： opencv_world346d.lib 将原工程根目录下的源文件和头文件添加到新建VS工程里，修改fusion.h和line2Dup.h文件里的路径： #include &quot;MIPP/mipp.h&quot; // for SIMD in different platforms 修改test.cpp里的prefix变量路径，指向资源文件： static std::string prefix = &quot;../test/&quot;; api调用原作者分别对模板做了角度、尺度方面的测试，以及noise_test（NMS筛选）。这里假设模板是工业器件，且由于拍摄角度和器件摆放位置的随机性，需要简单写个my_test函数来调用api void my_test(string mode = &quot;test&quot;, bool use_rot = true) { int num_feature = 16; // 投票机制 line2Dup::Detector detector(num_feature, { 4, 8 }); if (mode != &quot;test&quot;) { Mat img = imread(prefix + &quot;case3/train.jpg&quot;); // 训练图片 // ... } else if (mode == &quot;test&quot;) { Mat test_img = imread(prefix + &quot;case3/ori.jpg&quot;); // 测试图片 // ... cv_dnn::NMSBoxes(boxes, scores, 90, 0, idxs); // 筛选阈值 // ... } } 效果训练 测试","categories":[{"name":"技术","slug":"技术","permalink":"http://goodguyjameswin.github.io/categories/技术/"}],"tags":[{"name":"开源项目","slug":"开源项目","permalink":"http://goodguyjameswin.github.io/tags/开源项目/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://goodguyjameswin.github.io/categories/技术/"}]},{"title":"mybatis-plus学习","slug":"mybatis-plus学习","date":"2022-06-10T08:16:21.000Z","updated":"2022-07-18T03:58:34.891Z","comments":false,"path":"2022/06/10/mybatis-plus学习/","link":"","permalink":"http://goodguyjameswin.github.io/2022/06/10/mybatis-plus学习/","excerpt":"","text":"构建工程Mybatis-Plus中文文档 入门新建Maven父工程，导入依赖： &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.24&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.h2database&lt;/groupId&gt; &lt;artifactId&gt;h2&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; resources目录下新建application.yml配置文件中添加H2数据库的相关配置： # DataSource Config spring: datasource: driver-class-name: org.h2.Driver schema: classpath:db/schema=h2.sql data: classpath:db/data-h2.sql url: jdbc:h2:mem:test username: root password: test 在 Spring Boot 启动类中添加 @MapperScan 注解，扫描 Mapper 文件夹： @SpringBootApplication @MapperScan(&quot;scan.your.mapper.package&quot;) public class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); } } Mapper包下的UserMapper接口只需要继承BaseMapper&lt;T&gt;类即可（泛型指定封装数据类型） 配置日志mybatis-plus: configuration: log-impl: org.apache.ibatis.logging.stdout.StdOutImpl 主键策略主键注解@TableId(&quot;AUTO&quot;)，设置数据库ID自增，用在实体类的主键字段，数据库对应列也应当设置为自增 自动填充功能注解填充字段 @TableField(.. fill = FieldFill.INSERT) public class User { @TableField(fill = FieldFill.INSERT) private String createTime; @TableField(fill = FieldFill.INSERT_UPDATE) private String updateTime; ... } 实现元对象处理器接口：com.baomidou.mybatisplus.core.handlers.MetaObjectHandler @Slf4j @Component public class MyMetaObjectHandler implements MetaObjectHandler { @Override public void insertFill(MetaObject metaObject) { log.info(&quot;start insert fill ....&quot;); this.setFieldValByName(&quot;createTime&quot;, new Date(), metaObject); this.setFieldValByName(&quot;updateTime&quot;, new Date(), metaObject) } @Override public void updateFill(MetaObject metaObject) { log.info(&quot;start update fill ....&quot;); this.setFieldValByName(&quot;updateTime&quot;, new Date(), metaObject) } } 乐观锁当要更新一条记录时，希望这条记录没有被别人更新，实现方式为： 去除记录时，获取当前version 更新时，带上这个 version 执行更新时， set version = newVersion where version = oldVersion 如果 version 不对，就更新失败 @Configuration @MapperScan(&quot;scan.your.mapper.package&quot;) public class MybatisPlusConfig { @Bean public MybatisPlusInterceptor mybatisPlusInterceptor() { MybatisPlusInterceptor mybatisPlusInterceptor = new MybatisPlusInterceptor(); mybatisPlusInterceptor.addInnerInterceptor(new OptimisticLockerInnerInterceptor()); return mybatisPlusInterceptor; } } 在对应的实体类字段上加上@Version注解即可 分页配置拦截器 @Configuration @MapperScan(&quot;scan.your.mapper.package&quot;) public class MybatisPlusConfig { /** * 新的分页插件,一缓和二缓遵循mybatis的规则,需要设置 MybatisConfiguration#useDeprecatedExecutor = false 避免缓存出现问题 */ @Bean public MybatisPlusInterceptor mybatisPlusInterceptor() { MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor(); interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.H2)); return interceptor; } @Bean public ConfigurationCustomizer configurationCustomizer() { return configuration -&gt; configuration.setUseDeprecatedExecutor(false); } } 直接使用Page对象即可 逻辑删除增加一个字段，标记用户对数据库中数据的删除操作，实际上数据库中的数据未被删除（实际上进行的是更新操作），类似于回收站，后续管理员可根据需要进行数据库的清理 配置application.yml或者编写配置类 mybatis-plus: global-config: db-config: logic-delete-field: flag # 全局逻辑删除的实体字段名(配置后可以忽略配置类) logic-delete-value: 1 # 逻辑已删除值(默认为 1) logic-not-delete-value: 0 # 逻辑未删除值(默认为 0) @Configuration @MapperScan(&quot;scan.your.mapper.package&quot;) public class MybatisPlusConfig { @Bean public ISqlInjector sqlInjector() { return new LogicSqlInjector(); } } 对应实体类字段上加上@TableLogic注解即可 性能分析SQL执行效率插件 @Configuration @MapperScan(&quot;scan.your.mapper.package&quot;) public class MybatisPlusConfig { @Bean @Profile({&quot;dev&quot;, &quot;test&quot;}) // 设置 dev test 环境开启，保证效率，注意在 SpringBoot 环境中配置 spring.profiles.active=dev/test public PerformanceInterceptor performanceInterceptor() { PerformanceInterceptor performanceInterceptor = new PerformanceInterceptor(); performanceInterceptor.setMaxTime(100); // ms 设置sql执行的最大时间，如果超过了则不执行 performanceInterceptor.setFormat(true); // 是否格式化代码 return performanceInterceptor; } } 条件构造器@Test void contextLoads() { QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;(); // 链式编程 wrapper .isNotNull(&quot;name&quot;) // name 不为空 .isNotNull(&quot;email&quot;) // 邮箱不为空 .ge(&quot;age&quot;, 12); // 年龄大于等于12 // wrapper // 模糊查询 // .notLike(&quot;name&quot;, &quot;e&quot;); // name NOT LIKE &#39;%e%&#39; // .likeRight(&quot;email&quot;, &quot;t&quot;); // email LIKE &#39;t%&#39; // wrapper // .inSql(&quot;id&quot;, &quot;select id from user where id &lt; 3&quot;) // 子查询 // .orderByDsc(&quot;id&quot;); // 根据 id 进行降序排序 userMapper.selectList(wrapper).forEach(System.out::println); } 代码生成器导入依赖 &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt; &lt;version&gt;最新版本&lt;/version&gt; &lt;/dependency&gt; FastAutoGenerator.create(&quot;url&quot;, &quot;username&quot;, &quot;password&quot;) .globalConfig(builder -&gt; { builder.author(&quot;baomidou&quot;) // 设置作者 .enableSwagger() // 开启 swagger 模式 .fileOverride() // 覆盖已生成文件 .outputDir(&quot;/src/main/java&quot;); // 指定输出目录 }) .packageConfig(builder -&gt; { builder.parent(&quot;com.baomidou.mybatisplus.samples.generator&quot;) // 设置父包名 .moduleName(&quot;system&quot;) // 设置父包模块名 .pathInfo(Collections.singletonMap(OutputFile.xml, &quot;D://&quot;)); // 设置mapperXml生成路径 }) .strategyConfig(builder -&gt; { builder.addInclude(&quot;user&quot;) // 设置需要生成的表名 .addTablePrefix(&quot;t_&quot;, &quot;c_&quot;); // 设置过滤表前缀 }) .templateEngine(new FreemarkerTemplateEngine()) // 使用Freemarker引擎模板，默认的是Velocity引擎模板 .execute();","categories":[{"name":"生活","slug":"生活","permalink":"http://goodguyjameswin.github.io/categories/生活/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://goodguyjameswin.github.io/tags/学习笔记/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"http://goodguyjameswin.github.io/categories/生活/"}]},{"title":"动态规划","slug":"动态规划","date":"2022-06-05T07:25:26.000Z","updated":"2022-08-03T04:41:48.272Z","comments":false,"path":"2022/06/05/动态规划/","link":"","permalink":"http://goodguyjameswin.github.io/2022/06/05/动态规划/","excerpt":"","text":"自底向上最优子结构由于遇到了重复的问题，每一阶段求解的结果应该被记录下来；更大规模问题的最优解参考了规模更小的子问题的最优解。 经典问题：给定不同面额的硬币coins和一个总金额amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回-1。 输入: coins = [1, 2, 5], amount = 11 输出: 3 解释: 11 = 5 + 5 + 1 public class Solution { public int coinChange(int[] coins, int amount) { // 给 0 占位 int[] dp = new int[amount + 1]; // 要求 恰好填满，所以初始化的时候需要赋值为一个不可能的值 // 初始化 Arrays.fill(dp, amount + 1); dp[0] = 0; // 递推开始 for (int i = 1; i &lt;= amount; i++) { for (int coin : coins) { if (i - coin &gt;= 0 &amp;&amp; dp[i - coin] != amount + 1) { dp[i] = Math.min(dp[i], 1 + dp[i - coin]); } } } // 如果不能凑出，根据题意返回 -1 if (dp[amount] == amount + 1) { dp[amount] = -1; } return dp[amount]; } } 思考：如何用贪心算法解决本题？ 查看解析 public int changeForGreedy(int[] coins, int amount) { // 将 coins 倒序排列 coins = IntStream.of(coins).boxed().sorted(Comparator.reverseOrder()).mapToInt(Integer::intValue).toArray(); int res = 0; int index = 0; // 贪心的点：尽可能多地优先选择面值大的纸币 while (amount &gt; 0) { // 这一步算出当前面值的纸币需要使用多少张 int count = amount / coins[index]; // 纸币数加入总数 res += count; // 扣除了当前使用掉的纸币以后还剩下多少金额 amount %= coins[index]; // 考虑下一种面额的纸币 index++; } return res; } 力扣343：给定一个正整数n，将其拆分为k个正整数的和（k&gt;=2），并使这些整数的乘积最大化。返回你可以获得的最大乘积。 输入: n = 2 输出: 1 解释: 2 = 1 + 1, 1 × 1 = 1。 查看解析 public class Solution { public int integerBreak(int n) { int[] dp = new int[n + 1]; // 初始化 dp[1] = 1; // 递推开始 for (int i = 2; i &lt;= n; i++) { // 其中一个加法因子至少是 1，最多是 i - 1 for (int j = 1; j &lt;= i - 1; j++) { dp[i] = Math.max(dp[i], Math.max(j * (i - j), j * dp[i - j])); } } return dp[n]; } } 无后效性经典问题：你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。 输入: [2, 7, 9, 3, 1] 输出: 12 解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。偷窃到的最高金额 = 2 + 9 + 1 = 12 。 public class Solution { public int rob(int[] nums) { int len = nums.length; if (len == 0) { return 0; } if (len == 1) { return nums[0]; } // dp[i][0]：考虑区间 [0..i] ，并且下标为 i 的这个房屋不偷 // dp[i][1]：考虑区间 [0..i] ，并且下标为 i 的这个房屋偷 int[][] dp = new int[len][2]; // 初始化 dp[0][0] = 0; dp[0][1] = nums[0]; // 递推开始 for (int i = 1; i &lt; len; i++) { // 前一个房屋偷或不偷，取两者最大值 dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1]); // 由于相邻的两个房屋不能同时偷取，只有左边房屋不偷，当前房屋才可以偷 dp[i][1] = dp[i - 1][0] + nums[i]; } return Math.max(dp[len - 1][0], dp[len - 1][1]); } } 力扣120：给定一个三角形triangle，找出自顶向下的最小路径和。 每一步只能移动到下一行中相邻的节点上。相邻的结点在这里指的是下标与上一层结点下标相同或等于上一层结点下标 + 1的两个节点。也就是说，如果正位于当前行的下标i，那么下一步可以移动到下一行的下标i或i + 1。 输入：triangle = [[2],[3,4],[6,5,7],[4,1,8,3]] 输出：11 解释：如下面简图所示： 2 3 4 6 5 7 4 1 8 3 自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。 查看解析 class Solution { public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) { int n = triangle.size(); // dp[i][j] 表示从点 (i, j) 到底边的最小路径和 int[] dp = new int[n + 1]; // 从三角形的最后一行开始递推 for (int i = n - 1; i &gt;= 0; i--) { for (int j = 0; j &lt;= i; j++) { // 列数与行号对应 dp[j] = Math.min(dp[j], dp[j + 1]) + triangle.get(i).get(j); } } return dp[0]; } } 经典问题：给定一个数组prices，它的第i个元素prices[i]表示一支给定股票第i天的价格。 你只能选择某一天买入这只股票，并选择在未来的某一个不同的日子卖出该股票。设计一个算法来计算你所能获取的最大利润。返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回0。 输入：[7,1,5,3,6,4] 输出：5 解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润= 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。 class Solution { public int maxProfit(int[] prices) { var dp = new int[2]; dp[0] = 0; dp[1] = -prices[0]; int len = prices.length; for (int i = 1; i &lt; len; ++i) { dp[0] = Math.max(dp[0], dp[1] + prices[i]); dp[1] = Math.max(dp[1], -prices[i]); // 注意只能交易一次 } return dp[0]; } } 思考：若你可以尽可能多地完成更多的交易，但是**卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)**，注意你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票），如何获取最大利润？ 查看解析 class Solution { public int maxProfit(int k, int[] prices) { int len = prices.length; var dp = new int[3]; Arrays.fill(dp, Integer.MIN_VALUE); // 其他不合法状态初始化为一个较大的负值 // dp[0][2] = −∞ ：第一天无法处于冷冻期，将不合法的状态初始化为一个较大的负值。 dp[0] = 0; // 第一天手上无股票，也没有购入股票 dp[1] = -prices[0]; // 第一天购入股票，花费 prices[0] // dp[i][0] 表示第 i 天结束时，手上 没有 股票且 处于非冷冻期 时的最大利润， // dp[i][1] 表示第 i 天结束时，手上 持有 股票时的最大利润。 // dp[i][2] 表示第 i 天结束时，手上 没有 股票且 处于冷冻期 时的最大利润（注意：第i天卖出，并随即进入冷冻期）。 for (int i = 1; i &lt; len; ++i) { int temp0 = dp[0]; int temp1 = dp[1]; int temp2 = dp[2]; dp[0] = Math.max(temp0, temp2); dp[1] = Math.max(temp1, temp0 - prices[i]); dp[2] = temp1 + prices[i]; } return Math.max(dp[0], dp[2]); } } 思考：若你有且仅有k次交易机会，注意你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票），如何获取最大利润？ 查看解析 class Solution { public int maxProfit(int k, int[] prices) { int len = prices.length; if (len &lt; 1 || k &lt; 1) { return 0; } var dp = new int[k + 1][2]; for (int[] d : dp) { Arrays.fill(d, Integer.MIN_VALUE); // 其他不合法状态初始化为一个较大的负值 } dp[0][0] = 0; // 第一天手上无股票，也没有购入股票，也就是未进行交易 dp[1][1] = -prices[0]; // 第一天购入股票，也是第一次交易 int max = 0; // dp[i][j][0] 表示第 i 天交易完，j 次交易（卖出）股票后，手上 没有 股票时的累计最大利润 // dp[i][j][1] 表示第 i 天交易完，j 次交易（买入）股票后，手上 持有 股票时的累计最大利润 for (int i = 1; i &lt; len; ++i) { for (int j = 1; j &lt;= k; ++j) { // 因为只有先第 j 次买了股票后才能第 j 次卖掉该股票 dp[j][0] = Math.max(dp[j][0], dp[j][1] + prices[i]); // 因为只有将第 j-1 次买的股票卖出后才能第 j 次再次购买股票 dp[j][1] = Math.max(dp[j][1], dp[j - 1][0] - prices[i]); max = Math.max(dp[j][0], max); } } return max; } } 线性DP问题经典问题：给定一个整数数组nums，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 输入: [-2, 1, -3, 4, -1, 2, 1, -5, 4] 输出: 6 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 public class Solution { public int maxSubArray(int[] nums) { int len = nums.length; if (len == 0) { return 0; } // 起名叫 pre 表示的意思是「上一个状态的值」 int pre = nums[0]; int res = pre; for (int i = 1; i &lt; len; i++) { pre = Math.max(nums[i], pre + nums[i]); res = Math.max(res, pre); } return res; } } 思考：若数组nums的末端将会与开头相连呈环状，那么如何求得其非空子数组的最大和？ 查看解析 // 最大的环形子数组和 = max(最大子数组和，数组总和-最小子数组和) public int maxSubarraySumCircular(int[] A) { int total = 0, maxSum = A[0], curMax = 0, minSum = A[0], curMin = 0; for (int a : A) { curMax = Math.max(curMax + a, a); maxSum = Math.max(maxSum, curMax); curMin = Math.min(curMin + a, a); minSum = Math.min(minSum, curMin); total += a; } return maxSum &gt; 0 ? Math.max(maxSum, total - minSum) : maxSum; } 力扣845：把符合下列属性的数组arr称为山脉数组： arr.length &gt;= 3 存在下标i（0 &lt; i &lt; arr.length - 1），满足: arr[0] &lt; arr[1] &lt; ... &lt; arr[i - 1] &lt; arr[i]且arr[i] &gt; arr[i + 1] &gt; ... &gt; arr[arr.length - 1]给出一个整数数组arr，返回最长山脉子数组的长度。如果不存在山脉子数组，返回 0 。 输入：arr = [2,1,4,7,3,2,5] 输出：5 解释：最长的山脉子数组是 [1,4,7,3,2]，长度为 5。 查看解析 class Solution { public int longestMountain(int[] arr) { int n = arr.length; if (n == 0) { return 0; } int[] left = new int[n]; for (int i = 1; i &lt; n; ++i) { left[i] = arr[i - 1] &lt; arr[i] ? left[i - 1] + 1 : 0; } int[] right = new int[n]; for (int i = n - 2; i &gt;= 0; --i) { right[i] = arr[i + 1] &lt; arr[i] ? right[i + 1] + 1 : 0; } int ans = 0; for (int i = 0; i &lt; n; ++i) { if (left[i] &gt; 0 &amp;&amp; right[i] &gt; 0) { ans = Math.max(ans, left[i] + right[i] + 1); } } return ans; } } 双序列DP问题经典问题：在两条独立的水平线上按给定的顺序写下 nums1 和 nums2 中的整数。现在，可以绘制一些连接两个数字 nums1[i] 和 nums2[j] 的直线，这些直线需要同时满足满足： nums1[i] == nums2[j] 且绘制的直线不与任何其他连线（非水平线）相交。请注意，连线即使在端点也不能相交：每个数字只能属于一条连线。以这种方法绘制线条，并返回可以绘制的最大连线数。 输入：nums1 = [1,4,2], nums2 = [1,2,4] 输出：2 解释：可以画出两条不交叉的线，如上图所示。但无法画出第三条不相交的直线，因为从 nums1[1]=4 到 nums2[2]=4 的直线将与从 nums1[2]=2 到 nums2[1]=2 的直线相交。 class Solution { // 分割区域 public int maxUncrossedLines(int[] nums1, int[] nums2) { int m = nums1.length, n = nums2.length; var dp = new int[m + 1][n + 1]; // 初始化 for (int i = 0; i &lt;= m; i++) { dp[i][0] = 0; } for (int j = 0; j &lt;= n; j++) { dp[0][j] = 0; } for (int i = 1; i &lt;= m; ++i) { for (int j = 1; j &lt;= n; ++j) { if (nums1[i - 1] == nums2[j - 1]) { dp[i][j] = dp[i - 1][j - 1] + 1; } else { dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]); } } } return dp[m][n]; } } 力扣97：给定三个字符串s1、s2、s3，请你帮忙验证s3是否是由s1和s2交错组成的。 两个字符串s和t交错的定义与过程如下，其中每个字符串都会被分割成若干非空子字符串： s = s1 + s2 + ... + sn t = t1 + t2 + ... + tm |n - m| &lt;= 1 交错是s1 + t1 + s2 + t2 + s3 + t3 + ...或者t1 + s1 + t2 + s2 + t3 + s3 + ...注意：a + b意味着字符串a和b连接。 输入：s1 = “aabcc”, s2 = “dbbca”, s3 = “aadbbcbcac” 输出：true 查看解析 class Solution { public boolean isInterleave(String s1, String s2, String s3) { int n = s1.length(), m = s2.length(), t = s3.length(); if (n + m != t) { return false; } // 定义 f(i,j) 表示 s1 的前 i 个元素和 s2 的前 j 个元素是否能交错组成 s3 的前 i+j 个元素 boolean[][] f = new boolean[n + 1][m + 1]; f[0][0] = true; for (int i = 0; i &lt;= n; ++i) { for (int j = 0; j &lt;= m; ++j) { int p = i + j - 1; if (i &gt; 0) { // 表示 s1 的前 i-1 个元素和 s2 的前 j 个元素是否能交错组成 s3 的前 i+j-1 个元素 f[i][j] = f[i][j] || (f[i - 1][j] &amp;&amp; s1.charAt(i - 1) == s3.charAt(p)); } if (j &gt; 0) { // // 表示 s1 的前 i 个元素和 s2 的前 j-1 个元素是否能交错组成 s3 的前 i+j-1 个元素 f[i][j] = f[i][j] || (f[i][j - 1] &amp;&amp; s2.charAt(j - 1) == s3.charAt(p)); } } } return f[n][m]; } } 力扣115：给定一个字符串s和一个字符串t，计算在s的子序列中t出现的个数。 字符串的一个子序列是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，&quot;ACE&quot;是&quot;ABCDE&quot;的一个子序列，而AEC不是）。题目数据保证答案符合32位带符号整数范围。 输入：s = “rabbbit”, t = “rabbit” 输出：3 解释： 如下图所示, 有 3 种可以从 s 中得到 “rabbit” 的方案。 rabbbit rabbbit rabbbit 查看解析 class Solution { public int numDistinct(String s, String t) { if(t.length() &gt; s.length()) return 0; // s长度小于t时间直接返回0 int sn = s.length(), tn = t.length(); int[][] dp = new int[sn + 1][tn + 1]; // 注意数组大小由dp定义决定 for(int i = 0; i &lt; sn + 1; i++) dp[i][0] = 1; // 边界 for(int i = 1; i &lt; sn + 1; i++){ for(int j = 1; j &lt; tn + 1; j++){ //若s[i] = t[j]：假设s_i中的所有t_j子序列中，包含s[i]的有a个，不包含的有b个。s_i中包含s[i]的子序列个数相当于s_i-1中t_j-1的个数，不包含s[i]的子序列个数与上一种情况一样，于是得到该情形的转移方程： if(s.charAt(i-1) == t.charAt(j-1)) dp[i][j] = dp[i-1][j-1] + dp[i-1][j]; //若s[i] ≠ t[j]：那么s_i中的所有t_j子序列，必不包含s[i]，即s_i-1和s_i中tj的数量是一样的，得到该情形的转移方程: else dp[i][j] = dp[i-1][j]; } } return dp[sn][tn]; } } 经典问题：给你一个字符串s和一个字符规律p，请你来实现一个支持&#39;.&#39;和&#39;*&#39;的正则表达式匹配。 &#39;.&#39;匹配任意单个字符 &#39;*&#39;匹配零个或多个前面的那一个元素所有匹配，是要涵盖整个字符串s的，而不是部分字符串。 输入：s = “ab”, p = “.*” 输出：true 解释：”.“ 表示可匹配零个或多个（’‘）任意字符（’.’）。 class Solution { public boolean isMatch(String s, String p) { int m = s.length(); int n = p.length(); // f[i][j]表示 s 的前 i 个字符与 P 中的前 j 个字符是否能够匹配 boolean[][] f = new boolean[m + 1][n + 1]; f[0][0] = true; for (int i = 0; i &lt;= m; ++i) { for (int j = 1; j &lt;= n; ++j) { if (p.charAt(j - 1) == &#39;*&#39;) { // 将组合扔掉，不再进行匹配 f[i][j] = f[i][j - 2]; if (matches(s, p, i, j - 1)) { // 匹配 s 末尾的一个字符，将该字符扔掉，而该组合还可以继续进行匹配 f[i][j] = f[i][j] || f[i - 1][j]; } } else { // 匹配一个字母 if (matches(s, p, i, j)) { f[i][j] = f[i - 1][j - 1]; } } } } return f[m][n]; } public boolean matches(String s, String p, int i, int j) { if (i == 0) { return false; } if (p.charAt(j - 1) == &#39;.&#39;) { return true; } return s.charAt(i - 1) == p.charAt(j - 1); } } 力扣72：给你两个单词word1和word2，请返回将word1转换成word2所使用的最少操作数。你可以对一个单词进行如下三种操作： 插入一个字符 删除一个字符 替换一个字符 输入：word1 = “intention”, word2 = “execution” 输出：5 解释： intention -&gt; inention (删除 ‘t’) inention -&gt; enention (将 ‘i’ 替换为 ‘e’) enention -&gt; exention (将 ‘n’ 替换为 ‘x’) exention -&gt; exection (将 ‘n’ 替换为 ‘c’) exection -&gt; execution (插入 ‘u’) 查看解析 class Solution { public int minDistance(String word1, String word2) { int len1 = word1.length(); int len2 = word2.length(); int[][] dp = new int[len1 + 1][len2 + 1]; // 插入操作 for(int i = 1; i &lt;= len1; i++) { dp[i][0] = dp[i - 1][0] + 1; } // 删除操作 for(int j = 1;j &lt;= len2; j++) { dp[0][j] = dp[0][j - 1] + 1; } for(int i = 1; i &lt;= len1; i++) { for(int j = 1; j &lt;= len2; j++) { // 删除操作：dp[i - 1][j] // 增加操作：dp[i][j - 1] // 替换操作：dp[i - 1][j - 1] dp[i][j] = Math.min(dp[i - 1][j], Math.min(dp[i - 1][j - 1], dp[i][j - 1])) + 1; if(word1.charAt(i - 1) == word2.charAt(j - 1)) { dp[i][j] = Math.min(dp[i][j], dp[i - 1][j - 1]); } } } return dp[len1][len2]; } } 区间DP和划分型DP问题经典问题：给你一个字符串s，找出其中最长的回文子序列，并返回该序列的长度。 子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。 输入：s = “bbbab” 输出：4 解释：一个可能的最长回文子序列为 “bbbb” 。 class Solution { public int longestPalindromeSubseq(String s) { int n = s.length(); int[][] dp = new int[n][n]; for (int i = n - 1; i &gt;= 0; i--) { dp[i][i] = 1; char c1 = s.charAt(i); for (int j = i + 1; j &lt; n; j++) { char c2 = s.charAt(j); if (c1 == c2) { dp[i][j] = dp[i + 1][j - 1] + 2; } else { dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]); } } } return dp[0][n - 1]; } } 经典问题：有n个气球，编号为0到n - 1，每个气球上都标有一个数字，这些数字存在数组nums中。 现在要求你戳破所有的气球。戳破第i个气球，你可以获得nums[i - 1] * nums[i] * nums[i + 1]枚硬币。 这里的i - 1和i + 1代表和i相邻的两个气球的序号。如果i - 1或i + 1超出了数组的边界，那么就当它是一个数字为1的气球。 求所能获得硬币的最大数量。 输入：nums = [3,1,5,8] 输出：167 解释： nums = [3,1,5,8] –&gt; [3,5,8] –&gt; [3,8] –&gt; [8] –&gt; [] coins = 315 + 358 + 138 + 181 = 167 public class Solution { public int maxCoins(int[] nums) { int len = nums.length; // 预处理 int[] newNums = new int[len + 2]; newNums[0] = 1; newNums[len + 1] = 1; System.arraycopy(nums, 0, newNums, 1, len); nums = newNums; // 第一维是左边界下标，第二维是右边界下标 int[][] dp = new int[len + 2][len + 2]; // 递推开始 // 先枚举长度 for (int L = 1; L &lt;= len; L++) { // i 是左边界 for (int i = 1; i &lt;= len - L + 1; i++) { // j 是 i 和 L 确定的情况下，右边界 int j = i + L - 1; // 枚举每一个位置，把气球编号 k 当做区间内最后一个被戳破的气球 for (int k = i; k &lt;= j; k++) { dp[i][j] = Math.max(dp[i][j], dp[i][k - 1] + nums[i - 1] * nums[k] * nums[j + 1] + dp[k + 1][j]); } } } return dp[1][len]; } } 经典问题：给你一个整数数组nums。玩家 1 和玩家 2 基于这个数组设计了一个游戏。 玩家 1 和玩家 2 轮流进行自己的回合，玩家 1 先手。开始时，两个玩家的初始分值都是 0 。每一回合，玩家从数组的任意一端取一个数字（即，nums[0] 或 nums[nums.length - 1]），取到的数字将会从数组中移除（数组长度减 1 ）。玩家选中的数字将会加到他的得分上。当数组中没有剩余数字可取时，游戏结束。 如果玩家 1 能成为赢家，返回true。如果两个玩家得分相等，同样认为玩家 1 是游戏的赢家，也返回true。你可以假设每个玩家的玩法都会使他的分数最大化。 输入：nums = [1,5,233,7] 输出：true 解释：玩家 1 一开始选择 1 。然后玩家 2 必须从 5 和 7 中进行选择。无论玩家 2 选择了哪个，玩家 1 都可以选择 233 。最终，玩家 1（234 分）比玩家 2（12 分）获得更多的分数，所以返回 true，表示玩家 1 可以成为赢家。 class Solution { public boolean PredictTheWinner(int[] nums) { int length = nums.length; // dp[i][j] 表示当数组剩下的部分为下标 i 到下标 j 时，即在下标范围 [i, j][i,j] 中，当前玩家与另一个玩家的分数之差的最大值，注意当前玩家不一定是先手 int[][] dp = new int[length][length]; // 只剩一个数字时，当前玩家只能拿这个数字 for (int i = 0; i &lt; length; i++) { dp[i][i] = nums[i]; } // 当 i&lt;j 时，当前玩家可以选择 nums[i] 或 nums[j]，然后轮到另一个玩家在数组剩下的部分选取数字。在两种方案中，当前玩家会选择最优的方案，使得自己的分数最大化 for (int i = length - 2; i &gt;= 0; i--) { for (int j = i + 1; j &lt; length; j++) { dp[i][j] = Math.max(nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1]); } } return dp[0][length - 1] &gt;= 0; } } 经典问题：给你一个字符串s，请你将s分割成一些子串，使每个子串都是回文。返回符合要求的最少分割次数。 输入：s = “aab” 输出：1 解释：只需一次分割就可将 s 分割成 [“aa”,”b”] 这样两个回文子串。 // 枚举最后一个回文串的起始位置 j+1，保证 s[j+1..i] 是一个回文串，那么 f[i] 就可以从 f[j] 转移而来，附加 1 次额外的分割次数。 class Solution { public int minCut(String s) { int n = s.length(); boolean[][] g = new boolean[n][n]; for (int i = 0; i &lt; n; ++i) { Arrays.fill(g[i], true); } // 将字符串 s 的每个子串是否为回文串预先计算出来 for (int i = n - 1; i &gt;= 0; --i) { for (int j = i + 1; j &lt; n; ++j) { g[i][j] = s.charAt(i) == s.charAt(j) &amp;&amp; g[i + 1][j - 1]; } } // f[i] 表示字符串的前缀 s[0..i] 的最少分割次数 int[] f = new int[n]; Arrays.fill(f, Integer.MAX_VALUE); for (int i = 0; i &lt; n; ++i) { if (g[0][i]) { f[i] = 0; } else { for (int j = 0; j &lt; i; ++j) { if (g[j + 1][i]) { f[i] = Math.min(f[i], f[j] + 1); } } } } return f[n - 1]; } } 力扣410：给定一个非负整数数组nums和一个整数m，你需要将这个数组分成m个非空的连续子数组。 设计一个算法使得这m个子数组各自和的最大值最小。 输入：nums = [7,2,5,10,8], m = 2 输出：18 解释：一共有四种方法将 nums 分割为 2 个子数组。其中最好的方式是将其分为 [7,2,5] 和 [10,8]。因为此时这两个子数组各自的和的最大值为 18，在所有情况中最小。 查看解析 public class Solution { public int splitArray(int[] nums, int m) { int len = nums.length; // 前缀和，preSum[i] = sum[0..i) int[] preSum = new int[len + 1]; preSum[0] = 0; for (int i = 0; i &lt; len; i++) { preSum[i + 1] = preSum[i] + nums[i]; } // 区间 [i..j] 的和 preSum(j + 1) - preSum(i) int[][] dp = new int[len][m + 1]; // 初始化：由于要找最小值，初值赋值成为一个不可能达到的很大的值 for (int i = 0; i &lt; len; i++) { Arrays.fill(dp[i], Integer.MAX_VALUE); } // 分割数为 1 ，即不分割的情况，所有的前缀和就是依次的状态值 for (int i = 0; i &lt; len; i++) { dp[i][1] = preSum[i + 1]; } // 从分割数为 2 开始递推 for (int k = 2; k &lt;= m; k++) { // 还未计算出的 i 是从 j 的最小值的下一位开始，因此是 k - 1 for (int i = k - 1; i &lt; len; i++) { // j 表示第 k - 1 个区间的最后一个元素额下标，最小值为 k - 2，最大值为 len - 2（最后一个区间至少有 1 个元素） for (int j = k - 2; j &lt; i; j++) { dp[i][k] = Math.min(dp[i][k], Math.max(dp[j][k - 1], preSum[i + 1] - preSum[j + 1])); } } } return dp[len - 1][m]; } } 树形DP问题经典问题：在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为「根」。 除了「根」之外，每栋房子有且只有一个「父」房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。 计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。 输入: [3, 4, 5, 1, 3, null, 1] 3 / \\ 4 5 / \\ \\ 1 3 1 输出: 9 解释: 小偷一晚能够盗取的最高金额 = 4 + 5 = 9. public class Solution { public int rob(TreeNode root) { int[] res = dfs(root); return Math.max(res[0], res[1]); } private int[] dfs(TreeNode root) { if (root == null) { return new int[2]; } // 分类讨论的标准是：当前结点偷或者不偷 // 需要后序遍历，所以先计算左右子结点，然后计算当前结点的状态值 int[] left = dfs(root.left); int[] right = dfs(root.right); // dp[0]：以当前 node 为根结点的子树能够偷取的最大价值，规定 node 结点不偷 // dp[1]：以当前 node 为根结点的子树能够偷取的最大价值，规定 node 结点偷 int[] dp = new int[2]; // 根结点不打劫 = max(左子树不打劫, 左子树打劫) + max(右子树不打劫, 右子树打劫) dp[0] = Math.max(left[0], left[1]) + Math.max(right[0], right[1]); // 根结点打劫 = 左右孩子结点都不能打劫 dp[1] = left[0] + right[0] + root.val; return dp; } } 力扣865：给定一个根为root的二叉树，每个节点的深度是该节点到根的最短距离。返回包含原始树中所有最深节点的最小子树。如果一个节点在整个树的任意节点之间具有最大的深度，则该节点是最深的。一个节点的子树是该节点加上它的所有后代的集合。 输入：root = [3,5,1,6,2,0,8,null,null,7,4] 输出：[2,7,4] 解释：我们返回值为 2 的节点，在图中用黄色标记。在图中用蓝色标记的是树的最深的节点。注意，节点 5、3 和 2 包含树中最深的节点，但节点 2 的子树最小，因此我们返回它。 查看解析 class Solution { // 思路：从每个树开始，获得当前节点的左右子树的最大深度 // 深度相同，说明最深的节点在这个节点两边，那这个节点就是结果 // 如果深度不相同，则去深度大的子树继续判断，最终就能得到结果 public TreeNode subtreeWithAllDeepest(TreeNode root) { if (root == null) return root; // 获取当前节点的左右子树的最大深度 int leftMaxDepth = getMaxDepth(root.left); int rightMaxDepth = getMaxDepth(root.right); // 如果两边最大深度相同，则这个节点就是结果 if (leftMaxDepth == rightMaxDepth) return root; // 不相等，那就去深度大的子树那边继续找 if (leftMaxDepth &gt; rightMaxDepth){ return subtreeWithAllDeepest(root.left); } return subtreeWithAllDeepest(root.right); } public int getMaxDepth(TreeNode root){ if (root == null) return 0; return Math.max(getMaxDepth(root.left), getMaxDepth(root.right)) + 1; } } 背包问题0-1背包问题有若干个物品，每个物品有两个属性：价值和重量。现在考虑将这些物品装入一个容器，称为背包，背包只有一个属性：最大承重，每个物品只有一件。问如何选择物品，使得所选物品的重量总和在不超过背包的最大承重的前提下，这些物品的价值总和最大。 为满足无后效性，有约束可以在状态数组的后面增加一维。对于下标为i的物品，有选和不选两种方案，选出两者中较好的即可。 public class Solution { public int backpack01(int W, int[] weights, int[] values) { int N = weights.length; if (N == 0) { return 0; } // dp[i][j] 表示：考虑物品区间 [0..i] 里，不超过背包容量，能够获得的最大价值 int[][] dp = new int[N + 1][W + 1]; // 递推开始，以 dp 数组为视角，从 1 开始，到 N 为止 // 注意：遇到物品的下标都减 1 for (int i = 1; i &lt;= N; i++) { for (int j = 0; j &lt;= W; j++) { // 下标为 i 的行参考了下标为 i - 1 的行的状态值。为了让 i - 1 &gt;= 0，下标为 0 的行需要初始化。事实上，可以将状态二维数组多设置一行，表示 添加了一个重量为 0、价值为 0 的物品，计算结果与原问题等价 dp[i][j] = dp[i - 1][j]; if (weights[i - 1] &lt;= j) { dp[i][j] = Math.max(dp[i][j], dp[i - 1][j - weights[i - 1]] + values[i - 1]); } } } return dp[N][W]; } } 空间优化方法：状态值的更新只和它上边和左边的元素有关，我们可以把空间投影到一行，执行状态转移（填表）的时候，从右边到左边更新状态值，从而保证新状态值得计算可以参考到正确得旧状态值。 public class Solution { public int backpack01(int W, int[] weights, int[] values) { int N = weights.length; if (N == 0) { return 0; } int[] dp = new int[W + 1]; // 注意：这里 i 从 1 开始，到 N 结束，N 可以取到 for (int i = 1; i &lt;= N; i++) { for (int j = W; j &gt;= weights[i - 1]; j--) { dp[j] = Math.max(dp[j], dp[j - weights[i - 1]] + values[i - 1]); } } return dp[W]; } } 力扣474：给你一个二进制字符串数组strs和两个整数m和n。请你找出返回strs的最大子集的长度，该子集中最多有m个0和n个1。如果x的所有元素也是y的元素，集合x是集合y的子集。 输入：strs = [“10”,”0001”,”111001”,”1”,”0”], m = 5, n = 3 输出：4 解释：最多有 5 个 0 和 3 个 1 的最大子集是 {“10”,”0001”,”1”,”0”}，因此答案是 4。其他满足题意但较小的子集包括 {“0001”,”1”} 和 {“10”,”1”,”0”}。{“1110001”} 不满足题意，因为它包含 4 个 1，大于 n 的值 3。 查看解析 public class Solution { public int findMaxForm(String[] strs, int m, int n) { int len = strs.length; int[][][] dp = new int[len + 1][m + 1][n + 1]; // 阶段 for (int i = 1; i &lt;= len; i++) { int[] cnt = countZeroAndOne(strs[i - 1]); // 状态 1 for (int j = 0; j &lt;= m; j++) { // 状态 2 for (int k = 0; k &lt;= n; k++) { // 按照「0-1 背包问题」的状态转移过程，先把上一行的值抄下来 dp[i][j][k] = dp[i - 1][j][k]; int zeros = cnt[0]; int ones = cnt[1]; // 决策 if (j &gt;= zeros &amp;&amp; k &gt;= ones) { dp[i][j][k] = Math.max(dp[i - 1][j][k], dp[i - 1][j - zeros][k - ones] + 1); } } } } return dp[len][m][n]; } /** * 分别统计每个单词 0 和 1 出现的次数 * * @param str * @return */ private int[] countZeroAndOne(String str) { int[] counter = new int[2]; for (char c : str.toCharArray()) { counter[c - &#39;0&#39;]++; } return counter; } } 还有一类问题要求恰好能够装满总重量为 j 的背包，需要区分清楚恰好能够装满和装入不超过背包容量的物品的区别 经典问题：给你一个只包含正整数得非空数组nums。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。 输入：nums = [1,5,11,15] 输出：true 解释：数组可以分割成 [1,5,5] 和 [11]。 public class Solution { public boolean canPartition(int[] nums) { int len = nums.length; // Java8 以后推出的流式语法求数组所有元素的和 int sum = Arrays.stream(nums).sum(); // 如果输入数组所有元素的和为奇数，一定找不到这样的子集 if (sum % 2 != 0) { return false; } // 背包的总重量 int target = sum / 2; // dp[i][j]：前缀区间 [0..i] 里是否有一部分元素的和恰好为 j boolean[][] dp = new boolean[len][target + 1]; // 初始化：nums[0] 只能填满容积为 nums[0] 的背包 if (nums[0] &lt;= target) { dp[0][nums[0]] = true; } // 递推开始 for (int i = 1; i &lt; len; i++) { for (int j = 0; j &lt;= target; j++) { // 不选：把上一行照抄下来 dp[i][j] = dp[i - 1][j]; if (nums[i] &lt;= j) { // 选：二者之中有一个为 true 即可 dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i]]; } } // 如果某一行最后一列为 true，最后一行最后一列一定为 true，提前终止程序 if (dp[i][target]) { return true; } } return dp[len - 1][target]; } } 力扣494：有一堆石头，每块石头的重量都是正整数。每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为x和y，且x &lt;= y。那么粉碎的可能结果如下： 如果x == y，那么两块石头都会被完全粉碎； 如果x != y，那么重量为x的石头将会完全粉碎，而重量为y的石头新重量为y-x 最后，最多只会剩下一块石头。返回此石头最小的可能重量。如果没有石头剩下，就返回0。 输入：[2,7,4,1,8,1] 输出：1 解释： 组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]， 组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]， 组合 2 和 1，得到 1，所以数组转化为 [1,1,1]， 组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。 查看解析 转换为0-1背包问题：sum（所有添加正号的数） + sum（所有添加负号的数） = sum；sum（所有添加正号的数） - sum（所有添加负号的数） = target。两式相减得到2 * sum(所有添加负号的数) = sum - target，因为target &gt;= 0，所以得到约束条件sum(所有添加负号的数) &lt;= sum / 2。因此问题转化为：从输入数组中找出一些数，每个数只能使用一次，并且这些数的和不能超过sum / 2，并且它们的「和」最大，这样才能使得target = sum - 2 * sum(所有添加负号的数)的值最小。 public class Solution { public int lastStoneWeightII(int[] stones) { int len = stones.length; int sum = Arrays.stream(stones).sum(); int target = sum / 2; // dp[i][j] 表示：从输入数组的前缀区间 [0..i] 里取出一部分元素，并且和小于等于 j 的最大值 int[][] dp = new int[len][target + 1]; // 初始化 for (int j = stones[0]; j &lt;= target; j++) { dp[0][j] = stones[0]; } // 递推开始 for (int i = 1; i &lt; len; i++) { for (int j = 0; j &lt;= target; j++) { if (stones[i] &gt; j) { dp[i][j] = dp[i - 1][j]; } else { // 状态转移方程：注意分析这里为什么取最大值 dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - stones[i]] + stones[i]); } } } // dp[len - 1][target] 最大，整体就最小 return sum - 2 * dp[len - 1][target]; } } 完全背包问题重点在于： 每种物品都有无限件可用 一种物品可以使用多个，且不计算顺序 状态转移的时候，每一件物品在背包有限制的前提下可以使用多少个需要全部考虑进去，如果将每一种物品可以考虑的件数平铺开来，就可以转换成为0-1背包问题。dp[i][j] = max(dp[i-1][j], dp[i][j-w[i]] + v[i]) public class Solution { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); // 读第 1 行 int N = scanner.nextInt(); int V = scanner.nextInt(); // 读后面的体积和价值 int[] weight = new int[N]; int[] value = new int[N]; for (int i = 0; i &lt; N; i++) { weight[i] = scanner.nextInt(); value[i] = scanner.nextInt(); } int[] dp = new int[V + 1]; // 先写第 1 行 // 优化空间 for (int i = 1; i &lt;= N; i++) { // 细节，j 从 weight[i - 1] 开始遍历 for (int j = weight[i - 1]; j &lt;= V; j++) { // 完全背包问题中，当前状态参考当前行的值，所以优化空间采用正序填表 dp[j] = Math.max(dp[j], dp[j - weight[i - 1]] + value[i - 1]); } } // 输出 System.out.println(dp[V]); } } 力扣322：给你一个整数数组cost和一个整数target。请你返回满足如下规则可以得到的最大整数： 给当前结果添加一个数位i + 1的成本为cost[i]（cost数组下标从 0 开始）。 总成本必须恰好等于target。 添加的数位中没有数字 0 。 由于答案可能会很大，请你以字符串形式返回。如果按照上述要求无法得到任何整数，请你返回 “0” 。 输入：cost = [7,6,5,5,5,6,8,7,8], target = 12 输出：”85” 解释：添加数位 ‘8’ 的成本是 7 ，添加数位 ‘5’ 的成本是 5 。”85” 的成本为 7 + 5 = 12 。 查看解析 public class Solution { public String largestNumber(int[] cost, int target) { // 第 1 步：使用动态规划计算最大位数 // dp[i][j] 表示：使用 cost 前缀区间 [0..i] 里的元素能够刚好凑成和为 j 的时候的数字的最大位数 int[][] dp = new int[9][target + 1]; for (int i = 0; i &lt; 9; i++) { Arrays.fill(dp[i], -1); } // 初始化 dp[0][0] = 0; for (int j = cost[0]; j &lt;= target; j++) { if (dp[0][j - cost[0]] != -1) { dp[0][j] = dp[0][j - cost[0]] + 1; } } // 一个数一个数考虑，因此外层循环是 cost for (int i = 1; i &lt; 9; i++) { for (int j = 0; j &lt;= target; j++) { dp[i][j] = dp[i - 1][j]; if (cost[i] &lt;= j &amp;&amp; dp[i][j - cost[i]] != -1) { dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - cost[i]] + 1); } } } // 判断是否有结果 if (dp[8][target] == -1) { return &quot;0&quot;; } // 第 2 步：根据第 1 步计算的结果，优先考虑数值大的放在高位，还原最大整数 int t = target; // 最大整数的位数 int len = dp[8][target]; StringBuilder res = new StringBuilder(); int i = 8; while (t &gt; 0) { // 这一步选谁 int num = -1; // 倒着选，如果正着选会选出最小值 for (int j = 9; j &gt;= 1; j--) { if (t &gt;= cost[j - 1] &amp;&amp; dp[i][t - cost[j - 1]] == len - 1) { num = j; break; } } res.append(num); t -= cost[num - 1]; len--; } return res.toString(); } } .center { width: auto; display: table; margin-left: auto; margin-right: auto; }","categories":[{"name":"思维","slug":"思维","permalink":"http://goodguyjameswin.github.io/categories/思维/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://goodguyjameswin.github.io/tags/学习笔记/"}],"keywords":[{"name":"思维","slug":"思维","permalink":"http://goodguyjameswin.github.io/categories/思维/"}]},{"title":"DiyTomcat","slug":"diytomcat","date":"2022-06-01T07:35:38.000Z","updated":"2022-07-18T04:19:19.634Z","comments":false,"path":"2022/06/01/diytomcat/","link":"","permalink":"http://goodguyjameswin.github.io/2022/06/01/diytomcat/","excerpt":"","text":"内容部分转载自how2j实践项目，自学笔记，仅作学习交流用 Hello diyTomcat通过socket可简单模拟浏览器和服务端通信： while (true) { // 外套循环，表示处理掉一个Socket连接请求之后，再处理下一个连接请求 Socket s = ss.accept(); // 表示收到浏览器客户端的请求 InputStream is = s.getInputStream(); // ... is.read(buffer); String requestString = new String(buffer, StandardCharsets.UTF_8); System.out.println(&quot;浏览器的输入信息：\\r\\n&quot; + requestString); OutputStream os = s.getOutputStream(); // 因为作为web服务器和浏览器之间通信，需要遵循http协议 String response_head = &quot;HTTP/1.1 200 Ok\\r\\n&quot; + &quot;Content-Type:text/html\\r\\n\\r\\n&quot;; // ... os.write(responseString.getBytes()); s.close(); } MiniBrowser实现一个迷你浏览器，浏览器主要用于获取html内容和响应头信息，关键在于通过socket发送http协议给服务端： public static byte[] getHttpBytes(String url) { URL u = new URL(url); int port = u.getPort(); InetSocketAddress inetSocketAddress = new InetSocketAddress(u.getHost(), port); client.connect(inetSocketAddress, 1000); // 浏览器（客户端）与服务端建立连接 Map&lt;String,String&gt; requestHeaders = new HashMap&lt;&gt;(); // ... httpRequestString.append(&quot;GET&quot; + u.getPath() + &quot; HTTP/1.1\\r\\n&quot;); // ... PrintWriter pWriter = new PrintWriter(client.getOutputStream(), true); pWriter.println(httpRequestString); // 浏览器发送请求 InputStream is = client.getInputStream(); // 接受回传数据 ByteArrayOutputStream baos = new ByteArrayOutputStream(); byte buffer[] = new byte[1024]; while(true) { // 服务端回传过来的信息很有可能长度不是刚好1024，如果超过或者低于都会存在信息丢失，故采用循环读取 int length = is.read(buffer); if(-1==length) break; baos.write(buffer, 0, length); if(length!=buffer_size) break; } } Request和Response对象request对象用于解析http请求字符串，主要是uri： private void parseUri() { if(StrUtil.isEmpty(requestString)) return; String temp; // 请求的uri就是刚开始的两个空格之间的数据 temp = StrUtil.subBetween(requestString, &quot; &quot;, &quot; &quot;); // 判断有无参数 if (!StrUtil.contains(temp, &#39;?&#39;)) { uri = temp; return; } temp = StrUtil.subBefore(temp, &#39;?&#39;, false); uri = temp; } response对象实现HttpServletResponse中response.getWriter().println()类似风格： public Response(){ this.stringWriter = new StringWriter(); // 用于存放返回的html文本 // response.getWriter().println() 写进去的数据最后都写到stringWriter里面去了 this.writer = new PrintWriter(stringWriter); this.contentType = &quot;text/html&quot;; // 对应响应头里面的Content-type } 线程池处理多请求： ThreadPoolExecutor threadPool = new ThreadPoolExecutor(20, 20, 60, TimeUnit.SECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(10)); // 创建包含20个线程的线程池 for(int i = 0; i&lt;3; i++){ threadPool.execute(new Runnable(){ public void run() { getContentString(&quot;/timeConsume.html&quot;); // 获取响应内容 } }); } threadPool.shutdown(); // 尝试关闭线程池，如果其中有任务在运行，就不会强制关闭 threadPool.awaitTermination(1, TimeUnit.HOURS); // 若一小时后仍在运行任务，强制关闭线程池 服务端在每个请求到来的时候，创建一个Runnable任务，并且把他丢到线程池运行即可，然后去准备接受下一个请求： while(true) { Socket s = ss.accept(); Runnable r = new Runnable(){ @Override public void run() { try { Request request = new Request(s); Response response = new Response(); String uri = request.getUri(); if(&quot;/&quot;.equals(uri)){ // 默认请求 String html = &quot;Hello DIY Tomcat from how2j.cn&quot;; response.getWriter().println(html); } else{ // 请求资源 String fileName = StrUtil.removePrefix(uri, &quot;/&quot;); File file = FileUtil.file(Constant.rootFolder,fileName); if(file.exists()){ String fileContent = FileUtil.readUtf8String(file); response.getWriter().println(fileContent); if(fileName.equals(&quot;timeConsume.html&quot;)){ // 耗时任务 ThreadUtil.sleep(1000); } } else{ // 资源未找到 response.getWriter().println(&quot;File Not Found&quot;); } } // ... // 处理请求 } catch (IOException e) { e.printStackTrace(); } } }; ThreadPoolUtil.run(r); // 放入线程池 } 多应用添加访问路径与对应服务端文件系统中文件位置的映射contextMap，Request对象中增加对Context对象（代表一个应用）的处理： private void parseContext() { String path = StrUtil.subBetween(uri, &quot;/&quot;, &quot;/&quot;); if (null == path) path = &quot;/&quot;; else path = &quot;/&quot; + path; context = Bootstrap.contextMap.get(path); if (null == context) context = Bootstrap.contextMap.get(&quot;/&quot;); // Context对象找不到，则返回默认的ROOT Context } 就可以通过客户端请求，获取对应的Context对象，根据这个对象获取信息： Context context = request.getContext(); // ... File file = FileUtil.file(context.getDocBase(), fileName); // 得到请求资源对应在文件系统中的位置 server.xml还可以通过配置文件注册Context对象： &lt;Server&gt; &lt;Context path=&quot;/b&quot; docBase=&quot;d:/java_proj/diytomcat/b&quot; /&gt; &lt;/Server&gt; 引入Tomcat各内置对象： &lt;Server&gt; &lt;!--表示服务器本身--&gt; &lt;Service name=&quot;Catalina&quot;&gt; &lt;!--代表tomcat提供的服务--&gt; &lt;Connector port=&quot;18080&quot;/&gt; &lt;!--配置多端口监听--&gt; &lt;Connector port=&quot;18081&quot;/&gt; &lt;Connector port=&quot;18082&quot;/&gt; &lt;!--表示servlet引擎，用来处理servlet的请求--&gt; &lt;Engine defaultHost=&quot;localhost&quot;&gt; &lt;!--默认的 Host 是名称是 &quot;localhost&quot; 的 Host--&gt; &lt;!--Host表示虚拟主机--&gt; &lt;Host name=&quot;localhost&quot;&gt; &lt;Context path=&quot;/b&quot; docBase=&quot;d:/java_proj/diytomcat/b&quot; /&gt; &lt;/Host&gt; &lt;/Engine&gt; &lt;/Service&gt; &lt;/Server&gt; 利用jsoup解析xml文件： public static List&lt;Context&gt; getContexts() { List&lt;Context&gt; result = new ArrayList&lt;&gt;(); String xml = FileUtil.readUtf8String(Constant.serverXmlFile); Document d = Jsoup.parse(xml); Elements es = d.select(&quot;Context&quot;); // 选择器通过标签名获取元素 for (Element e : es) { String path = e.attr(&quot;path&quot;); String docBase = e.attr(&quot;docBase&quot;); Context context = new Context(path, docBase); result.add(context); } return result; } 可以看到启动服务端时，控制台打印类似官方Tomcat风格的日志： 404和500响应注明响应头： public static final String response_head_404 = &quot;HTTP/1.1 404 Not Found\\r\\n&quot; + &quot;Content-Type: text/html\\r\\n\\r\\n&quot;; public static final String response_head_500 = &quot;HTTP/1.1 500 Internal Server Error\\r\\n&quot; + &quot;Content-Type: text/html\\r\\n\\r\\n&quot;; 处理404请求： protected void handle404(Socket s, String uri) throws IOException { OutputStream os = s.getOutputStream(); String responseText = StrUtil.format(Constant.textFormat_404, uri, uri); responseText = Constant.response_head_404 + responseText; // 响应页面可直接延用官方Tomcat页面 byte[] responseByte = responseText.getBytes(&quot;utf-8&quot;); os.write(responseByte); } 处理500请求，需要打印异常堆栈信息： StackTraceElement[] stes = e.getStackTrace(); // 拿到Exception的异常堆栈，可以看到依次调用的类的方法的信息 欢迎页编写Tomcat的配置文件conf/web.xml： &lt;web-app&gt; &lt;!--存放关于tomcat的默认配置--&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;/web-app&gt; 设置每个应用对应的起始页： public static String getWelcomeFile(Context context) { String xml = FileUtil.readUtf8String(webXmlFile); Document d = Jsoup.parse(xml); Elements es = d.select(&quot;welcome-file&quot;); for (Element e : es) { String welcomeFileName = e.text(); File f = new File(context.getDocBase(), welcomeFileName); if (f.exists()) return f.getName(); } return &quot;index.html&quot;; } mime-type网页仅识别mime-type类型的资源文件，因此需要配置文件类型与mime-type类型的映射： &lt;!-- --&gt; &lt;mime-mapping&gt; &lt;extension&gt;zip&lt;/extension&gt; &lt;mime-type&gt;application/zip&lt;/mime-type&gt; &lt;/mime-mapping&gt; &lt;!-- --&gt; 初始化时加载一次： private static void initMimeType() { String xml = FileUtil.readUtf8String(webXmlFile); Document d = Jsoup.parse(xml); Elements es = d.select(&quot;mime-mapping&quot;); for (Element e : es) { String extName = e.select(&quot;extension&quot;).first().text(); String mimeType = e.select(&quot;mime-type&quot;).first().text(); mimeTypeMapping.put(extName, mimeType); } } 处理请求时，设置响应头： String extName = FileUtil.extName(file); String mimeType = WebXMLUtil.getMimeType(extName); response.setContentType(mimeType); // 根据请求文件类型，设置响应头 servlet映射在diytomcat的配置文件目录下新建context.xml，里面配置了servlet映射文件所在位置： &lt;Context&gt; &lt;!--web应用默认配置信息的存放路径--&gt; &lt;WatchedResource&gt;WEB-INF/web.xml&lt;/WatchedResource&gt; &lt;/Context&gt; 解析servlet映射文件： &lt;web-app&gt; &lt;servlet&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;cn.how2j.diytomcat.webappservlet.HelloServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/hello&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;/web-app&gt; private Map&lt;String, String&gt; url_servletClassName; // 地址对应 Servlet 的类名 private Map&lt;String, String&gt; url_servletName; // 地址对应 Servlet 的名称 private Map&lt;String, String&gt; servletName_className; // Servlet 的名称对应类名 private Map&lt;String, String&gt; className_servletName; // Servlet 类名对应名称 // ... private void parseServletMapping(Document d) { // url_ServletName Elements mappingurlElements = d.select(&quot;servlet-mapping url-pattern&quot;); for (Element mappingurlElement : mappingurlElements) { String urlPattern = mappingurlElement.text(); String servletName = mappingurlElement.parent().select(&quot;servlet-name&quot;).first().text(); url_servletName.put(urlPattern, servletName); } // ... } 服务端通过servlet类名实例化对象，然后调用其doGet方法： String servletClassName = context.getServletClassName(uri); if(null!=servletClassName){ Object servletObject = ReflectUtil.newInstance(servletClassName); ReflectUtil.invoke(servletObject, &quot;doGet&quot;, request, response); } Tomcat类加载器 Tomcat的顶层自定义加载器是公共类加载器。它负责加载%tomcat_home%/lib这个目录里的类和jar；WebappClassLoader，用于加载某个web应用，比如j2ee下的/WEB-INF/classes，/WEB-INF/lib目录里的类和jar；JspClassLoader，用于加载jsp转换成.java被编译之后的类。再还有 Catalina 和 Share 类加载器，分别加载%tomcat_home%/catalina/和%tomcat_home%/share目录下的jar。 public class CommonClassLoader extends URLClassLoader { public CommonClassLoader() { super(new URL[] {}); try { File workingFolder = new File(System.getProperty(&quot;user.dir&quot;)); File libFolder = new File(workingFolder, &quot;lib&quot;); File[] jarFiles = libFolder.listFiles(); assert jarFiles != null; for (File file : jarFiles) { if (file.getName().endsWith(&quot;jar&quot;)) { URL url = new URL(&quot;file:&quot; + file.getAbsolutePath()); this.addURL(url); // 加到当前的库里面去，当调用其loadClass方法时，就会从这些jar里面去找了 } } } catch (MalformedURLException e) { // TODO Auto-generated catch block e.printStackTrace(); } } } 自定义公共类加载器，为保证仅启动类使用应用程序类加载器，其余类通过CommonClassLoader加载，需要通过批处理文件运行： del /q bootstrap.jar jar cvf0 bootstrap.jar -C out/production/diytomcat cn/how2j/diytomcat/Bootstrap.class -C out/production/diytomcat cn/how2j/diytomcat/classloader/CommonClassLoader.class del /q lib/diytomcat.jar cd out cd production cd diytomcat jar cvf0 ../../../lib/diytomcat.jar * cd .. cd .. cd .. java -cp bootstrap.jar cn.how2j.diytomcat.Bootstrap pause 不同应用对应独立的类加载器WebappClassLoader： public class WebappClassLoader extends URLClassLoader { public WebappClassLoader(String docBase, ClassLoader commonClassLoader) { super(new URL[] {}, commonClassLoader); // ... File webinfFolder = new File(docBase, &quot;WEB-INF&quot;); File classesFolder = new File(webinfFolder, &quot;classes&quot;); File libFolder = new File(webinfFolder, &quot;lib&quot;); URL url; url = new URL(&quot;file:&quot; + classesFolder.getAbsolutePath() + &quot;/&quot;); // 末尾跟上&quot;/&quot;，URLClassLoader才会当成目录处理 this.addURL(url); List&lt;File&gt; jarFiles = FileUtil.loopFiles(libFolder); // ... } } 部署独立的web应用后可以看到，使用的是独立的web应用类加载器： // 每个web应用有自己独立的类加载器，不同应用间存在同名类也不影响 ClassLoader commonClassLoader = Thread.currentThread().getContextClassLoader(); this.webappClassLoader = new WebappClassLoader(docBase, commonClassLoader); 热加载 通过设置监听器ContextFileChangeWatcher监听web工作目录变化，来实现热加载功能： public class ContextFileChangeWatcher { private WatchMonitor monitor; // 真正作用的监听器 private boolean stop = false; // 标记是否已经暂停 public ContextFileChangeWatcher(Context context) { // 通过WatchUtil.createAll创建监听器； // context.getDocBase()代表监听的文件夹； // Integer.MAX_VALUE代表监听的深入，如果是0或者1，就表示只监听当前目录，而不监听子目录； // new Watcher 当有文件发生变化，那么就会访问 Watcher 对应的方法 this.monitor = WatchUtil.createAll(context.getDocBase(), Integer.MAX_VALUE, new Watcher() { private void dealWith(WatchEvent&lt;?&gt; event) { // 统一处理（重新加载context） synchronized (ContextFileChangeWatcher.class) { // 多线程下同步，防止context重载多次 String fileName = event.context().toString(); if (stop) // 表示已经重载过了，通知后续消息不需要再进行处理 return; // 只应对 jar class 和 xml 发生的变化，其他的不需要重启 if (fileName.endsWith(&quot;.jar&quot;) || fileName.endsWith(&quot;.class&quot;) || fileName.endsWith(&quot;.xml&quot;)) { stop = true; LogFactory.get().info(ContextFileChangeWatcher.this + &quot; 检测到了Web应用下的重要文件变化 {} &quot; , fileName); context.reload(); // 保存基本信息后，调用类加载器stop方法暂停，删掉映射中相应信息，之后利用保存的基本信息重新创建context及建立映射关系 } // ... } } }); // ... } } Servlet单例用Servlet缓存池实现Servlet单例模式，后续直接通过类名映射得到对应Servlet对象： public synchronized HttpServlet getServlet(Class&lt;?&gt; clazz) throws InstantiationException, IllegalAccessException, ServletException { HttpServlet servlet = servletPool.get(clazz); if (null == servlet) { synchronized (HttpServlet.class) { servlet = (HttpServlet) clazz.newInstance(); servletPool.put(clazz, servlet); } } return servlet; } Servlet生命周期实例化Servlet后，放入缓存池之前，初始化Servlet： servlet = (HttpServlet) clazz.newInstance(); ServletContext servletContext = this.getServletContext(); String className = clazz.getName(); String servletName = className_servletName.get(className); Map&lt;String, String&gt; initParameters = servlet_className_init_params.get(className); ServletConfig servletConfig = new StandardServletConfig(servletContext, servletName, initParameters); servlet.init(servletConfig); Servlet提供服务之后，销毁并回收Servlet： private void destroyServlets() { Collection&lt;HttpServlet&gt; servlets = servletPool.values(); for (HttpServlet servlet : servlets) { servlet.destroy(); } } Servlet自启动xml文件中解析需要自启动的Servlet类： public void parseLoadOnStartup(Document d) { Elements es = d.select(&quot;load-on-startup&quot;); for (Element e : es) { String loadOnStartupServletClassName = e.parent().select(&quot;servlet-class&quot;).text(); loadOnStartupServletClassNames.add(loadOnStartupServletClassName); } } 启动tomcat时加载需要自启动的Servlet类： public void handleLoadOnStartup() { for (String loadOnStartupServletClassName : loadOnStartupServletClassNames) { try { Class&lt;?&gt; clazz = webappClassLoader.loadClass(loadOnStartupServletClassName); getServlet(clazz); } catch (ClassNotFoundException | InstantiationException | IllegalAccessException | ServletException e) { e.printStackTrace(); } } } Request请求参数和头信息Request对象中处理请求参数： private void parseParameters() { // 获取参数，GET的参数放在uri里，POST参数放在请求最后的请求体里 if (&quot;GET&quot;.equals(this.getMethod())) { String url = StrUtil.subBetween(requestString, &quot; &quot;, &quot; &quot;); if (StrUtil.contains(url, &#39;?&#39;)) { queryString = StrUtil.subAfter(url, &#39;?&#39;, false); } } if (&quot;POST&quot;.equals(this.getMethod())) { queryString = StrUtil.subAfter(requestString, &quot;\\r\\n\\r\\n&quot;, false); } // ... } Request对象中处理头信息： public void parseHeaders() { StringReader stringReader = new StringReader(requestString); List&lt;String&gt; lines = new ArrayList&lt;&gt;(); IoUtil.readLines(stringReader, lines); for (int i = 1; i &lt; lines.size(); i++) { // i = 1 绕过请求头 String line = lines.get(i); if (0 == line.length()) // 绕过请求体 break; String[] segs = line.split(&quot;:&quot;); String headerName = segs[0].toLowerCase(); String headerValue = segs[1]; headerMap.put(headerName, headerValue); } } Cookie设置Response字段cookies，在返回响应时转换成cookies header，重写addCookie方法： public void addCookie(Cookie cookie) { cookies.add(cookie); } 重写getCookies方法，在Request中处理cookies： private void parseCookies() { List&lt;Cookie&gt; cookieList = new ArrayList&lt;&gt;(); String cookies = headerMap.get(&quot;cookie&quot;); if (null != cookies) { String[] pairs = StrUtil.split(cookies, &quot;;&quot;); for (String pair : pairs) { if (StrUtil.isBlank(pair)) continue; String[] segs = StrUtil.split(pair, &quot;=&quot;); String name = segs[0].trim(); String value = segs[1].trim(); Cookie cookie = new Cookie(name, value); cookieList.add(cookie); } } this.cookies = ArrayUtil.toArray(cookieList, Cookie.class); } session获取session的主逻辑： public static HttpSession getSession(String jsessionid, Request request, Response response) { if (null == jsessionid) { // 如果浏览器没有传递 jsessionid 过来，那么就创建一个新的session return newSession(request, response); } else { StandardSession currentSession = sessionMap.get(jsessionid); if (null == currentSession) { // 如果浏览器传递过来的 jsessionid 无效，那么也创建一个新的 sessionid return newSession(request, response); } else { // 否则就使用现成的session, 并且修改它的lastAccessedTime， 以及创建对应的 cookie currentSession.setLastAccessedTime(System.currentTimeMillis()); createCookieBySession(currentSession, request, response); return currentSession; } } } 通过开启一个线程轮询来达到session的时效性： private static void startSessionOutdateCheckThread() { new Thread(() -&gt; { while (true) { checkOutDateSession(); ThreadUtil.sleep(1000 * 30); // 每隔30秒调用一次 checkOutDateSession 方法 } }).start(); } gzip在server.xml上设置是否进行gzip压缩： &lt;Connector port=&quot;18080&quot; compression=&quot;on&quot; compressionMinSize=&quot;20&quot; noCompressionUserAgents=&quot;gozilla, traviata&quot; compressableMimeType=&quot;text/html,text/xml,text/javascript,application/javascript,text/css,text/plain,text/json&quot; /&gt; &lt;!--是否启动gzip压缩；最小进行压缩的字节数；不进行压缩的浏览器；需要进行压缩的mimeType--&gt; 针对需要进行压缩的请求头（判断是否满足压缩条件）调用ZipUtil.gzip()方法对响应体进行gzip压缩： public static final String response_head_200_gzip = &quot;HTTP/1.1 200 OK\\r\\nContent-Type: {}{}\\r\\n&quot; + &quot;Content-Encoding:gzip&quot; + &quot;\\r\\n\\r\\n&quot;; // 进行了压缩时的响应头 客户端跳转分为301永久跳转和302临时跳转，在Response中设置保存客户端跳转路径的字段，在服务端响应成功后，如果Response对象里这一字段不为空，则返回302响应头通知浏览器进行跳转： public static final String response_head_302 = &quot;HTTP/1.1 302 Found\\r\\nLocation: {}\\r\\n\\r\\n&quot;; if(null!=response.getRedirectPath()) response.setStatus(Constant.CODE_302); else response.setStatus(Constant.CODE_200); 服务端跳转实现RequestDispatcher接口，用于进行服务端跳转： public class ApplicationRequestDispatcher implements RequestDispatcher { private String uri; public ApplicationRequestDispatcher(String uri) { if (!uri.startsWith(&quot;/&quot;)) uri = &quot;/&quot; + uri; this.uri = uri; } @Override public void forward(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException { Request request = (Request) servletRequest; Response response = (Response) servletResponse; request.setUri(uri); // 修改 request 的 uri HttpProcessor processor = new HttpProcessor(); processor.execute(request.getSocket(), request, response); // 通过 HttpProcessor 的 execute 再执行一次 request.setForwarded(true); // 相当于在服务器内部再次访问了某个页面 } @Override public void include(ServletRequest arg0, ServletResponse arg1) throws ServletException, IOException { // TODO Auto-generated method stub } } 通过上述方式进行服务端跳转，需要在HttpProcessor.execute()方法加入条件判断： if (request.isForwarded()) { // 防止服务端进行多次跳转，导致程序使用已经关闭的socket从而抛出异常 return; } FilterFilter的初始化和配置与Servlet类似；自定义ApplicationFilterChain类实现FilterChain接口： public class ApplicationFilterChain implements FilterChain { private Filter[] filters; private Servlet servlet; int pos; public ApplicationFilterChain(List&lt;Filter&gt; filterList,Servlet servlet){ this.filters = ArrayUtil.toArray(filterList,Filter.class); this.servlet = servlet; } @Override public void doFilter(ServletRequest request, ServletResponse response) throws IOException, ServletException { if(pos &lt; filters.length) { Filter filter= filters[pos++]; filter.doFilter(request, response, this); } else { servlet.service(request, response); } } } 注册到Filter缓存池之后，请求到来时通过责任链模式进行处理： // 通过servlet类名实例化对象，然后调用其doGet方法 String servletClassName = context.getServletClassName(uri); HttpServlet workingServlet; // Servlet的service方法是在chain里面调用，所以用一个workingSerlvet分别指向它们 if (null != servletClassName) { workingServlet = InvokerServlet.getInstance(); } else if (uri.endsWith(&quot;.jsp&quot;)) { workingServlet = JspServlet.getInstance(); } else { workingServlet = DefaultServlet.getInstance(); // 处理静态资源 } // 通过Filter匹配模式筛选出需要过滤的Filter List&lt;Filter&gt; filters = request.getContext().getMatchedFilters(request.getRequestURI()); // 实例化自定义的FilterChain ApplicationFilterChain filterChain = new ApplicationFilterChain(filters, workingServlet); filterChain.doFilter(request, response); War部署首先将web应用打包成War包，置于diytomcat的webapps目录下，设置diytomcat启动时自动解压War文件，并识别web应用： public void loadWar(File warFile) { String fileName =warFile.getName(); String folderName = StrUtil.subBefore(fileName,&quot;.&quot;,true); //看看是否已经有对应的 Context了 Context context= getContext(&quot;/&quot;+folderName); if(null!=context) return; //先看是否已经有对应的文件夹 File folder = new File(Constant.webappsFolder,folderName); if(folder.exists()) return; //移动war文件，因为jar 命令只支持解压到当前目录下 File tempWarFile = FileUtil.file(Constant.webappsFolder, folderName, fileName); File contextFolder = tempWarFile.getParentFile(); contextFolder.mkdir(); FileUtil.copyFile(warFile, tempWarFile); //解压 String command = &quot;jar xvf &quot; + fileName; Process p =RuntimeUtil.exec(null, contextFolder, command); try { p.waitFor(); } catch (InterruptedException e) { e.printStackTrace(); } //解压之后删除临时war tempWarFile.delete(); //然后创建新的 Context loadContext(contextFolder); } 同样自定义监控类WarFileWatcher可实现动态War部署： public class WarFileWatcher { // 监控webapps目录，当发现新创建了war文件的时候，就调用loadWar方法 private WatchMonitor monitor; public WarFileWatcher(Host host) { this.monitor = WatchUtil.createAll(Constant.webappsFolder, 1, new Watcher() { private void dealWith(WatchEvent&lt;?&gt; event, Path currentPath) { synchronized (WarFileWatcher.class) { String fileName = event.context().toString(); if(fileName.toLowerCase().endsWith(&quot;.war&quot;) &amp;&amp; ENTRY_CREATE.equals(event.kind())) { File warFile = FileUtil.file(Constant.webappsFolder, fileName); host.loadWar(warFile); } } } // ... }); } // ... } 监听器配置监听器，diytomcat端解析xml文件初始化加载监听器（流程类似过滤器）： public class ContextListener implements ServletContextListener { @Override public void contextDestroyed(ServletContextEvent e) { System.out.println(&quot;监听到 web 应用 &quot;+ e.getSource() +&quot; 的销毁事件 &quot;); } @Override public void contextInitialized(ServletContextEvent e) { System.out.println(&quot;监听到 web 应用 &quot;+ e.getSource() +&quot; 的初始化事件 &quot;); } } 定义事件处理方法，实现在服务端处理请求流程中，监听Context生命周期中的初始化和销毁过程： private void fireEvent(String type) { ServletContextEvent event = new ServletContextEvent(servletContext); for (ServletContextListener servletContextListener : listeners) { if(&quot;init&quot;.equals(type)) servletContextListener.contextInitialized(event); if(&quot;destroy&quot;.equals(type)) servletContextListener.contextDestroyed(event); } } 测试测试完毕，项目已推至github，其实还是有些小bug，等之后学些netty和分布式的东西再回来优化","categories":[{"name":"生活","slug":"生活","permalink":"http://goodguyjameswin.github.io/categories/生活/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://goodguyjameswin.github.io/tags/学习笔记/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"http://goodguyjameswin.github.io/categories/生活/"}]},{"title":"回溯","slug":"回溯","date":"2022-05-28T10:43:14.000Z","updated":"2022-07-29T05:54:20.558Z","comments":false,"path":"2022/05/28/回溯/","link":"","permalink":"http://goodguyjameswin.github.io/2022/05/28/回溯/","excerpt":"","text":"什么是回溯算法当要解决一个问题有多个步骤，每一个步骤有多种选择，使用回溯算法可以通过深度优先遍历得到所有的解决方案。回溯算法递归地建立了局部的可能的解决方案，当发现一个可能的解决方案无法得出正确的结果时，回退到上一步，尝试下一个可能的解决方案。 剪枝剪枝是指根据问题的特点，在遍历的过程中检测不可能搜索到正确结果的子树，以缩短遍历的路径，从而缩短程序运行的时间。 经典问题：给定一个包含重复数字的序列，返回所有不重复的全排列。 输入: [1,1,2] 输出: [[1,1,2], [1,2,1], [2,1,1]] public class Solution { public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) { int len = nums.length; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); if (len == 0) { return res; } // 排序（升序或者降序都可以），排序是剪枝的前提 Arrays.sort(nums); // 初始化的时候所有的元素都为 false boolean[] used = new boolean[len]; Deque&lt;Integer&gt; path = new ArrayDeque&lt;&gt;(len); dfs(nums, len, 0, used, path, res); return res; } private void dfs(int[] nums, int len, int index, boolean[] used, Deque&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; res) { // 当 index == len 时，path 是一个排列，把它添加到结果集中 if (index == len) { res.add(new ArrayList&lt;&gt;(path)); // 程序就没有必要执行下去了，这里显式地写上 return 让程序不要再往下面走 return; } // 排列与顺序有关，因此每次都头开始遍历 for (int i = 0; i &lt; len; ++i) { // 因为排列中原序列中每个数只能选一次，所以如果某个数已经选择过，跳过 if (used[i]) { continue; } // 剪枝条件：i &gt; 0 是为了保证 nums[i - 1] 有意义； // 要解决重复问题，就要保证在填第 idx 个数的时候重复数字只会被填入一次。因此通过对原数组排序，保证相同的数字都相邻，然后每次填入的数一定是这个数所在重复数集合中 从左往右第一个未被填过的数字。 if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; !used[i - 1]) { continue; } path.addLast(nums[i]); used[i] = true; dfs(nums, len, index + 1, used, path, res); // 回溯部分的代码，和 dfs 之前的代码是对称的 used[i] = false; path.removeLast(); } } } 经典问题：给定一个无重复元素的数组candidates和一个目标数target，找出candidates中所有可以使数字和为target的组合。candidates中的数字可以无限制重复被选取。 其中所有数字（包括target）都是正整数；解集不能包含重复的组合。 输入: candidates = [2,3,5], target = 8, 所求解集为： [[2,2,2,2], [2,3,3], [3,5]] public class Solution { public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) { int len = candidates.length; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); if (len == 0) { return res; } // 排序是剪枝的前提 Arrays.sort(candidates); Deque&lt;Integer&gt; path = new ArrayDeque&lt;&gt;(); dfs(candidates, 0, len, target, path, res); return res; } private void dfs(int[] candidates, int begin, int len, int target, Deque&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; res) { // 由于进入更深层的时候，小于 0 的部分被剪枝，因此递归终止条件值只判断等于 0 的情况 if (target == 0) { res.add(new ArrayList&lt;&gt;(path)); return; } // 注意从 begin 开始搜索，因为前面已经遍历完所有组合中包含 candidates[begin] 元素的情况 for (int i = begin; i &lt; len; i++) { // 剪枝：如果一个正数减去一个较小的数都小于等于0，那么它再减去一个更大的数，一定小于0 if (target - candidates[i] &lt; 0) { break; } path.addLast(candidates[i]); // 注意：由于每一个元素可以重复使用，下一轮搜索的起点依然是 i，否则是 i + 1 dfs(candidates, i, len, target - candidates[i], path, res); // 状态重置 path.removeLast(); } } } 漫水填充在图论里指：从一个结点出发，遍历与它同在一个连通分量中的所有点，可以使用深度优先遍历的方式。如果要寻找最短路径，可以使用广度优先遍历。 经典问题：给你一个由1（陆地）和0（水）组成的二维网格，请你计算网格中岛屿的数量。 岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。此外，你可以假设该网格的四条边均被水包围。 输入：grid = [[“1”,”1”,”1”,”1”,”0”], [“1”,”1”,”0”,”1”,”0”], [“1”,”1”,”0”,”0”,”0”], [“0”,”0”,”0”,”0”,”0”]] 查看解析 class Solution { void dfs(char[][] grid, int r, int c) { int nr = grid.length; int nc = grid[0].length; if (r &lt; 0 || c &lt; 0 || r &gt;= nr || c &gt;= nc || grid[r][c] == &#39;0&#39;) { return; } grid[r][c] = &#39;0&#39;; dfs(grid, r - 1, c); dfs(grid, r + 1, c); dfs(grid, r, c - 1); dfs(grid, r, c + 1); } public int numIslands(char[][] grid) { if (grid == null || grid.length == 0) { return 0; } int nr = grid.length; int nc = grid[0].length; int num_islands = 0; for (int r = 0; r &lt; nr; ++r) { for (int c = 0; c &lt; nc; ++c) { if (grid[r][c] == &#39;1&#39;) { ++num_islands; dfs(grid, r, c); } } } return num_islands; } } 力扣417：有一个m * n的矩形岛屿，与太平洋和大西洋相邻。“太平洋”处于大陆的左边界和上边界，而“大西洋”处于大陆的右边界和下边界。这个岛被分割成一个由若干方形单元格组成的网格。给定一个m * n的整数矩阵heights，heights[r][c]表示坐标(r, c)上单元格海平面的高度。 岛上雨水较多，如果相邻单元格的高度小于或等于当前单元格的高度，雨水可以直接向北、南、东、西流向相邻单元格。水可以从海洋附近的任何单元格流入海洋。 返回网格坐标result的2D列表，其中result[i] = [ri, ci]表示雨水从单元格(ri, ci)流动即可流向太平洋也可流向大西洋。 输入: heights = [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]] 输出: [[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]] class Solution { static int dirs[][]; int heights[][]; int m, n; public List&lt;List&lt;Integer&gt;&gt; pacificAtlantic(int[][] heights) { this.dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; this.heights = heights; this.m = heights.length; this.n = heights[0].length; boolean[][] pacific = new boolean[m][n]; boolean[][] atlantic = new boolean[m][n]; for (int i = 0; i &lt; m; i++) { dfs(i, 0, pacific); } for (int j = 1; j &lt; n; j++) { dfs(0, j, pacific); } for (int i = 0; i &lt; m; i++) { dfs(i, n - 1, atlantic); } for (int j = 0; j &lt; n - 1; j++) { dfs(m - 1, j, atlantic); } List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;List&lt;Integer&gt;&gt;(); for (int i = 0; i &lt; m; i++) { for (int j = 0; j &lt; n; j++) { if (pacific[i][j] &amp;&amp; atlantic[i][j]) { List&lt;Integer&gt; cell = new ArrayList&lt;Integer&gt;(); cell.add(i); cell.add(j); result.add(cell); } } } return result; } public void dfs(int row, int col, boolean[][] ocean) { if (ocean[row][col]) { return; } ocean[row][col] = true; for (int[] dir : dirs) { int newRow = row + dir[0], newCol = col + dir[1]; if (newRow &gt;= 0 &amp;&amp; newRow &lt; m &amp;&amp; newCol &gt;= 0 &amp;&amp; newCol &lt; n &amp;&amp; heights[newRow][newCol] &gt;= heights[row][col]) { dfs(newRow, newCol, ocean); } } } } 经典问题：给你一个整数n，返回和为n的完全平方数的最少数量。完全平方数是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。 输入：n = 12 输出：3 解释：12 = 4 + 4 + 4 class Solution { public int numSquares(int n) { Queue&lt;Integer&gt; queue=new LinkedList&lt;&gt;(); HashSet&lt;Integer&gt; visited=new HashSet&lt;&gt;(); queue.offer(n); visited.add(n); int level=0; while(!queue.isEmpty()){ level++; int len=queue.size(); for(int i=0;i&lt;len;i++){ int cur=queue.poll(); for(int j=1;j*j&lt;=cur;j++){ int tmp=cur-j*j; if(tmp==0) return level; if(!visited.contains(tmp)) queue.offer(tmp); visited.add(tmp); } } } return level; } } 思考：请尝试用动态规划解答本题。 查看解析 class Solution { public int numSquares(int n) { int[] f = new int[n + 1]; for (int i = 1; i &lt;= n; i++) { int minn = Integer.MAX_VALUE; for (int j = 1; j * j &lt;= i; j++) { minn = Math.min(minn, f[i - j * j]); } f[i] = minn + 1; } return f[n]; } } 力扣773：在一个2 * 3的板上（board）有 5 块砖瓦，用数字1~5来表示，以及一块空缺用0来表示。一次移动定义为选择0与一个相邻的数字（上下左右）进行交换。 最终当板board的结果是[[1,2,3],[4,5,0]]迷板被解开。 给出一个谜板的初始状态board，返回最少可以通过多少次移动解开谜板，如果不能解开谜板，则返回-1。 输入：board = [[1,2,3],[4,0,5]] 输出：1 解释：交换 0 和 5，1 步完成 class Solution { int neighbors[][]; public int slidingPuzzle(int[][] board) { this.neighbors = {{1, 3}, {0, 2, 4}, {1, 5}, {0, 4}, {1, 3, 5}, {2, 4}}; StringBuffer sb = new StringBuffer(); for (int i = 0; i &lt; 2; ++i) { for (int j = 0; j &lt; 3; ++j) { sb.append(board[i][j]); } } String initial = sb.toString(); if (&quot;123450&quot;.equals(initial)) { return 0; } int step = 0; Queue&lt;String&gt; queue = new LinkedList&lt;String&gt;(); queue.offer(initial); Set&lt;String&gt; seen = new HashSet&lt;String&gt;(); seen.add(initial); while (!queue.isEmpty()) { ++step; int size = queue.size(); for (int i = 0; i &lt; size; ++i) { String status = queue.poll(); for (String nextStatus : get(status)) { if (!seen.contains(nextStatus)) { if (&quot;123450&quot;.equals(nextStatus)) { return step; } queue.offer(nextStatus); seen.add(nextStatus); } } } } return -1; } // 枚举 status 通过一次交换操作得到的状态 public List&lt;String&gt; get(String status) { List&lt;String&gt; ret = new ArrayList&lt;String&gt;(); char[] array = status.toCharArray(); int x = status.indexOf(&#39;0&#39;); for (int y : neighbors[x]) { swap(array, x, y); ret.add(new String(array)); swap(array, x, y); } return ret; } public void swap(char[] array, int x, int y) { char temp = array[x]; array[x] = array[y]; array[y] = temp; } } 力扣886：给定一组n人（编号为1,2,...,n），我们想把每个人分进任意大小的两组。每个人都可能不喜欢其他人，那么他们不应该属于同一组。 给定整数n和数组dilikes，其中dilikes[i]=[ai,bi]，表示不允许将编号为ai和bi的人归入同一组。当可以用这种方法将所有人分进两组时，返回true；否则返回false。 输入：n = 4, dislikes = [[1,2],[1,3],[2,4]] 输出：true 解释：group1 [1,4], group2 [2,3] 查看解析 class Solution { ArrayList&lt;Integer&gt;[] graph; Map&lt;Integer, Integer&gt; color; // 考虑由给定的 “不喜欢” 边缘形成的 N 人的图表，检查这个图的每个连通分支是否为二分的； // 对于每个连通的部分，我们只需试着用两种颜色对它进行着色，就可以检查它是否是二分的。如何做到这一点：将任一结点涂成红色，然后将它的所有邻居都涂成蓝色，然后将所有的邻居的邻居都涂成红色，以此类推。如果我们将一个红色结点涂成蓝色（或蓝色结点涂成红色），那么就会产生冲突 public boolean possibleBipartition(int N, int[][] dislikes) { graph = new ArrayList[N+1]; for (int i = 1; i &lt;= N; ++i) graph[i] = new ArrayList(); for (int[] edge: dislikes) { graph[edge[0]].add(edge[1]); graph[edge[1]].add(edge[0]); } color = new HashMap(); for (int node = 1; node &lt;= N; ++node) if (!color.containsKey(node) &amp;&amp; !dfs(node, 0)) return false; return true; } public boolean dfs(int node, int c) { if (color.containsKey(node)) return color.get(node) == c; color.put(node, c); for (int nei: graph[node]) if (!dfs(nei, c ^ 1)) return false; return true; } } 回溯模拟经典问题：按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。n皇后问题研究的是如何将n个皇后放置在n * n的棋盘上，并且使皇后彼此之间不能相互攻击。 给你一个整数n，返回所有不同的n皇后问题的解决方案。每一种解法包含不同的n皇后问题的棋子放置方案，该方案中&#39;Q&#39;和&#39;.&#39;分别代表了皇后和空位。 输入：n = 4 输出：[[“.Q..”,”…Q”,”Q…”,”..Q.”],[“..Q.”,”Q…”,”…Q”,”.Q..”]] 解释：如上图所示，4 皇后问题存在两个不同的解法。 import java.util.ArrayDeque; import java.util.ArrayList; import java.util.Deque; import java.util.List; public class Solution { private int n; /** * 记录某一列是否放置了皇后 */ private boolean[] col; /** * 记录主对角线上的单元格是否放置了皇后 */ private boolean[] main; /** * 记录了副对角线上的单元格是否放置了皇后 */ private boolean[] sub; private List&lt;List&lt;String&gt;&gt; res; public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) { res = new ArrayList&lt;&gt;(); if (n == 0) { return res; } // 设置成员变量，减少参数传递 this.n = n; this.col = new boolean[n]; this.main = new boolean[2 * n - 1]; this.sub = new boolean[2 * n - 1]; Deque&lt;Integer&gt; path = new ArrayDeque&lt;&gt;(); dfs(0, path); return res; } private void dfs(int row, Deque&lt;Integer&gt; path) { if (row == n) { // 深度优先遍历到下标为 n，表示 [0.. n - 1] 已经填完，得到了一个结果 List&lt;String&gt; board = convert2board(path); res.add(board); return; } // 针对下标为 row 的每一列，尝试是否可以放置 for (int j = 0; j &lt; n; j++) { if (!col[j] &amp;&amp; !main[row - j + n - 1] &amp;&amp; !sub[row + j]) { path.addLast(j); col[j] = true; // 主对角线方向上的单元格：横坐标 - 纵坐标 = 定值 main[row - j + n - 1] = true; // 加上偏移防止数组下标越界 // 副对角线方向上的单元格：横坐标 + 纵坐标 = 定值 sub[row + j] = true; // 按行遍历，所以摆放的皇后肯定不在同一行 dfs(row + 1, path); sub[row + j] = false; main[row - j + n - 1] = false; col[j] = false; path.removeLast(); } } } private List&lt;String&gt; convert2board(Deque&lt;Integer&gt; path) { List&lt;String&gt; board = new ArrayList&lt;&gt;(); for (Integer num : path) { StringBuilder row = new StringBuilder(); row.append(&quot;.&quot;.repeat(Math.max(0, n))); row.replace(num, num + 1, &quot;Q&quot;); board.add(row.toString()); } return board; } } 力扣37：编写一个程序，通过填充空格来解决数独问题。一个数独的解法需遵循如下规则： 数字1-9在每一行只能出现一次 数字1-9在每一列只能出现一次 数字1-9在每一个以粗实线分隔的3*3宫内只能出现一次 数独部分空格内已填入了数字，空白格用&#39;.&#39;表示。 输入：board = [[“5”,”3”,”.”,”.”,”7”,”.”,”.”,”.”,”.”],[“6”,”.”,”.”,”1”,”9”,”5”,”.”,”.”,”.”],[“.”,”9”,”8”,”.”,”.”,”.”,”.”,”6”,”.”],[“8”,”.”,”.”,”.”,”6”,”.”,”.”,”.”,”3”],[“4”,”.”,”.”,”8”,”.”,”3”,”.”,”.”,”1”],[“7”,”.”,”.”,”.”,”2”,”.”,”.”,”.”,”6”],[“.”,”6”,”.”,”.”,”.”,”.”,”2”,”8”,”.”],[“.”,”.”,”.”,”4”,”1”,”9”,”.”,”.”,”5”],[“.”,”.”,”.”,”.”,”8”,”.”,”.”,”7”,”9”]] 输出：[[“5”,”3”,”4”,”6”,”7”,”8”,”9”,”1”,”2”],[“6”,”7”,”2”,”1”,”9”,”5”,”3”,”4”,”8”],[“1”,”9”,”8”,”3”,”4”,”2”,”5”,”6”,”7”],[“8”,”5”,”9”,”7”,”6”,”1”,”4”,”2”,”3”],[“4”,”2”,”6”,”8”,”5”,”3”,”7”,”9”,”1”],[“7”,”1”,”3”,”9”,”2”,”4”,”8”,”5”,”6”],[“9”,”6”,”1”,”5”,”3”,”7”,”2”,”8”,”4”],[“2”,”8”,”7”,”4”,”1”,”9”,”6”,”3”,”5”],[“3”,”4”,”5”,”2”,”8”,”6”,”1”,”7”,”9”]] 解释：输入的数独如上图所示，唯一有效的解决方案如下所示： 查看解析 public class Solution { private boolean[][] row; private boolean[][] col; private boolean[][][] box; public void solveSudoku(char[][] board) { row = new boolean[9][9]; col = new boolean[9][9]; box = new boolean[3][3][9]; // 步骤 1：先遍历棋盘一次，然后每一行，每一列在 row col cell 里占住位置 for (int i = 0; i &lt; 9; i++) { for (int j = 0; j &lt; 9; j++) { if (board[i][j] != &#39;.&#39;) { // 计算在布尔数值中的下标，减去 1 使得下标从 0 开始 int index = board[i][j] - &#39;1&#39;; // 在下标为 i 这一行，记录为 true row[i][index] = true; // 在下标为 j 这一列，记录为 true col[j][index] = true; // 在横坐标为 i / 3、纵坐标 j / 3 的地方， 看到的那个数字记录为 true box[i / 3][j / 3][index] = true; } } } // 步骤 2：进行一次深度优先遍历，尝试所有的可能性 dfs(board, 0, 0); } /** * @param board 棋盘 * @param i 棋盘横坐标 * @param j 棋盘纵坐标 * @return 由于存在唯一解，搜索到一个解就可以退出了，递归函数的返回值为是否搜索到一个解 */ private boolean dfs(char[][] board, int i, int j) { // 递归终止条件 1：全部填完 if (i == 9) { return true; } // 对 &#39;.&#39; 尝试从 1 填到 9 if (board[i][j] == &#39;.&#39;) { for (char c = &#39;1&#39;; c &lt;= &#39;9&#39;; c++) { // 如果行、列、box 已经填了 c - &#39;1&#39; 则尝试下一个数字 int index = c - &#39;1&#39;; if (row[i][index] || col[j][index] || box[i / 3][j / 3][index]) { continue; } // 填写当前字符，并且对应 row、col、box 占位 board[i][j] = c; row[i][index] = true; col[j][index] = true; box[i / 3][j / 3][index] = true; // 题目保证只有唯一解，继续填写下一格 // ①：i + (j + 1) / 9 表示如果 j 已经在一列的末尾（此时 j = 8），跳转到下一行 // (j + 1) % 9 ，当 j = 8 时，j + 1 重置到 0 if (dfs(board, i + (j + 1) / 9, (j + 1) % 9)) { return true; } // 重置变量 board[i][j] = &#39;.&#39;; row[i][index] = false; col[j][index] = false; box[i / 3][j / 3][index] = false; } } else { // 填写下一格和 ① 一样 return dfs(board, i + (j + 1) / 9, (j + 1) % 9); } // 递归终止条件 2：全部尝试过以后，返回 false return false; } } .center { width: auto; display: table; margin-left: auto; margin-right: auto; }","categories":[{"name":"生活","slug":"生活","permalink":"http://goodguyjameswin.github.io/categories/生活/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://goodguyjameswin.github.io/tags/学习笔记/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"http://goodguyjameswin.github.io/categories/生活/"}]},{"title":"springsecurity学习","slug":"springsecurity学习","date":"2022-05-25T10:24:07.000Z","updated":"2022-07-18T03:57:57.615Z","comments":false,"path":"2022/05/25/springsecurity学习/","link":"","permalink":"http://goodguyjameswin.github.io/2022/05/25/springsecurity学习/","excerpt":"","text":"内容部分转载自 公众号：江南一点雨，自学笔记，仅作学习交流用 入门新建SpringBoot项目，引入依赖： &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt; &lt;/dependency&gt; 启动项目后，访问任何接口，都会自动重定向到登录页面了。 登录页面和接口在SpringSecurity中，默认的登录页面和登录接口，都是/login，只不过一个是get请求（登录页面），另一个是post请求（登录接口）。 form表单的相关配置在FormLoginConfigurer中，该类继承自AbstractAuthenticationFilterConfigurer，后者的构造方法中配置了默认的loginPage为/login。 protected AbstractAuthenticationFilterConfigurer() { this.setLoginPage(&quot;/login&quot;); } FormLoginConfigurer的初始化方法init中也调用了父类的init方法： protected final void updateAuthenticationDefaults() { if (loginProcessingUrl == null) { loginProcessingUrl(loginPage); } //省略 } 因此当用户没有给loginProcessingUrl设置值的时候，就默认使用loginPage作为loginProcessingUrl 表单参数FormLoginConfigurer类的构造方法中，有配置用户名和密码的方法： public FormLoginConfigurer() { super(new UsernamePasswordAuthenticationFilter(), null); usernameParameter(&quot;username&quot;); passwordParameter(&quot;password&quot;); } 首先调用父类构造方法，传入UsernamePasswordAuthenticationFilter实例，它将被赋值给父类的authFilter属性。 usernameParameter方法如下： public FormLoginConfigurer&lt;H&gt; usernameParameter(String usernameParameter) { // 调用父类的getAuthenticationFilter方法，返回authFilter属性，实际上是构造时创建的UsernamePasswordAuthenticationFilter实例，然后调用其setUsernameParameter方法 getAuthenticationFilter().setUsernameParameter(usernameParameter); return this; } 在类UsernamePasswordAuthenticationFilter中可以拿到请求HttpServletRequest中取出来用户的登录名和密码 protected String obtainPassword(HttpServletRequest request) { return request.getParameter(passwordParameter); } protected String obtainUsername(HttpServletRequest request) { return request.getParameter(usernameParameter); } 因此它默认的表单参数名就是username和password。 配置用户名和密码和用户相关的自动化配置类在UserDetailsServiceAutoConfiguration里面，该类的getOrDeducePassword方法中，看到打印日志： if (user.isPasswordGenerated()) { logger.info(String.format(&quot;%n%nUsing generated security password: %s%n&quot;, user.getPassword())); } 而user.getPassword出现在SecurityProperties中： /** * Default user name. */ private String name = &quot;user&quot;; /** * Password for the default user name. */ private String password = UUID.randomUUID().toString(); private boolean passwordGenerated = true; 因此默认的用户密码每次重启项目都会变，同时也知道如果要定义自己的用户名和密码，就必然要去覆盖默认配置。 @ConfigurationProperties(prefix = &quot;spring.security&quot;) publicclass SecurityProperties { ... } properties中定义的用户名密码是通过set注入到属性中去的，并且此时控制台就不会打印默认的密码了： public void setPassword(String password) { if (!StringUtils.hasLength(password)) { return; } this.passwordGenerated = false; this.password = password; } 同时密码需要经过加密处理，一般采用散列函数，并且加密过程中还需要加盐（一般存在数据库里），SpringSecurity推荐使用BCryptPasswordEncoder（自带加盐），它是PasswordEncoder的接口实现类。 public interface PasswordEncoder { // 对明文密码进行加密，返回加密之后的密文 String encode(CharSequence rawPassword); // 校对密码，以用户传来的明文密码和数据库中保存的密文密码作为参数，根据返回值判断用户密码是否输入正确 boolean matches(CharSequence rawPassword, String encodedPassword); // 是否需要再次加密 default boolean upgradeEncoding(String encodedPassword) { returnfalse; } } 定义配置类，覆盖自动配置： @Configuration public class SecurityConfig extends WebSecurityConfigurerAdapter { @Bean PasswordEncoder passwordEncoder() { // NoOpPasswordEncoder表示不对密码进行加密 return NoOpPasswordEncoder.getInstance(); } @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { // inMemoryAuthentication开启在内存中定义用户，如果要配置多个用户，用and相连 auth.inMemoryAuthentication() // withUser 中是用户名，password 中则是用户密码，roles 中是用户角色 .withUser(&quot;javaboy.org&quot;) .password(&quot;123&quot;).roles(&quot;admin&quot;); } } 由于SpringSecurity支持多种数据源，例如内存、数据库、LDAP等，这些不同来源的数据被共同封装成了一个UserDetailService接口，任何实现了该接口的对象都可以作为认证数据源 因此还可以重写WebSecurityConfigurerAdapter中的userDetailsService来提供一个userDetailsService实例进而配置多个用户： @Bean protected UserDetailsService userDetailsService() { InMemoryUserDetailsManager manager = new InMemoryUserDetailsManager(); manager.createUser(User.withUsername(&quot;javaboy&quot;).password(&quot;123&quot;).roles(&quot;admin&quot;).build()); manager.createUser(User.withUsername(&quot;江南一点雨&quot;).password(&quot;123&quot;).roles(&quot;user&quot;).build()); return manager; } 或者通过JDBC的方式根据数据库存放的用户信息创建用户： @Autowired DataSource dataSource; @Override @Bean protected UserDetailsService userDetailsService() { JdbcUserDetailsManager manager = new JdbcUserDetailsManager(); manager.setDataSource(dataSource); if (!manager.userExists(&quot;javaboy&quot;)) { manager.createUser(User.withUsername(&quot;javaboy&quot;).password(&quot;123&quot;).roles(&quot;admin&quot;).build()); } if (!manager.userExists(&quot;江南一点雨&quot;)) { manager.createUser(User.withUsername(&quot;江南一点雨&quot;).password(&quot;123&quot;).roles(&quot;user&quot;).build()); } return manager; } createUser或者userExists方法其实都是调用写好的SQL去判断的： public class JdbcUserDetailsManager extends JdbcDaoImpl implements UserDetailsManager, GroupManager { public static final String DEF_USER_EXISTS_SQL = &quot;select username from users where username = ?&quot;; private String userExistsSql = DEF_USER_EXISTS_SQL; public boolean userExists(String username) { List&lt;String&gt; users = getJdbcTemplate().queryForList(userExistsSql, new String[] { username }, String.class); if (users.size() &gt; 1) { throw new IncorrectResultSizeDataAccessException( &quot;More than one user found with name &#39;&quot; + username + &quot;&#39;&quot;, 1); } return users.size() == 1; } } 登录和注销@Override public void configure(WebSecurity web) throws Exception { // 配置要忽略的URL地址，一般针对静态文件 web.ignoring().antMatchers(&quot;/js/**&quot;, &quot;/css/**&quot;,&quot;/images/**&quot;); } @Override protected void configure(HttpSecurity http) throws Exception { http.authorizeRequests() // 配置拦截规则 .antMatchers(&quot;/admin/**&quot;).hasRole(&quot;admin&quot;) .antMatchers(&quot;/user/**&quot;).hasRole(&quot;user&quot;) .anyRequest().authenticated() // 表示其他格式的请求路径，认证（登录）后即可访问 .and() .formLogin() .loginPage(&quot;/login.html&quot;) // 配置登录页面 .loginProcessingUrl(&quot;/doLogin&quot;) // 配置提交登录数据请求接口 .usernameParameter(&quot;name&quot;) // 自定义用户名表单参数 .passwordParameter(&quot;passwd&quot;) // 自定义密码表单参数 .successForwardUrl(&quot;/index&quot;) // 登录成功后，服务端跳转到 /index 页面 .defaultSuccessUrl(&quot;/index&quot;, false) // 默认第二个参数为false，当请求需要登录才能访问的页面时，会重定向到登录页，登录成功后就直接跳转到之前访问的页面，如果之前直接访问的登录页，登陆成功后就会跳转到 /index 页面；如果第二个参数为 true，则效果与 successForwardUrl一致 .failureForwardUrl(&quot;/index&quot;) // 登录失败后发生服务端跳转 .failureUrl(&quot;/index&quot;) // 登录失败后发生重定向 .permitAll() // 表示登录相关的页面/接口不要被拦截 .and() .csrf().disable(); // 关闭csrf } 注销登录的默认接口是/logout，也可以配置： .and() .logout() .logoutUrl(&quot;/logout&quot;) // 是一个 GET 请求 .logoutRequestMatcher(new AntPathRequestMatcher(&quot;/logout&quot;,&quot;POST&quot;)) // 不仅可以修改注销 URL，还可以修改请求方式，与 logoutUrl等效 .logoutSuccessUrl(&quot;/index&quot;) // 注销成功后要跳转的页面 .deleteCookies() // 清楚 cookie .clearAuthentication(true) // 清除认证消息 .invalidateHttpSession(true) // 使HttpSession失效，可以不用配置，默认就会清除 .permitAll() .and() 回调方法登录成功后回调，可以取消重定向，而通过JSON来与前端交互： // successHandler的方法参数是一个AuthenticationSuccessHandler对象，需要实现onAuthenticationSuccess方法，它有三个参数分别是HttpServletRequest、HttpServletResponse和Authentication，而第三个参数保存了我们刚刚登录的用户信息 .successHandler((req, resp, authentication) -&gt; { Object principal = authentication.getPrincipal(); resp.setContentType(&quot;application/json;charset=utf-8&quot;); PrintWriter out = resp.getWriter(); out.write(new ObjectMapper().writeValueAsString(principal)); out.flush(); out.close(); }) 登录失败后回调，因此可以根据不同的异常类型，通过JSON返回给前端以提供给用户一个更加明确的提示： // 方法的第三个参数是一个Exception，里面保存了登录失败的原因 .failureHandler((req, resp, e) -&gt; { resp.setContentType(&quot;application/json;charset=utf-8&quot;); PrintWriter out = resp.getWriter(); RespBean respBean = RespBean.error(e.getMessage()); if (e instanceof LockedException) { respBean.setMsg(&quot;账户被锁定，请联系管理员!&quot;); } elseif (e instanceof CredentialsExpiredException) { respBean.setMsg(&quot;密码过期，请联系管理员!&quot;); } elseif (e instanceof AccountExpiredException) { respBean.setMsg(&quot;账户过期，请联系管理员!&quot;); } elseif (e instanceof DisabledException) { respBean.setMsg(&quot;账户被禁用，请联系管理员!&quot;); } elseif (e instanceof BadCredentialsException) { respBean.setMsg(&quot;用户名或者密码输入错误，请重新输入!&quot;); } out.write(new ObjectMapper().writeValueAsString(respBean)); out.flush(); out.close(); }) 查找用户名失败对应的异常是UsernameNotFoundException，而密码匹配失败对应的异常是BadCredentialsException，但实际上总是抛出BadCredentialsException异常 public Authentication authenticate(Authentication authentication) throws AuthenticationException { try { user = retrieveUser(username, (UsernamePasswordAuthenticationToken) authentication); } catch (UsernameNotFoundException notFound) { logger.debug(&quot;User &#39;&quot; + username + &quot;&#39; not found&quot;); if (hideUserNotFoundExceptions) { thrownew BadCredentialsException(messages.getMessage( &quot;AbstractUserDetailsAuthenticationProvider.badCredentials&quot;, &quot;Bad credentials&quot;)); } else { throw notFound; } } } 从源码中可以看出，因为hideUserNotFoundExceptions的值总是为true，所以抛出的UsernameNotFoundException总是被捕获 JSON交互如果不想让未认证的用户重定向到登录页面，则需要重写AuthenticationEntryPoint中接口实现类LoginUrlAuthenticationEntryPoint的commence方法： /** * Performs the redirect (or forward) to the login form URL. */ public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) { String redirectUrl = null; if (useForward) { if (forceHttps &amp;&amp; &quot;http&quot;.equals(request.getScheme())) { redirectUrl = buildHttpsRedirectUrlForRequest(request); } if (redirectUrl == null) { String loginForm = determineUrlToUseForThisRequest(request, response, authException); if (logger.isDebugEnabled()) { logger.debug(&quot;Server side forward to: &quot; + loginForm); } RequestDispatcher dispatcher = request.getRequestDispatcher(loginForm); dispatcher.forward(request, response); return; } } else { redirectUrl = buildRedirectUrlToLoginPage(request, response, authException); } redirectStrategy.sendRedirect(request, response, redirectUrl); } 可以看到默认useForward的值为false，所以请求总是走到重定向，因此自定义配置如下： .csrf().disable().exceptionHandling() .authenticationEntryPoint((req, resp, authException) -&gt; { resp.setContentType(&quot;application/json;charset=utf-8&quot;); PrintWriter out = resp.getWriter(); out.write(&quot;尚未登录，请先登录&quot;); out.flush(); out.close(); } ); 也可以配置注销成功后只返回JSON： .and() .logout() .logoutUrl(&quot;/logout&quot;) .logoutSuccessHandler((req, resp, authentication) -&gt; { resp.setContentType(&quot;application/json;charset=utf-8&quot;); PrintWriter out = resp.getWriter(); out.write(&quot;注销成功&quot;); out.flush(); out.close(); }) .permitAll() .and() 自定义授权数据库模型配置数据库连接和数据源，为用户实体类建表，用户实体类需要实现UserDetails接口，并实现接口方法： public class User implements UserDetails { private Long id; private String username; private String password; private boolean accountNonExpired; private boolean accountNonLocked; private boolean credentialsNonExpired; private boolean enabled; @ManyToMany(fetch = FetchType.EAGER,cascade = CascadeType.PERSIST) private List&lt;Role&gt; roles; @Override public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() { List&lt;SimpleGrantedAuthority&gt; authorities = new ArrayList&lt;&gt;(); for (Role role : getRoles()) { authorities.add(new SimpleGrantedAuthority(role.getName())); } return authorities; } @Override public String getPassword() { return password; } @Override public String getUsername() { return username; } @Override public boolean isAccountNonExpired() { return accountNonExpired; } @Override public boolean isAccountNonLocked() { return accountNonLocked; } @Override public boolean isCredentialsNonExpired() { return credentialsNonExpired; } @Override public boolean isEnabled() { return enabled; } //省略其他 get/set 方法 } accountNonExpired、accountNonLocked、credentialsNonExpired、enabled这四个属性分别用来描述用户的状态，表示账户是否没有过期、账户是否没有被锁定、密码是否没有过期、以及账户是否可用。 roles属性表示用户的角色，User和Role是多对多关系。getAuthorities方法返回用户的角色信息 然后自定义UserService实现UserDetailsService接口，实现loadUserByUsername方法，参数就是用户登录时传入的用户名，根据用户名去查询用户信息（查出来之后，系统会自动进行密码比对）。 @Service public class HrService implements UserDetailsService { @Autowired HrMapper hrMapper; @Autowired HrRoleMapper hrRoleMapper; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException { Hr hr = hrMapper.loadUserByUsername(username); if (hr == null) { throw new UsernameNotFoundException(&quot;用户名不存在!&quot;); } hr.setRoles(hrMapper.getHrRolesById(hr.getId())); return hr; } // ... } 在SecurityConfig中配置用户： @Autowired UserService userService; @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { auth.userDetailsService(userService); } 配置登录验证码编写验证码生成类： /** * 生成验证码的工具类 */ public class VerifyCode { private int width = 100;// 生成验证码图片的宽度 private int height = 50;// 生成验证码图片的高度 private String[] fontNames = { &quot;宋体&quot;, &quot;楷体&quot;, &quot;隶书&quot;, &quot;微软雅黑&quot; }; private Color bgColor = new Color(255, 255, 255);// 定义验证码图片的背景颜色为白色 private Random random = new Random(); private String codes = &quot;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;; private String text;// 记录随机字符串 /** * 获取一个随意颜色 * * @return */ private Color randomColor() { int red = random.nextInt(150); int green = random.nextInt(150); int blue = random.nextInt(150); returnnew Color(red, green, blue); } /** * 获取一个随机字体 * * @return */ private Font randomFont() { String name = fontNames[random.nextInt(fontNames.length)]; int style = random.nextInt(4); int size = random.nextInt(5) + 24; returnnew Font(name, style, size); } /** * 获取一个随机字符 * * @return */ private char randomChar() { return codes.charAt(random.nextInt(codes.length())); } /** * 创建一个空白的BufferedImage对象 * * @return */ private BufferedImage createImage() { BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB); Graphics2D g2 = (Graphics2D) image.getGraphics(); g2.setColor(bgColor);// 设置验证码图片的背景颜色 g2.fillRect(0, 0, width, height); return image; } public BufferedImage getImage() { BufferedImage image = createImage(); Graphics2D g2 = (Graphics2D) image.getGraphics(); StringBuffer sb = new StringBuffer(); for (int i = 0; i &lt; 4; i++) { String s = randomChar() + &quot;&quot;; sb.append(s); g2.setColor(randomColor()); g2.setFont(randomFont()); float x = i * width * 1.0f / 4; g2.drawString(s, x, height - 15); } this.text = sb.toString(); drawLine(image); return image; } /** * 绘制干扰线 * * @param image */ private void drawLine(BufferedImage image) { Graphics2D g2 = (Graphics2D) image.getGraphics(); int num = 5; for (int i = 0; i &lt; num; i++) { int x1 = random.nextInt(width); int y1 = random.nextInt(height); int x2 = random.nextInt(width); int y2 = random.nextInt(height); g2.setColor(randomColor()); g2.setStroke(new BasicStroke(1.5f)); g2.drawLine(x1, y1, x2, y2); } } public String getText() { return text; } public static void output(BufferedImage image, OutputStream out) throws IOException { ImageIO.write(image, &quot;JPEG&quot;, out); } } 通过流将验证码写到前端页面&lt;img src=&quot;/vercode&quot; alt=&quot;&quot;&gt;： @RestController public class VerifyCodeController { @GetMapping(&quot;/vercode&quot;) public void code(HttpServletRequest req, HttpServletResponse resp) throws IOException { VerifyCode vc = new VerifyCode(); // 创建一个 VerifyCode 对象 BufferedImage image = vc.getImage(); String text = vc.getText(); HttpSession session = req.getSession(); session.setAttribute(&quot;index_code&quot;, text); // 将生成的验证码字符保存到 session 中 VerifyCode.output(image, resp.getOutputStream()); } } 用户登录的用户名/密码是在UsernamePasswordAuthenticationFilter类中处理的： public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException { String username = obtainUsername(request); String password = obtainPassword(request); //省略 } protected String obtainPassword(HttpServletRequest request) { return request.getParameter(passwordParameter); } protected String obtainUsername(HttpServletRequest request) { return request.getParameter(usernameParameter); } SpringSecurity默认通过key/value的形式来传递登录参数，因此可以自定义一个过滤器来代替UsernamePasswordAuthenticationFilter，然后获取JSON形式数据 publicclass LoginFilter extends UsernamePasswordAuthenticationFilter { @Override public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException { if (!request.getMethod().equals(&quot;POST&quot;)) { // 登录请求肯定是 POST throw new AuthenticationServiceException( &quot;Authentication method not supported: &quot; + request.getMethod()); } String verify_code = (String) request.getSession().getAttribute(&quot;verify_code&quot;); // 处理验证码 if (request.getContentType().equals(MediaType.APPLICATION_JSON_VALUE) || request.getContentType().equals(MediaType.APPLICATION_JSON_UTF8_VALUE)) { Map&lt;String, String&gt; loginData = new HashMap&lt;&gt;(); try { // 通过读取 request 中的 I/O 流，将 JSON 映射到一个 Map 上 loginData = new ObjectMapper().readValue(request.getInputStream(), Map.class); } catch (IOException e) { }finally { String code = loginData.get(&quot;code&quot;); checkCode(response, code, verify_code); } String username = loginData.get(getUsernameParameter()); String password = loginData.get(getPasswordParameter()); if (username == null) { username = &quot;&quot;; } if (password == null) { password = &quot;&quot;; } username = username.trim(); UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationToken( username, password); setDetails(request, authRequest); return this.getAuthenticationManager().authenticate(authRequest); } else { checkCode(response, request.getParameter(&quot;code&quot;), verify_code); // 既支持 JSON 形式传递参数，也支持 key/value 形式传递参数 return super.attemptAuthentication(request, response); } } public void checkCode(HttpServletResponse resp, String code, String verify_code) { if (code == null || verify_code == null || &quot;&quot;.equals(code) || !verify_code.toLowerCase().equals(code.toLowerCase())) { //验证码不正确 throw new AuthenticationServiceException(&quot;验证码不正确&quot;); } } } 提供一个LoginFilter的实例，原本在SecurityConfig#configure方法中关于form表单的配置就会失效，那些失效的属性，都可以在配置LoginFilter实例的时候配置。 @Bean LoginFilter loginFilter() throws Exception { LoginFilter loginFilter = new LoginFilter(); loginFilter.setAuthenticationSuccessHandler(new AuthenticationSuccessHandler() { @Override public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException { response.setContentType(&quot;application/json;charset=utf-8&quot;); PrintWriter out = response.getWriter(); Hr hr = (Hr) authentication.getPrincipal(); hr.setPassword(null); RespBean ok = RespBean.ok(&quot;登录成功!&quot;, hr); String s = new ObjectMapper().writeValueAsString(ok); out.write(s); out.flush(); out.close(); } }); loginFilter.setAuthenticationFailureHandler(new AuthenticationFailureHandler() { @Override public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception) throws IOException, ServletException { response.setContentType(&quot;application/json;charset=utf-8&quot;); PrintWriter out = response.getWriter(); RespBean respBean = RespBean.error(exception.getMessage()); if (exception instanceof LockedException) { respBean.setMsg(&quot;账户被锁定，请联系管理员!&quot;); } elseif (exception instanceof CredentialsExpiredException) { respBean.setMsg(&quot;密码过期，请联系管理员!&quot;); } elseif (exception instanceof AccountExpiredException) { respBean.setMsg(&quot;账户过期，请联系管理员!&quot;); } elseif (exception instanceof DisabledException) { respBean.setMsg(&quot;账户被禁用，请联系管理员!&quot;); } elseif (exception instanceof BadCredentialsException) { respBean.setMsg(&quot;用户名或者密码输入错误，请重新输入!&quot;); } out.write(new ObjectMapper().writeValueAsString(respBean)); out.flush(); out.close(); } }); loginFilter.setAuthenticationManager(authenticationManagerBean()); // 根据 WebSecurityConfigurerAdapter 中提供的配置 loginFilter.setFilterProcessesUrl(&quot;/doLogin&quot;); // 默认是 /login return loginFilter; } 最后调用addFilterAt方法完成替换操作： @Override protected void configure(HttpSecurity http) throws Exception { http.authorizeRequests() ... //省略 http.addFilterAt(loginFilter(), UsernamePasswordAuthenticationFilter.class); } 自动登录认证原理SpringSecurity中有个重要对象Authentication，可以在任何地方注入它以获得当前登录用户信息，它本身是一个接口，最常用的实现类就是UsernamePasswordAuthenticationToken，这个类及其父类的属性就保存了登录用户的基本信息。那么登录信息是如何存到两个对象里的？ SpringSecurity中，认证和授权的相关校验都是在一系列的过滤器链中完成的，而认证相关的就是UsernamePasswordAuthenticationFilter。 public class UsernamePasswordAuthenticationFilter extends AbstractAuthenticationProcessingFilter { public UsernamePasswordAuthenticationFilter() { super(new AntPathRequestMatcher(&quot;/login&quot;, &quot;POST&quot;)); } public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException { String username = obtainUsername(request); String password = obtainPassword(request); UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationToken( username, password); setDetails(request, authRequest); returnthis.getAuthenticationManager().authenticate(authRequest); } protected String obtainPassword(HttpServletRequest request) { return request.getParameter(passwordParameter); } protected String obtainUsername(HttpServletRequest request) { return request.getParameter(usernameParameter); } protected void setDetails(HttpServletRequest request, UsernamePasswordAuthenticationToken authRequest) { authRequest.setDetails(authenticationDetailsSource.buildDetails(request)); } } 首先通过obtainUsername和obtainPassword提取请求里的用户名和密码，因此默认的表单登录要通过key/value形式传递参数 接下来构造UsernamePasswordAuthenticationToken对象，传入的参数分别对应其中的principal属性和credentials属性 然后通过setDetails方法给其details属性赋值（属性在父类AbstractAuthenticationToken（实现了Authentication接口）中定义），details是一个对象，里面存放WebAuthenticationDetails实例，其中主要描述了请求的remoteAddress和sessionId 调用authenticate方法进行校验 其中校验操作首先要获取一个AuthenticationManager，拿到的是ProviderManager，因此进入其authenticate方法中： public Authentication authenticate(Authentication authentication) throws AuthenticationException { Class&lt;? extends Authentication&gt; toTest = authentication.getClass(); for (AuthenticationProvider provider : getProviders()) { if (!provider.supports(toTest)) { continue; } result = provider.authenticate(authentication); if (result != null) { copyDetails(authentication, result); break; } } if (result == null &amp;&amp; parent != null) { result = parentResult = parent.authenticate(authentication); } if (result != null) { if (eraseCredentialsAfterAuthentication &amp;&amp; (result instanceof CredentialsContainer)) { ((CredentialsContainer) result).eraseCredentials(); } if (parentResult == null) { eventPublisher.publishAuthenticationSuccess(result); } return result; } throw lastException; } 首先获取authentication的Class，判断当前provider是否支持该authentication 如果支持，则调用provider的authenticate方法开始做校验，校验完成后，会返回一个新的Authentication 这里的provider可能有多个，如果provider的authenticate方法没能正常返回一个Authentication，则调用provider的parent的authenticate方法继续校验 copyDetails方法则用来把旧Token的details属性拷贝到新的Token中来 接下来会调用eraseCredentials方法擦除凭证信息，也就是密码，这个擦除方法比较简单，就是将Token中的credentials属性置空 最后通过publishAuthenticationSuccess方法将登录成功的事件广播出去 需要注意的是，方法中的for循环里，第一个拿到的provider是一个AnonymousAuthenticationProvider，它不支持UsernamePasswordAuthenticationToken，因此会直接调用parent的authenticate方法进行校验。 而这个parent就是ProviderManager，因此会再次回到authenticate方法，provider也变成了DaoAuthenticationProvider，它是支持UsernamePasswordAuthenticationToken的，它继承自父类AbstractUserDetailsAuthenticationProvider，并且没有重写其authenticate方法，因此直接调用这个方法： public Authentication authenticate(Authentication authentication) throws AuthenticationException { String username = (authentication.getPrincipal() == null) ? &quot;NONE_PROVIDED&quot; : authentication.getName(); user = retrieveUser(username,(UsernamePasswordAuthenticationToken) authentication); preAuthenticationChecks.check(user); additionalAuthenticationChecks(user,(UsernamePasswordAuthenticationToken) authentication); postAuthenticationChecks.check(user); Object principalToReturn = user; if (forcePrincipalAsString) { principalToReturn = user.getUsername(); } return createSuccessAuthentication(principalToReturn, authentication, user); } 首先从·Authentication中提取登录用户名 通过拿到的username去调用retrieveUser方法获取当前用户对象，此时会调用loadUserByUsername方法，所以这里返回的user其实就是登录对象 接下来调用preAuthenticationChecks.check方法检验user中的各个账户状态属性是否正常，例如账户是否被禁用、账户是否被锁定、账户是否过期等等 additionalAuthenticationChecks方法则是做密码比对的 最后在postAuthenticationChecks.check方法中检查密码是否过期 接下来有一个forcePrincipalAsString属性，这个是是否强制将Authentication中的principal属性设置为字符串，默认为false 最后，通过createSuccessAuthentication方法构建一个新的UsernamePasswordAuthenticationToken 来到UsernamePasswordAuthenticationFilter的父类AbstractAuthenticationProcessingFilter中，如果需要自定义过滤器，都需要继承自这个类，而UsernamePasswordAuthenticationFilter的attemptAuthentication方法就是在这个父类的doFilter中被触发的： public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException { HttpServletRequest request = (HttpServletRequest) req; HttpServletResponse response = (HttpServletResponse) res; Authentication authResult; try { authResult = attemptAuthentication(request, response); if (authResult == null) { return; } sessionStrategy.onAuthentication(authResult, request, response); } catch (InternalAuthenticationServiceException failed) { unsuccessfulAuthentication(request, response, failed); return; } catch (AuthenticationException failed) { unsuccessfulAuthentication(request, response, failed); return; } if (continueChainBeforeSuccessfulAuthentication) { chain.doFilter(request, response); } successfulAuthentication(request, response, chain, authResult); } 当attemptAuthentication方法被调用时，如果登录成功，successAuthentication方法就会被调用： protected void successfulAuthentication(HttpServletRequest request, HttpServletResponse response, FilterChain chain, Authentication authResult) throws IOException, ServletException { SecurityContextHolder.getContext().setAuthentication(authResult); rememberMeServices.loginSuccess(request, response, authResult); // Fire event if (this.eventPublisher != null) { eventPublisher.publishEvent(new InteractiveAuthenticationSuccessEvent( authResult, this.getClass())); } successHandler.onAuthenticationSuccess(request, response, authResult); } 其中可以看出，登录的用户信息可以通过SecurityContextHolder.getContext()获得，如果想要修改，也可以在这里修改。并且从最后的successHandler.onAuthenticationSuccess可以看出，SecurityConfig中配置登录成功的回调方法就是在这里触发的。 需要注意的是，SecurityContextHolder中的数据，本质是保存在ThreadLocal中，它的限制了仅有保存该数据的线程才能访问。然而正常情况下，我们每次登录都能获取到登录用户信息。这是因为请求在到达UsernamePasswordAuthenticationFilter之前，会先经过另一个过滤器： public class SecurityContextPersistenceFilter extends GenericFilterBean { public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException { HttpServletRequest request = (HttpServletRequest) req; HttpServletResponse response = (HttpServletResponse) res; HttpRequestResponseHolder holder = new HttpRequestResponseHolder(request, response); SecurityContext contextBeforeChainExecution = repo.loadContext(holder); try { SecurityContextHolder.setContext(contextBeforeChainExecution); chain.doFilter(holder.getRequest(), holder.getResponse()); } finally { SecurityContext contextAfterChainExecution = SecurityContextHolder .getContext(); SecurityContextHolder.clearContext(); repo.saveContext(contextAfterChainExecution, holder.getRequest(), holder.getResponse()); } } } SecurityContextPersistenceFilter继承自 GenericFilterBean，而GenericFilterBean则是Filter的实现 在doFilter方法中，它首先会从repo中读取一个SecurityContext出来，这里的repo实际上就是HttpSessionSecurityContextRepository，读取SecurityContext的操作会进入到readSecurityContextFromSession方法中，进入读取的核心方法Object contextFromSession = httpSession.getAttribute(springSecurityContextKey);，而这里的springSecurityContextKey实际上就是SPRING_SECURITY_CONTEXT，读取出来的对象最终会被转为一个SecurityContext对象 SecurityContext是一个接口，它有一个唯一的实现类SecurityContextImpl，这个实现类其实就是用户信息在session中保存的value 在拿到SecurityContext之后，通过SecurityContextHolder.setContext方法将这个SecurityContext设置到ThreadLocal中去 在过滤器链走完，数据响应给前端之后，从SecurityContextHolder中获取到SecurityContext，然后把SecurityContextHolder清空，最后调用repo.saveContext方法将获取到的SecurityContext存入session中 因此可以发现，如果登录请求不走SecurityContextPersistenceFilter过滤器，意味着不会将登录信息存入session，进而导致后续请求无法获取到用户信息 记住我在SpringSecurity中配置即可： @Override protected void configure(HttpSecurity http) throws Exception { http.authorizeRequests() .anyRequest().authenticated() .and() .formLogin() .and() .rememberMe() // 开启自动登录 .key(&quot;javaboy&quot;) // 设置令牌密钥 .and() .csrf().disable(); } 此时可以发现浏览器cookie中多了个remember-me令牌，其生成过程如下，核心的处理方法在TokenBasedRememberMeServices中： @Override public void onLoginSuccess(HttpServletRequest request, HttpServletResponse response, Authentication successfulAuthentication) { String username = retrieveUserName(successfulAuthentication); String password = retrievePassword(successfulAuthentication); if (!StringUtils.hasLength(password)) { UserDetails user = getUserDetailsService().loadUserByUsername(username); password = user.getPassword(); } int tokenLifetime = calculateLoginLifetime(request, successfulAuthentication); long expiryTime = System.currentTimeMillis(); expiryTime += 1000L * (tokenLifetime &lt; 0 ? TWO_WEEKS_S : tokenLifetime); String signatureValue = makeTokenSignature(expiryTime, username, password); setCookie(new String[] { username, Long.toString(expiryTime), signatureValue }, tokenLifetime, request, response); } protected String makeTokenSignature(long tokenExpiryTime, String username, String password) { String data = username + &quot;:&quot; + tokenExpiryTime + &quot;:&quot; + password + &quot;:&quot; + getKey(); MessageDigest digest; digest = MessageDigest.getInstance(&quot;MD5&quot;); return new String(Hex.encode(digest.digest(data.getBytes()))); } 首先从登录成功的Authentication中提取出用户名/密码 由于登录成功之后，密码可能被擦除了，所以，如果一开始没有拿到密码，就再从UserDetailsService中重新加载用户并重新获取密码 再接下来去获取令牌的有效期，令牌有效期默认就是两周 再接下来调用makeTokenSignature方法去计算散列值，实际上就是根据username、令牌有效期以及password、key一起计算一个散列值。如果我们没有自己去设置这个key，默认是在RememberMeConfigurer#getKey方法中进行设置的，它的值是一个UUID字符串 最后，将用户名、令牌有效期以及计算得到的散列值放入Cookie中 需要注意的是，如果服务端重启，自动生成的key就会变化，导致之前的remember-me令牌失效，因此需要自己配置key。触发流程是：AbstractAuthenticationProcessingFilter#doFilter-&gt;AbstractAuthenticationProcessingFilter#successfulAuthentication-&gt;AbstractRememberMeServices#loginSuccess-&gt;TokenBasedRememberMeServices#onLoginSuccess 认证过程则可以从RememberMeAuthenticationFilter过滤器中看到： public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException { HttpServletRequest request = (HttpServletRequest) req; HttpServletResponse response = (HttpServletResponse) res; if (SecurityContextHolder.getContext().getAuthentication() == null) { Authentication rememberMeAuth = rememberMeServices.autoLogin(request, response); if (rememberMeAuth != null) { rememberMeAuth = authenticationManager.authenticate(rememberMeAuth); SecurityContextHolder.getContext().setAuthentication(rememberMeAuth); onSuccessfulAuthentication(request, response, rememberMeAuth); if (this.eventPublisher != null) { eventPublisher .publishEvent(new InteractiveAuthenticationSuccessEvent( SecurityContextHolder.getContext() .getAuthentication(), this.getClass())); } if (successHandler != null) { successHandler.onAuthenticationSuccess(request, response, rememberMeAuth); return; } } chain.doFilter(request, response); } else { chain.doFilter(request, response); } } 可以看到，如果从SecurityContextHolder中无法获取当前登录用户实例，那么就调用rememberMeServices.autoLogin进行登录： public final Authentication autoLogin(HttpServletRequest request, HttpServletResponse response) { String rememberMeCookie = extractRememberMeCookie(request); if (rememberMeCookie == null) { return null; } logger.debug(&quot;Remember-me cookie detected&quot;); if (rememberMeCookie.length() == 0) { logger.debug(&quot;Cookie was empty&quot;); cancelCookie(request, response); return null; } UserDetails user = null; try { String[] cookieTokens = decodeCookie(rememberMeCookie); user = processAutoLoginCookie(cookieTokens, request, response); userDetailsChecker.check(user); logger.debug(&quot;Remember-me cookie accepted&quot;); return createSuccessfulAuthentication(request, user); } catch (CookieTheftException cte) { throw cte; } cancelCookie(request, response); return null; } 这里就是提取cookie信息，并对cookie信息进行解码，然后调用processAutoLoginCookie方法做校验，核心流程就是首先获取用户名和过期时间，再根据用户名查询到用户密码，然后通过MD5散列函数计算出散列值，在将拿到的散列值和浏览器传递来的散列值进行对比，就能确认这个令牌是否有效，进而确认登录是否有效。 有时为了提高安全性，需要做持久化令牌和二次校验。在持久化令牌中，新增了两个经过MD5散列函数计算的校验参数，一个是series，另一个是token。其中，series只有当用户在使用用户名/密码登录时，才会生成或者更新，而token只要有新的会话，就会重新生成，这样就可以避免一个用户同时在多端登录。 持久化令牌的具体处理类是PersistentTokenBasedRememberMeServices，保存令牌的处理类则是PersistentRememberMeToken： public class PersistentRememberMeToken { private final String username; private final String series; private final String tokenValue; private final Date date; // 表示上一次使用自动登录的时间 // 省略 getter、setter方法 } 首先需要一张表来记录令牌信息，可以使用系统默认提供的JDBC来操作JdbcTokenRepositoryImpl： @Autowired DataSource dataSource; @Bean JdbcTokenRepositoryImpl jdbcTokenRepository() { JdbcTokenRepositoryImpl jdbcTokenRepository = new JdbcTokenRepositoryImpl(); jdbcTokenRepository.setDataSource(dataSource); return jdbcTokenRepository; } @Override protected void configure(HttpSecurity http) throws Exception { http.authorizeRequests() .anyRequest().authenticated() .and() .formLogin() .and() .rememberMe() .key(&quot;javaboy&quot;) .tokenRepository(jdbcTokenRepository()) .and() .csrf().disable(); } 通过提供一个JdbcTokenRepositoryImpl实例，给其配置DataSource数据源，最后通过tokenRepository将其纳入配置中即可。 这时生成/解析令牌的实现类是PersistentTokenBasedRememberMeServices，令牌生成过程对应的方法是： protected void onLoginSuccess(HttpServletRequest request, HttpServletResponse response, Authentication successfulAuthentication) { String username = successfulAuthentication.getName(); PersistentRememberMeToken persistentToken = new PersistentRememberMeToken( username, generateSeriesData(), generateTokenData(), new Date()); tokenRepository.createNewToken(persistentToken); addCookie(persistentToken, request, response); } protected String generateSeriesData() { byte[] newSeries = new byte[seriesLength]; random.nextBytes(newSeries); return new String(Base64.getEncoder().encode(newSeries)); } protected String generateTokenData() { byte[] newToken = new byte[tokenLength]; random.nextBytes(newToken); return new String(Base64.getEncoder().encode(newToken)); } private void addCookie(PersistentRememberMeToken token, HttpServletRequest request, HttpServletResponse response) { setCookie(new String[] { token.getSeries(), token.getTokenValue() }, getTokenValiditySeconds(), request, response); } 登录成功后，还是首先获取到用户名username 然后构造一个PersistentRememberMeToken，generateSeriesData和generateTokenData方法分别用来获取series和token，具体的生成过程实际上就是调用SecureRandom生成随机数再进行Base64编码，SecureRandom则采用的是类似于密码学的随机数生成规则，其输出结果较难预测，适合在登录这样的场景下使用 调用tokenRepository实例中的createNewToken方法，tokenRepository实际上就是我们一开始配置的JdbcTokenRepositoryImpl，所以这行代码实际上就是将PersistentRememberMeToken存入数据库中 令牌校验过程对应的方法是： protected UserDetails processAutoLoginCookie(String[] cookieTokens, HttpServletRequest request, HttpServletResponse response) { final String presentedSeries = cookieTokens[0]; final String presentedToken = cookieTokens[1]; PersistentRememberMeToken token = tokenRepository .getTokenForSeries(presentedSeries); if (!presentedToken.equals(token.getTokenValue())) { tokenRepository.removeUserTokens(token.getUsername()); throw new CookieTheftException( messages.getMessage( &quot;PersistentTokenBasedRememberMeServices.cookieStolen&quot;, &quot;Invalid remember-me token (Series/token) mismatch. Implies previous cookie theft attack.&quot;)); } if (token.getDate().getTime() + getTokenValiditySeconds() * 1000L &lt; System .currentTimeMillis()) { throw new RememberMeAuthenticationException(&quot;Remember-me login has expired&quot;); } PersistentRememberMeToken newToken = new PersistentRememberMeToken( token.getUsername(), token.getSeries(), generateTokenData(), new Date()); tokenRepository.updateToken(newToken.getSeries(), newToken.getTokenValue(), newToken.getDate()); addCookie(newToken, request, response); return getUserDetailsService().loadUserByUsername(token.getUsername()); } 首先从前端传来的cookie中解析出series和token 根据series从数据库中查询出一个PersistentRememberMeToken实例 如果查出来的token和前端传来的token不相同，说明账号可能被人盗用（别人用你的令牌登录之后，token会变）。此时根据用户名移除相关的token，相当于必须要重新输入用户名密码登录才能获取新的自动登录权限 校验token是否过期 构造新的PersistentRememberMeToken对象，并且更新数据库中的token，新的会话都会对应一个新的token 将新的令牌重新添加到cookie中返回 根据用户名查询用户信息，再走一遍登录流程 二次检验则可以通过配置接口访问来实现： @Override protected void configure(HttpSecurity http) throws Exception { http.authorizeRequests() .antMatchers(&quot;/rememberme&quot;).rememberMe() // 需要 rememberMe 才能访问 .antMatchers(&quot;/admin&quot;).fullyAuthenticated() // 不同于 authenticated，fullyAuthenticated 不包含自动登录的形式 .anyRequest().authenticated() .and() .formLogin() .and() .rememberMe() .key(&quot;javaboy&quot;) .tokenRepository(jdbcTokenRepository()) .and() .csrf().disable(); } 设置会话数想用新的登录踢掉旧的登录，只需要将最大会话数设置为1即可，或者设置禁止后面的登录操作： @Override protected void configure(HttpSecurity http) throws Exception { http.authorizeRequests() .anyRequest().authenticated() .and() .formLogin() .loginPage(&quot;/login.html&quot;) .permitAll() .and() .csrf().disable() .sessionManagement() .maximumSessions(1); // 配置最大会话数为 1 .maxSessionsPreventsLogin(true); // 禁止新的登录操作 } 还需要再提供一个Bean： @Bean HttpSessionEventPublisher httpSessionEventPublisher() { return new HttpSessionEventPublisher(); } 在SpringSecurity中，它是通过监听session的销毁事件，来及时清理session的记录。用户从不同的浏览器登录后，都会有对应的session，当用户注销登录之后，session就会失效，但是默认的失效是通过调用StandardSession#invalidate方法来实现的，这一个失效事件无法被Spring容器感知到，进而导致当用户注销登录之后，SpringSecurity没有及时清理会话信息表，以为用户还在线，进而导致用户无法重新登录进来。 因此提供一个实现了HttpSessionListener接口的类，在该Bean中，可以将session创建以及销毁的事件及时感知到，并且调用Spring中的事件机制将相关的创建和销毁事件发布出去，进而被SpringSecurity感知到： public void sessionCreated(HttpSessionEvent event) { HttpSessionCreatedEvent e = new HttpSessionCreatedEvent(event.getSession()); getContext(event.getSession().getServletContext()).publishEvent(e); } public void sessionDestroyed(HttpSessionEvent event) { HttpSessionDestroyedEvent e = new HttpSessionDestroyedEvent(event.getSession()); getContext(event.getSession().getServletContext()).publishEvent(e); } 事实上AbstractAuthenticationProcessingFilter#doFilter方法调用中，走完认证流程后，接下来就是调用sessionStrategy.onAuthentication方法，这个方法就是用来处理session并发问题的： public class ConcurrentSessionControlAuthenticationStrategy implements MessageSourceAware, SessionAuthenticationStrategy { public void onAuthentication(Authentication authentication, HttpServletRequest request, HttpServletResponse response) { final List&lt;SessionInformation&gt; sessions = sessionRegistry.getAllSessions( authentication.getPrincipal(), false); int sessionCount = sessions.size(); int allowedSessions = getMaximumSessionsForThisUser(authentication); if (sessionCount &lt; allowedSessions) { // They haven&#39;t got too many login sessions running at present return; } if (allowedSessions == -1) { // We permit unlimited logins return; } if (sessionCount == allowedSessions) { HttpSession session = request.getSession(false); if (session != null) { // Only permit it though if this request is associated with one of the // already registered sessions for (SessionInformation si : sessions) { if (si.getSessionId().equals(session.getId())) { return; } } } // If the session is null, a new one will be created by the parent class, // exceeding the allowed number } allowableSessionsExceeded(sessions, allowedSessions, sessionRegistry); } protected void allowableSessionsExceeded(List&lt;SessionInformation&gt; sessions, int allowableSessions, SessionRegistry registry) throws SessionAuthenticationException { if (exceptionIfMaximumExceeded || (sessions == null)) { throw new SessionAuthenticationException(messages.getMessage( &quot;ConcurrentSessionControlAuthenticationStrategy.exceededAllowed&quot;, new Object[] {allowableSessions}, &quot;Maximum sessions of {0} for this principal exceeded&quot;)); } // Determine least recently used sessions, and mark them for invalidation sessions.sort(Comparator.comparing(SessionInformation::getLastRequest)); int maximumSessionsExceededBy = sessions.size() - allowableSessions + 1; List&lt;SessionInformation&gt; sessionsToBeExpired = sessions.subList(0, maximumSessionsExceededBy); for (SessionInformation session: sessionsToBeExpired) { session.expireNow(); } } } 首先调用sessionRegistry.getAllSessions方法获取当前用户的所有session，该方法在调用时，传递两个参数，一个是当前用户的authentication，另一个参数false表示不包含已经过期的session（在用户登录成功后，会将用户的sessionid存起来，其中key是用户的主体（principal），value则是该主题对应的sessionid组成的一个集合） 接下来计算出当前用户已经有几个有效session了，同时获取允许的session并发数 如果当前session数（sessionCount）小于session并发数（allowedSessions），则不做任何处理；如果allowedSessions的值为-1，表示对session数量不做任何限制；如果当前session数（sessionCount）等于session并发数，且当前session不为null，并且已经存在于session中了，那么不做任何处理，否则说明将有一个新的session被创建出来，届时当前sessionCount数就会超过allowedSessions，进入策略判断方法allowableSessionsExceeded allowableSessionsExceeded方法中，首先会有exceptionIfMaximumExceeded属性，这就是我们在SecurityConfig中配置的maxSessionsPreventsLogin的值，默认为false，如果为true，就直接抛出异常，那么这次登录就失败了，如果为false，则对sessions按照请求时间进行排序，然后再使多余的session过期 SpringSecurity中通过SessionRegistryImpl类来实现对会话信息的统一管理： public class SessionRegistryImpl implements SessionRegistry, ApplicationListener&lt;SessionDestroyedEvent&gt; { /** &lt;principal:Object,SessionIdSet&gt; */ private final ConcurrentMap&lt;Object, Set&lt;String&gt;&gt; principals; /** &lt;sessionId:Object,SessionInformation&gt; */ private final Map&lt;String, SessionInformation&gt; sessionIds; public void registerNewSession(String sessionId, Object principal) { if (getSessionInformation(sessionId) != null) { removeSessionInformation(sessionId); } sessionIds.put(sessionId, new SessionInformation(principal, sessionId, new Date())); principals.compute(principal, (key, sessionsUsedByPrincipal) -&gt; { if (sessionsUsedByPrincipal == null) { sessionsUsedByPrincipal = new CopyOnWriteArraySet&lt;&gt;(); } sessionsUsedByPrincipal.add(sessionId); return sessionsUsedByPrincipal; }); } public void removeSessionInformation(String sessionId) { SessionInformation info = getSessionInformation(sessionId); if (info == null) { return; } sessionIds.remove(sessionId); principals.computeIfPresent(info.getPrincipal(), (key, sessionsUsedByPrincipal) -&gt; { sessionsUsedByPrincipal.remove(sessionId); if (sessionsUsedByPrincipal.isEmpty()) { sessionsUsedByPrincipal = null; } return sessionsUsedByPrincipal; }); } } 声明的principals是一个支持并发访问的map即可，它的value是一个set集合，保存了这个用户对应的sessionId；如果新的session需要添加，就在registerNewSession方法中添加，具体是调用principals.compute方法，如果用户注销登录，sessionId需要移除，相关操作类似。它的key是principal对象，因此要重写equals方法和hashCode方法。 这一点可以从SpringSecurity中定义的基于内存的用户中看出： public class User implements UserDetails, CredentialsContainer { private String password; private final String username; private final Set&lt;GrantedAuthority&gt; authorities; private final boolean accountNonExpired; private final boolean accountNonLocked; private final boolean credentialsNonExpired; private final boolean enabled; @Override public boolean equals(Object rhs) { if (rhs instanceof User) { return username.equals(((User) rhs).username); } return false; } @Override public int hashCode() { return username.hashCode(); } } 扩展认证信息Authentication中getDetails方法用来存储有关身份认证的其他信息，比如IP地址、sessionId和证书信息等。 在用户登录必经的过滤器UsernamePasswordAuthenticationFilter中，attemptAuthentication方法里有一个setDetails方法： protected void setDetails(HttpServletRequest request, UsernamePasswordAuthenticationToken authRequest) { authRequest.setDetails(authenticationDetailsSource.buildDetails(request)); } details的值是通过authenticationDetailsSource构建的： public class WebAuthenticationDetailsSource implements AuthenticationDetailsSource&lt;HttpServletRequest, WebAuthenticationDetails&gt; { public WebAuthenticationDetails buildDetails(HttpServletRequest context) { return new WebAuthenticationDetails(context); } } public class WebAuthenticationDetails implements Serializable { private final String remoteAddress; private final String sessionId; public WebAuthenticationDetails(HttpServletRequest request) { this.remoteAddress = request.getRemoteAddr(); HttpSession session = request.getSession(false); this.sessionId = (session != null) ? session.getId() : null; } //省略其他方法 } 实际上构建的是WebAuthenticationDetails，其中定义了用户登录地址和sessionId，而这个类可以自己定制，那么WebAuthenticationDetailsSource也需要重新定义： public class MyWebAuthenticationDetails extends WebAuthenticationDetails { public MyWebAuthenticationDetails(HttpServletRequest req) { super(req); // ... } // ... } @Component public class MyWebAuthenticationDetailsSource implements AuthenticationDetailsSource&lt;HttpServletRequest,MyWebAuthenticationDetails&gt; { @Override public MyWebAuthenticationDetails buildDetails(HttpServletRequest context) { return new MyWebAuthenticationDetails(context); } } 如果要扩展属性，只需要在WebAuthenticationDetails中定义更多属性，然后从HttpServletRequest中提取出来设置给对应的属性即可，登录成功后就可以随时随地获取这些属性了。最后需要在SecurityConfig中配置： @Autowired MyWebAuthenticationDetailsSource myWebAuthenticationDetailsSource; @Override protected void configure(HttpSecurity http) throws Exception { http.authorizeRequests() ... .and() .formLogin() .authenticationDetailsSource(myWebAuthenticationDetailsSource) ... } 防火墙SpringSecurity中提供了HttpFirewall，它可以自动处理一些非法请求。它有两个实现类：DefaultHttpFirewall和StrictHttpFirewall，前者的限制相比后者宽松，SpringSecurity中默认使用后者。 public class StrictHttpFirewall implements HttpFirewall { private Set&lt;String&gt; allowedHttpMethods = createDefaultAllowedHttpMethods(); private static Set&lt;String&gt; createDefaultAllowedHttpMethods() { Set&lt;String&gt; result = new HashSet&lt;&gt;(); result.add(HttpMethod.DELETE.name()); result.add(HttpMethod.GET.name()); result.add(HttpMethod.HEAD.name()); result.add(HttpMethod.OPTIONS.name()); result.add(HttpMethod.PATCH.name()); result.add(HttpMethod.POST.name()); result.add(HttpMethod.PUT.name()); return result; } private void rejectForbiddenHttpMethod(HttpServletRequest request) { if (this.allowedHttpMethods == ALLOW_ANY_HTTP_METHOD) { return; } if (!this.allowedHttpMethods.contains(request.getMethod())) { throw new RequestRejectedException(&quot;The request was rejected because the HTTP method \\&quot;&quot; + request.getMethod() + &quot;\\&quot; was not included within the whitelist &quot; + this.allowedHttpMethods); } } } HTTP请求方法必须是DELETE、GET、HEAD、OPTIONS、PATCH、POST 以及 PUT中的一个，请求才能发送成功，否则的话，就会抛出RequestRejectedException异常。如果向发送其他HTTP请求，比如TRACE，需要自己提供一个StrictHttpFirewall实例： @Bean HttpFirewall httpFirewall() { StrictHttpFirewall firewall = new StrictHttpFirewall(); firewall.setUnsafeAllowAnyHttpMethod(true); // 表示不做 HTTP 请求方法校验，表示任何请求方法都可以通过，也可以通过 setAllowedHttpMethods 方法重新定义可以通过的方法 return firewall; } 防御会话固定攻击HttpSession是一个服务端的概念，服务端生成的HttpSession都会有一个对应的sessionid，这个sessionid会通过cookie传递给前端，前端以后发送请求的时候，就带上这个sessionid参数，服务端看到这个sessionid就会把这个前端请求和服务端的某一个HttpSession对应起来，形成“会话”的感觉。 浏览器关闭并不会导致服务端的HttpSession失效，想让服务端的HttpSession失效，要么手动调用HttpSession#invalidate方法；要么等到session自动过期，要么重启服务端。事实上默认情况下，浏览器再次访问服务端的时候，服务端会给浏览器重新分配一个sessionId。 在服务端的响应头中有一个Set-Cookie字段，该字段指示浏览器更新sessionid，同时还有一个HttpOnly属性，这个表示通过JS脚本无法读取到Cookie信息，这样能有效的防止XSS攻击。 只要不关闭浏览器，并且服务端的HttpSession也没有过期，那么维系服务端和浏览器的sessionid是不会发生变化的，而会话固定攻击，则是利用这一机制，借助受害者用相同的会话ID获取认证和授权，然后利用该会话ID劫持受害者的会话以成功冒充受害者，造成会话固定攻击。 SpringSecurity中防御会话固定攻击主要体现在三个方面： 请求地址中有;，请求会被直接拒绝 响应的Set-Cookie字段中有HttpOnly属性，这种方式避免了通过XSS攻击来获取Cookie中的会话信息进而达成会话固定攻击 可以配置改变sessionId public class SecurityConfig extends WebSecurityConfigurerAdapter { @Override protected void configure(HttpSecurity http) throws Exception { http.authorizeRequests().anyRequest().authenticated() .and() .formLogin() .permitAll() .and() .sessionManagement() .sessionFixation().migrateSession() // 默认配置，表示登录成功之后，创建一个新的会话，将旧 session 中的信息复制到新的 session 中 // .none() // 继续使用旧 session // .changeSessionId() // session 不变，修改 sessionId，用到了 Servlet 容器提供的防御会话固定攻击 // .newSession() // 登录后创建一个新的 session } } session共享引入依赖： &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.session&lt;/groupId&gt; &lt;artifactId&gt;spring-session-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; 有时候需要在各个服务之间共享数据，此时可以用Redis将其保存到一个公共的地方，当所有Tomcat需要往Session中写数据时，都往Redis中写，当所有Tomcat需要读数据时，都从Redis中读。或者使用Spring Session来实现，Spring Session就是使用Spring中的代理过滤器，将所有的Session操作拦截下来，自动的将数据同步到Redis中，或者自动的从Redis中读取数据。 引入依赖： &lt;dependecies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.session&lt;/groupId&gt; &lt;artifactId&gt;spring-session-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 引入nginx模拟SpringBoot集群：进入nginx的安装目录的conf目录下（默认是在/usr/local/nginx/conf），编辑nginx.conf文件： upstream javaboy.org{ # upstream 表示配置上游服务器，javaboy.org 表示服务器集群的名字，upstream 里面配置的是一个个的单独服务 server 127.0.0.1:8080 weight=1; # weight 表示服务的权重，意味着将有多少比例的请求从 nginx 上转发到该服务上 server 127.0.0.1:8081 weight=2; } server { listen 80; server_name localhost; #charset utf-8; #access_log logs/host.access.log main; location / { proxy_pass http://javaboy.org; # 表示请求转发的地址，/ 表示拦截所有的请求，转发到刚刚配置好的服务器集群中 proxy_redirect default; # 表示设置发生重定向请求时，nginx 自动修正响应头数据（默认是 Tomcat 返回重定向，此时重定向的地址是 Tomcat 的地址） #root html; #index index.html index.html; } } 配置完成后，正常使用HttpSession即可，Session同步到Redis等已由框架自动完成。因为会话注册表的维护默认是由SessionRegistryImpl完成，而它是基于内存的维护，所以要修改其实现逻辑： @Configuration public class SecurityConfig extends WebSecurityConfigurerAdapter { @Autowired FindByIndexNameSessionRepository sessionRepository; @Override protected void configure(HttpSecurity http) throws Exception { http.authorizeRequests().anyRequest() ... .sessionManagement() .maximumSessions(1) .maxSessionsPreventsLogin(true) .sessionRegistry(sessionRegistry()); } @Bean SpringSessionBackedSessionRegistry sessionRegistry() { return new SpringSessionBackedSessionRegistry(sessionRepository); } } 这时关于session并发的配置就生效了，集群环境下，用户也只能在一台设备上登录。 防御csrf攻击SpringSecurity中，默认通过Model将相关_csrf参数带到前端来，前端发请求时，除了携带Cookie中的信息之外，还需要通过隐藏域携带这个参数，否则网站就会拒绝请求。 也可以通过将_csrf参数放在Cookie中返回前端，配置如下： @Configuration public class SecurityConfig extends WebSecurityConfigurerAdapter { @Override protected void configure(HttpSecurity http) throws Exception { http.authorizeRequests().anyRequest().authenticated() .and() .formLogin() .and() .csrf().csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse()); // 此方法会设置 Cookie 中的 HttpOnly 属性为 false 以允许前端通过 js 操作 Cookie，否则前端无法获取到 _csrf 参数 } } 此时可以看到浏览器中返回的Cookie中多了个XSRF-TOKEN参数，当然服务端也要配置给js文件放行。 SpringSecurity中提供了一个保存csrf参数的规范，就是CsrfToken： public interface CsrfToken extends Serializable { String getHeaderName(); String getParameterName(); // 获取 _csrf 参数的 key String getToken(); // 获取 _csrf 参数的 value } 默认情况下使用DefaultCsrfToken实现类，_csrf参数的生成和保存则是另外一个类HttpSessionCsrfTokenRepository ，它是CsrfTokenRepository接口的默认实现类。 public final class HttpSessionCsrfTokenRepository implements CsrfTokenRepository { private static final String DEFAULT_CSRF_PARAMETER_NAME = &quot;_csrf&quot;; private static final String DEFAULT_CSRF_HEADER_NAME = &quot;X-CSRF-TOKEN&quot;; private static final String DEFAULT_CSRF_TOKEN_ATTR_NAME = HttpSessionCsrfTokenRepository.class .getName().concat(&quot;.CSRF_TOKEN&quot;); private String parameterName = DEFAULT_CSRF_PARAMETER_NAME; private String headerName = DEFAULT_CSRF_HEADER_NAME; private String sessionAttributeName = DEFAULT_CSRF_TOKEN_ATTR_NAME; public void saveToken(CsrfToken token, HttpServletRequest request, HttpServletResponse response) { if (token == null) { HttpSession session = request.getSession(false); if (session != null) { session.removeAttribute(this.sessionAttributeName); } } else { HttpSession session = request.getSession(); session.setAttribute(this.sessionAttributeName, token); } } public CsrfToken loadToken(HttpServletRequest request) { HttpSession session = request.getSession(false); if (session == null) { return null; } return (CsrfToken) session.getAttribute(this.sessionAttributeName); } public CsrfToken generateToken(HttpServletRequest request) { return new DefaultCsrfToken(this.headerName, this.parameterName, createNewToken()); } private String createNewToken() { return UUID.randomUUID().toString(); } } saveToken方法将CsrfToken保存在HttpSession中，将来再从HttpSession中取出和前端传来的参数做比较 loadToken方法就是从HttpSession中读取CsrfToken出来 generateToken是生成CsrfToken的过程，可以看到，生成的默认载体就是DefaultCsrfToken，而CsrfToken的值则通过createNewToken方法生成，是一个UUID字符串 在构造DefaultCsrfToken时还有两个参数headerName和parameterName，这两个参数是前端保存参数的key 如果将_csrf参数设置保存在Cookie中，则需要用到另一个实现类CsrfTokenRepository： public final class CookieCsrfTokenRepository implements CsrfTokenRepository { static final String DEFAULT_CSRF_COOKIE_NAME = &quot;XSRF-TOKEN&quot;; static final String DEFAULT_CSRF_PARAMETER_NAME = &quot;_csrf&quot;; static final String DEFAULT_CSRF_HEADER_NAME = &quot;X-XSRF-TOKEN&quot;; private String parameterName = DEFAULT_CSRF_PARAMETER_NAME; private String headerName = DEFAULT_CSRF_HEADER_NAME; private String cookieName = DEFAULT_CSRF_COOKIE_NAME; private boolean cookieHttpOnly = true; private String cookiePath; private String cookieDomain; public CookieCsrfTokenRepository() { } @Override public CsrfToken generateToken(HttpServletRequest request) { return new DefaultCsrfToken(this.headerName, this.parameterName, createNewToken()); } @Override public void saveToken(CsrfToken token, HttpServletRequest request, HttpServletResponse response) { String tokenValue = token == null ? &quot;&quot; : token.getToken(); Cookie cookie = new Cookie(this.cookieName, tokenValue); cookie.setSecure(request.isSecure()); if (this.cookiePath != null &amp;&amp; !this.cookiePath.isEmpty()) { cookie.setPath(this.cookiePath); } else { cookie.setPath(this.getRequestContext(request)); } if (token == null) { cookie.setMaxAge(0); } else { cookie.setMaxAge(-1); } cookie.setHttpOnly(cookieHttpOnly); if (this.cookieDomain != null &amp;&amp; !this.cookieDomain.isEmpty()) { cookie.setDomain(this.cookieDomain); } response.addCookie(cookie); } @Override public CsrfToken loadToken(HttpServletRequest request) { Cookie cookie = WebUtils.getCookie(request, this.cookieName); if (cookie == null) { return null; } String token = cookie.getValue(); if (!StringUtils.hasLength(token)) { return null; } return new DefaultCsrfToken(this.headerName, this.parameterName, token); } public static CookieCsrfTokenRepository withHttpOnlyFalse() { CookieCsrfTokenRepository result = new CookieCsrfTokenRepository(); result.setCookieHttpOnly(false); return result; } private String createNewToken() { return UUID.randomUUID().toString(); } } 与默认实现不同，这里是将CsrfToken保存到Cookie中。然后校验参数则通过CsrfFilter过滤器来实现： protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException { request.setAttribute(HttpServletResponse.class.getName(), response); CsrfToken csrfToken = this.tokenRepository.loadToken(request); final boolean missingToken = csrfToken == null; if (missingToken) { csrfToken = this.tokenRepository.generateToken(request); this.tokenRepository.saveToken(csrfToken, request, response); } request.setAttribute(CsrfToken.class.getName(), csrfToken); request.setAttribute(csrfToken.getParameterName(), csrfToken); if (!this.requireCsrfProtectionMatcher.matches(request)) { filterChain.doFilter(request, response); return; } String actualToken = request.getHeader(csrfToken.getHeaderName()); if (actualToken == null) { actualToken = request.getParameter(csrfToken.getParameterName()); } if (!csrfToken.getToken().equals(actualToken)) { if (this.logger.isDebugEnabled()) { this.logger.debug(&quot;Invalid CSRF token found for &quot; + UrlUtils.buildFullRequestUrl(request)); } if (missingToken) { this.accessDeniedHandler.handle(request, response, new MissingCsrfTokenException(actualToken)); } else { this.accessDeniedHandler.handle(request, response, new InvalidCsrfTokenException(csrfToken, actualToken)); } return; } filterChain.doFilter(request, response); } 首先调用tokenRepository.loadToken，这个就是之前配置的CsrfTokenRepository实例 如果调用tokenRepository.loadToken方法没有加载到CsrfToken，那说明这个请求可能是第一次发起，则调用tokenRepository.generateToken方法生成CsrfToken，并调用tokenRepository.saveToken方法保存CsrfToken 调用request.setAttribute方法存了一些值进去，这就是默认情况下，我们通过jsp或者thymeleaf标签渲染_csrf的数据来源 requireCsrfProtectionMatcher.matches方法则使用用来判断哪些请求方法需要做校验，默认情况下，”GET”, “HEAD”, “TRACE”, “OPTIONS”方法是不需要校验的 接下来获取请求中传递来的CSRF参数，先从请求头中获取，获取不到再从请求参数中获取 获取到请求传来的csrf参数之后，再和一开始加载到的csrfToken做比较，如果不同的话，就抛出异常 常见的GET请求实际上是不需要CSRF攻击校验的，但是下面代码总会执行： if (missingToken) { csrfToken = this.tokenRepository.generateToken(request); this.tokenRepository.saveToken(csrfToken, request, response); } 因此可以使用LazyCsrfTokenRepository，使得只有开发者调用getToken想要去获取csrfToken时，才去对csrfToken做保存操作： public final class LazyCsrfTokenRepository implements CsrfTokenRepository { @Override public CsrfToken generateToken(HttpServletRequest request) { return wrap(request, this.delegate.generateToken(request)); } @Override public void saveToken(CsrfToken token, HttpServletRequest request, HttpServletResponse response) { if (token == null) { this.delegate.saveToken(token, request, response); } } @Override public CsrfToken loadToken(HttpServletRequest request) { return this.delegate.loadToken(request); } private CsrfToken wrap(HttpServletRequest request, CsrfToken token) { HttpServletResponse response = getResponse(request); return new SaveOnAccessCsrfToken(this.delegate, request, response, token); } private static final class SaveOnAccessCsrfToken implements CsrfToken { private transient CsrfTokenRepository tokenRepository; private transient HttpServletRequest request; private transient HttpServletResponse response; private final CsrfToken delegate; SaveOnAccessCsrfToken(CsrfTokenRepository tokenRepository, HttpServletRequest request, HttpServletResponse response, CsrfToken delegate) { this.tokenRepository = tokenRepository; this.request = request; this.response = response; this.delegate = delegate; } @Override public String getToken() { saveTokenIfNecessary(); return this.delegate.getToken(); } private void saveTokenIfNecessary() { if (this.tokenRepository == null) { return; } synchronized (this) { if (this.tokenRepository != null) { this.tokenRepository.saveToken(this.delegate, this.request, this.response); this.tokenRepository = null; this.request = null; this.response = null; } } } } } 如果对csrf不做任何配置，默认其实就是LazyCsrfTokenRepository+HttpSessionCsrfTokenRepository组合，也可以自己配置： @Override protected void configure(HttpSecurity http) throws Exception { http.authorizeRequests().anyRequest().authenticated() .and() .formLogin() .loginPage(&quot;/login.html&quot;) .successHandler((req,resp,authentication)-&gt;{ resp.getWriter().write(&quot;success&quot;); }) .permitAll() .and() .csrf().csrfTokenRepository(new LazyCsrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse())); } 跨域配置当前端请求与后端同源时（仅端口不同），由于同源策略的限制，请求无法发送成功。通过在方法上配置注解@CrossOrigin(value=&quot;http://xxx:xxx&quot;)，表示其接受某一个域的请求。 也可以通过全局配置： @Configuration publicclass WebMvcConfig implements WebMvcConfigurer { @Override public void addCorsMappings(CorsRegistry registry) { registry.addMapping(&quot;/**&quot;) .allowedOrigins(&quot;http://localhost:8081&quot;) .allowedMethods(&quot;*&quot;) .allowedHeaders(&quot;*&quot;); } } 或者在SpringSecurity中做全局配置： @Configuration public class SecurityConfig extends WebSecurityConfigurerAdapter { @Override protected void configure(HttpSecurity http) throws Exception { http .authorizeRequests() .anyRequest().authenticated() .and() .formLogin() .permitAll() .and() .httpBasic() .and() .cors() // 开启对CORS的支持 .configurationSource(corsConfigurationSource()) .and() .csrf() .disable(); } // 通过 CorsConfigurationSource 实例对跨域信息作出详细配置，例如允许的请求来源、允许的请求方法、允许通过的请求头、探测请求的有效期、需要处理的路径等等 @Bean CorsConfigurationSource corsConfigurationSource() { UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(); CorsConfiguration configuration = new CorsConfiguration(); configuration.setAllowCredentials(true); configuration.setAllowedOrigins(Arrays.asList(&quot;*&quot;)); configuration.setAllowedMethods(Arrays.asList(&quot;*&quot;)); configuration.setAllowedHeaders(Arrays.asList(&quot;*&quot;)); configuration.setMaxAge(Duration.ofHours(1)); source.registerCorsConfiguration(&quot;/**&quot;,configuration); return source; } } 动态权限配置权限管理本身是由FilterSecurityInterceptor控制的，系统默认已经自动创建好了，如果想修改它的属性，则可以利用withObjectPostProcessor方法： @Configuration public class SecurityConfig extends WebSecurityConfigurerAdapter { @Override protected void configure(HttpSecurity http) throws Exception { http.authorizeRequests() .withObjectPostProcessor(new ObjectPostProcessor&lt;FilterSecurityInterceptor&gt;() { @Override public &lt;O extends FilterSecurityInterceptor&gt; O postProcess(O object) { object.setAccessDecisionManager(customUrlDecisionManager); object.setSecurityMetadataSource(customFilterInvocationSecurityMetadataSource); return object; } }) .and() // ... } } ObjectPostProcessor接口就一个postProcess，最主要的实现类AutowireBeanFactoryObjectPostProcessor就实现了这个方法（里面就是具体的注册逻辑），因此最主要作用就是手动注册实例到Spring容器中（并且让实例走一遍Bean的生命周期） 因为FilterSecurityInterceptor在创建成功后会重走一遍postProcess方法，因此这里通过重写postProcess方法就能实现属性修改。 自定义异常处理ExceptionTranslationFilter是SpringSecurity中专门负责处理异常的过滤器，默认情况下，这个过滤器已经被自动加载到过滤器链中。 public class ExceptionTranslationFilter extends GenericFilterBean { public ExceptionTranslationFilter(AuthenticationEntryPoint authenticationEntryPoint, RequestCache requestCache) { this.authenticationEntryPoint = authenticationEntryPoint; this.requestCache = requestCache; } public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException { HttpServletRequest request = (HttpServletRequest) req; HttpServletResponse response = (HttpServletResponse) res; try { chain.doFilter(request, response); } catch (IOException ex) { throw ex; } catch (Exception ex) { Throwable[] causeChain = throwableAnalyzer.determineCauseChain(ex); RuntimeException ase = (AuthenticationException) throwableAnalyzer .getFirstThrowableOfType(AuthenticationException.class, causeChain); if (ase == null) { ase = (AccessDeniedException) throwableAnalyzer.getFirstThrowableOfType( AccessDeniedException.class, causeChain); } if (ase != null) { if (response.isCommitted()) { throw new ServletException(&quot;Unable to handle the Spring Security Exception because the response is already committed.&quot;, ex); } handleSpringSecurityException(request, response, chain, ase); } else { if (ex instanceof ServletException) { throw (ServletException) ex; } else if (ex instanceof RuntimeException) { throw (RuntimeException) ex; } throw new RuntimeException(ex); } } } private void handleSpringSecurityException(HttpServletRequest request, HttpServletResponse response, FilterChain chain, RuntimeException exception) throws IOException, ServletException { if (exception instanceof AuthenticationException) { sendStartAuthentication(request, response, chain, (AuthenticationException) exception); } else if (exception instanceof AccessDeniedException) { Authentication authentication = SecurityContextHolder.getContext().getAuthentication(); if (authenticationTrustResolver.isAnonymous(authentication) || authenticationTrustResolver.isRememberMe(authentication)) { sendStartAuthentication( request, response, chain, new InsufficientAuthenticationException( messages.getMessage( &quot;ExceptionTranslationFilter.insufficientAuthentication&quot;, &quot;Full authentication is required to access this resource&quot;))); } else { accessDeniedHandler.handle(request, response, (AccessDeniedException) exception); } } } protected void sendStartAuthentication(HttpServletRequest request, HttpServletResponse response, FilterChain chain, AuthenticationException reason) throws ServletException, IOException { SecurityContextHolder.getContext().setAuthentication(null); requestCache.saveRequest(request, response); logger.debug(&quot;Calling Authentication entry point.&quot;); authenticationEntryPoint.commence(request, response, reason); } } 这里的doFilter方法中过滤器链继续向下执行，ExceptionTranslationFilter处于SpringSecurity过滤器链的倒数第二个，最后一个是FilterSecurityInterceptor，它专门处理授权问题，如果发现用户未登录、未授权等，进而抛出异常，抛出的异常最终会被ExceptionTranslationFilter#doFilter方法捕获 捕获异常之后，通过调用throwableAnalyzer.getFirstThrowableOfType方法判断是认证异常还是授权异常，判断出类型之后，进入到handleSpringSecurityException方法进行处理，如果不是SpringSecurity中的异常类型，则走ServletException异常类型的处理逻辑 进入handleSpringSecurityException 方法之后，还是根据异常类型判断，如果是认证相关的异常，就走sendStartAuthentication方法，最终被authenticationEntryPoint.commence方法处理；如果是授权相关的异常，就走accessDeniedHandler.handle方法进行处理 AccessDeniedHandler的默认实现类则是AccessDeniedHandlerImpl，因此授权异常默认是在AccessDeniedHandlerImpl#handle方法中处理的 // 服务器跳转返回 403 public void handle(HttpServletRequest request, HttpServletResponse response, AccessDeniedException accessDeniedException) throws IOException, ServletException { if (!response.isCommitted()) { if (errorPage != null) { request.setAttribute(WebAttributes.ACCESS_DENIED_403, accessDeniedException); response.setStatus(HttpStatus.FORBIDDEN.value()); RequestDispatcher dispatcher = request.getRequestDispatcher(errorPage); dispatcher.forward(request, response); } else { response.sendError(HttpStatus.FORBIDDEN.value(), HttpStatus.FORBIDDEN.getReasonPhrase()); } } } 自定义异常处理逻辑需要在exceptionHandling上进行配置，首先自定义认证异常处理类和授权异常处理类： @Component public class MyAuthenticationEntryPoint implements AuthenticationEntryPoint { @Override public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException, ServletException { response.getWriter().write(&quot;login failed:&quot; + authException.getMessage()); } } @Component public class MyAccessDeniedHandler implements AccessDeniedHandler { @Override public void handle(HttpServletRequest request, HttpServletResponse response, AccessDeniedException accessDeniedException) throws IOException, ServletException { response.setStatus(403); response.getWriter().write(&quot;Forbidden:&quot; + accessDeniedException.getMessage()); } } 然后在SecurityConfig中进行配置： @Configuration public class SecurityConfig extends WebSecurityConfigurerAdapter { @Override protected void configure(HttpSecurity http) throws Exception { http.authorizeRequests() // ... .and() .exceptionHandling() .authenticationEntryPoint(myAuthenticationEntryPoint) .accessDeniedHandler(myAccessDeniedHandler) .and() // ... } }","categories":[{"name":"生活","slug":"生活","permalink":"http://goodguyjameswin.github.io/categories/生活/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://goodguyjameswin.github.io/tags/学习笔记/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"http://goodguyjameswin.github.io/categories/生活/"}]},{"title":"二叉树","slug":"二叉树","date":"2022-05-21T10:43:08.000Z","updated":"2022-07-24T09:26:51.572Z","comments":false,"path":"2022/05/21/二叉树/","link":"","permalink":"http://goodguyjameswin.github.io/2022/05/21/二叉树/","excerpt":"","text":"树的简介树的特点是：除了根节点以外，其他节点都有唯一的父亲节点。如果一棵树中每个结点至多有两个孩子结点，这样的树就称为二叉树。完全二叉树所有的结点按照从上到下、从左到右紧凑摆放，中间不会有缺失结点，如果最后一层也没有缺失结点，就是满二叉树。 树的遍历包括深度优先遍历（DFS）和广度优先遍历（BFS），前者用栈实现，后者用队列实现。其中广度优先遍历可以用于搜索无向图的最短路径（两点之间，线段最短）。 力扣103：给你二叉树的根节点root，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。 输入：root = [3,9,20,null,null,15,7] 输出：[[3],[20,9],[15,7]] 查看解析 class Solution { public List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) { List&lt;List&lt;Integer&gt;&gt; ans = new LinkedList&lt;List&lt;Integer&gt;&gt;(); if (root == null) { return ans; } Queue&lt;TreeNode&gt; nodeQueue = new ArrayDeque&lt;TreeNode&gt;(); nodeQueue.offer(root); boolean isOrderLeft = true; while (!nodeQueue.isEmpty()) { // 通过双端队列实现 Deque&lt;Integer&gt; levelList = new LinkedList&lt;Integer&gt;(); int size = nodeQueue.size(); for (int i = 0; i &lt; size; ++i) { TreeNode curNode = nodeQueue.poll(); if (isOrderLeft) { levelList.offerLast(curNode.val); } else { levelList.offerFirst(curNode.val); } if (curNode.left != null) { nodeQueue.offer(curNode.left); } if (curNode.right != null) { nodeQueue.offer(curNode.right); } } ans.add(new LinkedList&lt;Integer&gt;(levelList)); isOrderLeft = !isOrderLeft; } return ans; } } 二叉树的遍历前序遍历前序遍历，对于每一棵树来说，总是先访问根结点，然后访问左子树，最后访问右子树。 public class Solution { public List&lt;Integer&gt; preorderTraversal(TreeNode root) { List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); dfs(root,res); return res; } private void dfs(TreeNode treeNode, List&lt;Integer&gt; res) { if (treeNode == null) { return; } res.add(treeNode.val); dfs(treeNode.left, res); dfs(treeNode.right, res); } } 思考：怎么通过迭代算法实现？（提示：栈） 查看解析 public class Solution { // 使用栈的模拟 private enum Action { /** * 如果当前结点有孩子结点（左右孩子结点至少存在一个），执行 GO */ GO, /** * 添加到结果集（真正输出这个结点） */ ADDTORESULT } private class Command { private Action action; private TreeNode node; /** * 将动作类与结点类封装起来 * * @param action * @param node */ public Command(Action action, TreeNode node) { this.action = action; this.node = node; } } public List&lt;Integer&gt; preorderTraversal(TreeNode root) { List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); if (root == null) { return res; } Deque&lt;Command&gt; stack = new ArrayDeque&lt;&gt;(); stack.addLast(new Command(Action.GO, root)); while (!stack.isEmpty()) { Command command = stack.removeLast(); if (command.action == Action.ADDTORESULT) { res.add(command.node.val); } else { // 特别注意：以下的顺序与递归执行的顺序反着来，即：倒过来写的结果 // 前序遍历：根结点、左子树、右子树、 // 添加到栈的顺序：右子树、左子树、根结点 if (command.node.right != null) { stack.add(new Command(Action.GO, command.node.right)); } if (command.node.left != null) { stack.add(new Command(Action.GO, command.node.left)); } stack.add(new Command(Action.ADDTORESULT, command.node)); } } return res; } } 中序遍历中序遍历，对于每一棵树来说，总是先访问左子树，然后访问根结点，最后访问右子树。 public class Solution { public List&lt;Integer&gt; inorderTraversal(TreeNode root) { List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); dfs(root, res); return res; } private void dfs(TreeNode node, List&lt;Integer&gt; res) { if (node == null) { return; } dfs(node.left, res); res.add(node.val); dfs(node.right, res); } } 后序遍历后序遍历，对于每一棵树来说，总是先访问左子树，然后访问右子树，最后访问根节点。 public class Solution { public List&lt;Integer&gt; postorderTraversal(TreeNode root) { List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); dfs(root, res); return res; } private void dfs(TreeNode node, List&lt;Integer&gt; res) { if (node == null) { return; } dfs(node.left, res); dfs(node.right, res); res.add(node.val); } } 力扣222：给你一颗完全二叉树的根节点root，求出该树的节点个数。必须设计一个比直接遍历树来统计节点更快的方案。 输入：root = [1,2,3,4,5,6] 输出：6 查看解析 class Solution { public int countNodes(TreeNode root) { if(root == null){ return 0; } int left = countLevel(root.left); int right = countLevel(root.right); if(left == right){ // 说明左子树是满二叉树，因为节点已经填充到右子树了 return countNodes(root.right) + (1&lt;&lt;left); }else{ // 说明此时最后一层结点不满，但倒数第二层已经满了，可以直接得到右子树的节点个数 return countNodes(root.left) + (1&lt;&lt;right); } } private int countLevel(TreeNode root){ // 计算完全二叉树的高度 int level = 0; while(root != null){ level++; root = root.left; } return level; } } 力扣124：路径被定义为一条从树中任意结点触发，沿父结点-子节点连接，达到任意结点的序列。同一个结点在一条路径序列中至多出现一次。该路径至少包含一个结点，且不一定经过根节点。路径和是路径中各节点值的总和。给你一个二叉树的根节点root，返回其最大路径和。 输入：root = [1,2,3] 输出：6 解释：最优路径是 2 -&gt; 1 -&gt; 3，路径和为 2 + 1 + 3 = 6 查看解析 class Solution { int max; public int maxPathSum(TreeNode root) { max = Integer.MIN_VALUE; dfs(root); return max; } private int dfs(TreeNode root) { if (root == null) { return 0; } int left = Math.max(dfs(root.left), 0); int right = Math.max(dfs(root.right), 0); // 包含经过根节点的路径和以根节点为起点的路径 max = Math.max(left + right + root.val, max); // 将当前结点能获取的最大路径和作为结果向上回溯（给浅层递归提供参考） return root.val + Math.max(left, right); } } 经典问题，由前、中序遍历序列构造二叉树： public class Solution { private int[] preorder; private Map&lt;Integer, Integer&gt; hashMap; public TreeNode buildTree(int[] preorder, int[] inorder) { int preLen = preorder.length; int inLen = inorder.length; if (preLen != inLen) { throw new RuntimeException(&quot;输入数据有误。&quot;); } this.preorder = preorder; this.hashMap = new HashMap&lt;&gt;(); for (int i = 0; i &lt; inLen; i++) { hashMap.put(inorder[i], i); } return buildTree(0, preLen - 1, 0, inLen - 1); } /** * 使用数组 preorder 在索引区间 [preLeft..preRight] 中的所有元素 * 和数组 inorder 在索引区间 [inLeft..inRight] 中的所有元素构造二叉树 * * @param preorder 二叉树前序遍历结果 * @param preLeft 二叉树前序遍历结果的左边界 * @param preRight 二叉树前序遍历结果的右边界 * @param inorder 二叉树后序遍历结果 * @param inLeft 二叉树后序遍历结果的左边界 * @param inRight 二叉树后序遍历结果的右边界 * @return 二叉树的根结点 */ private TreeNode buildTree(int preLeft, int preRight, int inLeft, int inRight) { // 因为是递归调用的方法，按照国际惯例，先写递归终止条件 if (preLeft &gt; preRight || inLeft &gt; inRight) { return null; } // 先序遍历的起点元素很重要（一定是二叉树的根节点） int pivot = preorder[preLeft]; TreeNode root = new TreeNode(pivot); // 寻找先序遍历序列的第一个结点在中序遍历序列中出现的位置 int pivotIndex = hashMap.get(pivot); root.left = buildTree(preLeft + 1, pivotIndex - inLeft + preLeft, inLeft, pivotIndex - 1); root.right = buildTree(pivotIndex - inLeft + preLeft + 1, preRight, pivotIndex + 1, inRight); return root; } } 力扣236：给定一个二叉树，找到该树中两个指定结点的最近公共祖先。最近公共祖先定义为：对于有根树T的两个结点p、q，最近公共祖先表示为一个结点x，满足x是p、q的祖先且x的深度尽可能大（一个结点也可以是它自己的祖先）。 输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1 输出：3 解释：结点 5 和结点 1 的最近公共祖先是结点 3；结点 5 和结点 4 的最近公共祖先是结点 5。因为根据定义最近公共祖先结点可以是结点本身 查看解析 public class Solution { public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { if (root == null || root == p || root == q) { return root; } // 后序遍历 TreeNode left = lowestCommonAncestor(root.left, p, q); TreeNode right = lowestCommonAncestor(root.right, p, q); // 这一句特别重要，如果左边和右边都非空，把当前结点返回回去 if (left != null &amp;&amp; right != null) { return root; } // 下面的这种写法包含了 left 和 right 同时为空的情况 if (left == null) { return right; } return left; } } 二叉搜索树二叉搜索树（BST）可以是一颗空树；二叉搜索树由根节点，左子树和右子树组成，其中左子树和右子树都是二叉搜索树，并且左子树上所有结点的键值小于根节点的键值，并且右子树上所有结点的键值大于根节点的键值。因此，二叉搜索树中序遍历得到的序列是有序的。 public class BinarySearchTree { /** * 根结点 */ private Node root; /** * 二叉搜索树中的结点个数 */ private int size; /** * 默认构造一棵空的二叉搜索树 */ public BinarySearchTree() { root = null; size = 0; } public int getSize() { return size; } public boolean isEmpty() { return size == 0; } public void insert(int key, int value) { root = insert(root, key, value); } /** * 向以 node 为结点的二叉搜索树中插入节点（key，value）， * 将当前 node 的 key 与插入节点的 key 进行比较，进而决定向左子树插入还是右子树插入 * * @param node * @param key * @param value * @return 插入了新的结点的二叉搜索树的根结点 */ private Node insert(Node node, int key, int value) { if (node == null) { size++; return new Node(key, value); } if (key == node.key) { // 如果 key 值重复，value 值更新，这一点是人为定义 node.value = value; } else if (key &lt; node.key) { // 插入了新的结点的子树是原来结点的左子树 node.left = insert(node.left, key, value); } else { // 插入了新的结点的子树是原来结点的右子树 node.right = insert(node.right, key, value); } return node; } /** * @param key * @return 如果找不到对应的 key，返回 null，因此将返回值设计成 Integer 包装类型 */ public Integer search(int key) { return search(root, key); } /** * 在以 node 为根的二叉搜索树中查找 key 所对应的 value * * @param node * @param key * @return */ private Integer search(Node node, int key) { // 先处理递归到底的情况 if (node == null) { return null; } if (node.key == key) { return node.value; } else if (key &lt; node.key) { // 在以 node.left 为根结点的子树中继续查找 return search(node.left, key); } else { // 在以 node.right 为根结点的子树中继续查找 return search(node.right, key); } } /** * @param key * @return 查找二叉搜索树中是否存在 key 等于给定 key 值的结点 */ public boolean contains(int key) { return contains(root, key); } private boolean contains(Node node, int key) { if (node == null) { return false; } if (node.key == key) { return true; } else if (key &lt; node.key) { return contains(node.left, key); } else { return contains(node.right, key); } } // 删除二叉搜索树中的结点 public void remove(int key) { root = remove(root, key); } private Node remove(Node node, int key) { if (node == null) { return null; } if (key &lt; node.key) { node.left = remove(node.left, key); return node; } else if (key &gt; node.key) { node.right = remove(node.right, key); return node; } else { // key == node.key if (node.left == null) { Node rightNode = node.right; node.right = null; size--; return rightNode; } if (node.right == null) { Node leftNode = node.left; node.left = null; size--; return leftNode; } // 使用当前 node 的后继代替（也可以使用 node 的前驱代替） Node successor = minimum(node.right); size++;// 下面删除了一个节点，所以要先加一下 successor.right = removeMin(node.right); successor.left = node.left; node.left = null; node.right = null; size--; return successor; } } private Node removeMin(Node node) { // 从根结点一直向左子树方向走，直到当前结点不存在左子树的时候，当前结点就是整棵树中 key 最小的结点 if (node.left == null) { // 仔细体会这个逻辑，用当前结点的右子树替换当前结点，因此，需要先保存当前结点的右子树 Node rightNode = node.right; // 切断引用，让当前结点成为游离结点，等待垃圾回收机制回收 node.right = null; size--; return rightNode; } node.left = removeMin(node.left); return node; } private Node minimum(Node node) { if (node.left == null) { return node; } return minimum(node.left); } /** * 删除二叉搜索树中最小的 key 所在的结点 */ public void removeMin() { if (root != null) { // 注意：有可能删除的结点是根结点，因此 // 在设计 removeMin 删除方法的时候，需要返回删除了最小 key 以后的新的树的根结点 root = removeMin(root); } } public Integer floor(int key) { return floor(root, key); } /** * @param node * @param key * @return 返回以 node 为根的二叉搜索树中，小于等于 key 的最大结点的 key */ private Integer floor(Node node, int key) { if (node == null) { return null; } if (node.key == key) { return node.key; } if (key &lt; node.key) { return floor(node.left, key); } Integer temp = floor(node.right, key); if (temp != null) { return temp; } return node.key; } public Integer ceiling(int key) { return ceiling(key); } /** * @param node * @param key * @return 返回以 node 为根的二叉搜索树中，大于等于 key 的最小结点的 key */ private Integer ceiling(Node node, int key) { if (node == null) { return null; } if (key == node.key) { return node.key; } if (key &gt; node.key) { return ceiling(node.right, key); } Integer temp = ceiling(node.left, key); if (temp != null) { return temp; } return node.key; } private class Node { /** * 设计成实现了 Comparable 接口的对象是更标准的做法，这里未采用 */ private int key; private int value; private Node left; private Node right; public Node(int key, int value) { this.key = key; this.value = value; this.left = null; this.right = null; } public Node(Node node) { this.key = node.key; this.value = node.value; this.left = node.left; this.right = node.right; } } } 力扣449：序列化是将数据结构或对象转换为一系列位的过程，以便它可以存储在文件或内存缓冲区中，或通过网络连接链路传输，以便稍后在同一个或另一个计算机环境中重建。设计一个算法来序列化和反序列化二叉搜索树。对序列化/反序列化算法的工作方式没有限制。您只需确保二叉搜索树可以序列化为字符串，并且可以将该字符串反序列化为最初的二叉搜索树。 输入：root = [2,1,3] 输出：[2,1,3] 查看解析 public class Codec { public String serialize(TreeNode root) { // 对二叉搜索树进行后序遍历，再将数组编码成字符串 List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); postOrder(root, list); String str = list.toString(); return str.substring(1, str.length() - 1); } public TreeNode deserialize(String data) { if (data.isEmpty()) { return null; } String[] arr = data.split(&quot;, &quot;); Deque&lt;Integer&gt; stack = new ArrayDeque&lt;Integer&gt;(); // 用栈快速得到末尾元素 int length = arr.length; for (int i = 0; i &lt; length; i++) { stack.push(Integer.parseInt(arr[i])); } // 后序遍历得到的数组中，根结点的值位于数组末尾，左子树的节点均小于根节点的值，右子树的节点均大于根节点的值 return construct(Integer.MIN_VALUE, Integer.MAX_VALUE, stack); } private void postOrder(TreeNode root, List&lt;Integer&gt; list) { if (root == null) { return; } postOrder(root.left, list); postOrder(root.right, list); list.add(root.val); } private TreeNode construct(int lower, int upper, Deque&lt;Integer&gt; stack) { if (stack.isEmpty() || stack.peek() &lt; lower || stack.peek() &gt; upper) { return null; } int val = stack.pop(); TreeNode root = new TreeNode(val); root.right = construct(val, upper, stack); root.left = construct(lower, val, stack); return root; } } 力扣1373：给你一颗以root为根的二叉树，请你返回任意二叉搜索子树的最大键值和。 二叉搜索树的定义如下： 任意结点的左子树中的键值都小于此节点的键值 任意结点的右子树中的键值都大于此节点的键值 任意结点的左子树和右子树都是二叉搜索树 输入：root = [1,4,3,2,4,2,5,null,null,null,null,null,null,4,6] 输出：20 解释：键值为 3 的子树是和最大的二叉搜索树 查看解析 class Solution { int ans = 0; public int maxSumBST(TreeNode root) { traverse(root); return ans; } // 后序遍历二叉树，递归 // 返回以root为根的二叉树[是否是二叉搜索树，最小节点值，最大节点值，节点值之和] public int[] traverse(TreeNode root){ if(root == null){ return new int[]{1, Integer.MAX_VALUE, Integer.MIN_VALUE, 0}; } int[] leftTree = traverse(root.left); int[] rightTree = traverse(root.right); int[] res = new int[4]; // 判断以root为根节点的二叉树是否是二叉搜索树 if(leftTree[0] == 1 &amp;&amp; rightTree[0] == 1 &amp;&amp; root.val &gt; leftTree[2] &amp;&amp; root.val &lt; rightTree[1]){ res[0] = 1; res[1] = Math.min(root.val, leftTree[1]); res[2] = Math.max(root.val, rightTree[2]); res[3] = root.val + leftTree[3] + rightTree[3]; ans = Math.max(res[3], ans); } // 如果不是搜索二叉树，直接返回res默认初始化值[0,0,0,0]即可，因为用不到了 return res; } } .center { width: auto; display: table; margin-left: auto; margin-right: auto; }","categories":[{"name":"生活","slug":"生活","permalink":"http://goodguyjameswin.github.io/categories/生活/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://goodguyjameswin.github.io/tags/学习笔记/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"http://goodguyjameswin.github.io/categories/生活/"}]},{"title":"springboot学习","slug":"springboot学习","date":"2022-05-19T08:26:45.000Z","updated":"2022-07-18T03:51:02.487Z","comments":false,"path":"2022/05/19/springboot学习/","link":"","permalink":"http://goodguyjameswin.github.io/2022/05/19/springboot学习/","excerpt":"","text":"内容部分转载自 公众号：狂神说，自学笔记，仅作学习交流用 构建工程入门使用IDEA创建项目，选择spring initializer，默认是到官网的快速构建工具实现，初始化组件一般选择Web即可 在主程序的同级目录下，新建一个controller包 @RestController public class HelloController { @RequestMapping(&quot;/hello&quot;) public String hello() { return &quot;Hello World&quot;; } } 从主程序启动项目，访问本机的Tomcat端口号即可 运行原理发现一个springboot项目主要是依赖于一个父项目 &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; 父项目还有一个父依赖，里面存有复数依赖包的各版号 &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt; &lt;/parent&gt; @SpringBootApplication注解SpringBoot的主配置类，SpringBoot通过运行这个类的main方法来启动SpringBoot应用 @SpringBootConfiguration @EnableAutoConfiguration @ComponentScan( excludeFilters = {@Filter( type = FilterType.CUSTOM, classes = {TypeExcludeFilter.class} ), @Filter( type = FilterType.CUSTOM, classes = {AutoConfigurationExcludeFilter.class} )} ) public @interface SpringBootApplication { // ...... } @SpringBootConfiguration注解SpringBoot的某个配置类 @EnableAutoConfiguration开启自动配置功能 @AutoConfigurationPackage @Import({AutoConfigurationImportSelector.class}) public @interface EnableAutoConfiguration { // ...... } @AutoConfigurationPackage自动配置包 @Import({Registrar.class}) public @interface AutoConfigurationPackage { // ...... } @Import是Spring底层注解，给容器导入一个组件，Registrar.class作用，将主启动类所在包及包下面所有子包的所有组件扫描到Spring容器 @Import({AutoConfigurationImportSelector.class})自动配置导入选择器 // 获得候选的配置 protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) { // getSpringFactoriesLoaderFactoryClass()方法返回启动自动导入配置文件的注解类：EnableAutoConfiguration List&lt;String&gt; configurations = new ArrayList(SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader())); ImportCandidates.load(AutoConfiguration.class, this.getBeanClassLoader()).forEach(configurations::add); Assert.notEmpty(configurations, &quot;No auto configuration classes found in META-INF/spring.factories nor in META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports. If you are using a custom packaging, make sure that file is correct.&quot;); return configurations; } 找到SpringFactoriesLoader的静态方法loadFactoryNames中调用的loadSpringFactories静态方法，获得自动配置的根源文件spring.factories private static Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(ClassLoader classLoader) { // 获取classLoader，这里得到的就是EnableAutoConfiguration标注的类本身 Map&lt;String, List&lt;String&gt;&gt; result = (Map)cache.get(classLoader); if (result != null) { return result; } else { HashMap result = new HashMap(); try { // 获取资源文件 Enumeration urls = classLoader.getResources(&quot;META-INF/spring.factories&quot;); // 将读取到的资源遍历，封装成为一个Properties // ...... } catch (IOException var14) { throw new IllegalArgumentException(&quot;Unable to load factories from location [META-INF/spring.factories]&quot;, var14); } } } 自动配置真正实现是从classpath中搜寻所有的META-INF/spring.factories配置文件 ，并将其中对应的org.springframework.boot.autoconfigure包下的配置项，通过反射实例化为对应标注了@Configuration的JavaConfig形式的IOC容器配置类（xxxAutoConfiguration），然后将这些都汇总成为一个实例并加载到IOC容器中 SpringApplication.run方法一部分是SpringApplication的实例化 public SpringApplication(ResourceLoader resourceLoader, Class... primarySources) { // ...... this.webApplicationType = WebApplicationType.deduceFromClasspath(); this.setInitializers(this.getSpringFactoriesInstances()); this.setListeners(this.getSpringFactoriesInstances(ApplicationListener.class)); this.mainApplicationClass = this.deduceMainApplicationClass(); } 推断应用的类型是普通的项目还是Web项目 查找并加载所有可用初始化器 ， 设置到initializers属性中 找出所有的应用程序监听器，设置到listeners属性中 推断并设置main方法的定义类，找到运行的主类 另一部分是run方法的执行 配置文件@ConfigurationProperties(prefix=&quot;pojo&quot;)作用是将配置文件中配置的每一个属性的值，映射到这个组件中；告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定，默认从全局配置文件中获取值prefix=&quot;pojo&quot;：将配置文件中的pojo下面的所有属性一一对应 @PropertySource(value=&quot;classpath:pojo.properties&quot;)加载指定的配置文件 @Validated用于校验数据 @Component //注册bean @ConfigurationProperties(prefix = &quot;person&quot;) @Validated //数据校验 public class Person { @Email(message=&quot;邮箱格式错误&quot;) //name必须是邮箱格式 private String name; } 通过spring.profiles.active={profile}指定使用不同的环境，环境使用不同的端口号，或者通过yaml文件来配置，默认使用properties配置文件 server: port: 8081 #选择要激活那个环境块 spring: profiles: active: prod --- server: port: 8083 spring: profiles: dev #配置环境的名称 --- server: port: 8084 spring: profiles: prod #配置环境的名称 springboot项目的配置文件扫描优先级从高到低 项目路径下的config文件夹配置文件 项目路径下配置文件 资源路径下的config文件夹配置文件 资源路径下配置文件 可在项目打包好后，使用命令行参数启动项目的时候指定配置文件的位置，此优先级最高 java -jar spring-boot-config.jar --spring.config.location=F:/application.properties 自动装配原理xxxAutoConfiguration自动配置类，用于给容器添加组件，必须在一定条件下才能生效，在主配置文件中启用debug=true让控制台打印自动配置报告 // 表示这是一个配置类 @AutoConfiguration // 启动指定类的ConfigurationProperties功能，xxxProperties类中封装着能在主配置文件中配置的属性 @EnableConfigurationProperties({ServerProperties.class}) // Spring底层@Conditional注解，根据条件判断配置类是否生效 @ConditionalOnWebApplication( type = Type.SERVLET ) // 判断当前项目有没有指定类 @ConditionalOnClass({CharacterEncodingFilter.class}) // 判断配置文件中是否存在某个配置，一般默认是存在的 @ConditionalOnProperty( prefix = &quot;server.servlet.encoding&quot;, value = {&quot;enabled&quot;}, matchIfMissing = true ) public class HttpEncodingAutoConfiguration { // 映射为SpringBoot的主配置文件 private final Encoding properties; public HttpEncodingAutoConfiguration(ServerProperties properties) { this.properties = properties.getServlet().getEncoding(); } // 给容器添加一个组件，值可以从主配置文件中获取 @Bean // 判断容器中是否存在指定组件 @ConditionalOnMissingBean public CharacterEncodingFilter characterEncodingFilter() { CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter(); filter.setEncoding(this.properties.getCharset().name()); filter.setForceRequestEncoding(this.properties.shouldForce(org.springframework.boot.web.servlet.server.Encoding.Type.REQUEST)); filter.setForceResponseEncoding(this.properties.shouldForce(org.springframework.boot.web.servlet.server.Encoding.Type.RESPONSE)); return filter; } // ...... } 连接数据库SpringBoot默认自动配置的数据源为class com.zaxxer.hikari.HikariDataSource，可直接注入使用，数据源的自动配置类DataSourceAutoConfiguration @Import({Hikari.class, Tomcat.class, Dbcp2.class, OracleUcp.class, Generic.class, DataSourceJmxConfiguration.class}) protected static class PooledDataSourceConfiguration { protected PooledDataSourceConfiguration() { } } SpringBoot也默认自动配置了JdbcTemplate放在容器中用于直接注入使用，其自动配置类JdbcTemplateConfiguration 通过主配置文件spring.datasource.type可指定其他数据源 spring: datasource: username: root password: 123456 #?serverTimezone=UTC解决时区的报错 url: jdbc:mysql://localhost:3306/springboot?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8 driver-class-name: com.mysql.cj.jdbc.Driver type: com.alibaba.druid.pool.DruidDataSource #Spring Boot 默认是不注入这些属性值的，需要自己绑定 #druid 数据源专有配置 initialSize: 5 minIdle: 5 maxActive: 20 maxWait: 60000 timeBetweenEvictionRunsMillis: 60000 minEvictableIdleTimeMillis: 300000 validationQuery: SELECT 1 FROM DUAL testWhileIdle: true testOnBorrow: false testOnReturn: false poolPreparedStatements: true #配置监控统计拦截的filters，stat:监控统计、log4j：日志记录、wall：防御sql注入 filters: stat,wall,log4j maxPoolPreparedStatementPerConnectionSize: 20 useGlobalDataSourceStat: true connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500 需要为DruidDataSource绑定全局配置文件中的参数，再添加到容器中 import com.alibaba.druid.pool.DruidDataSource; import javax.sql.DataSource; @Configuration public class DruidConfig { /* 将自定义的Druid数据源添加到容器中，不再让SpringBoot自动创建 绑定全局配置文件中的druid数据源属性到com.alibaba.druid.pool.DruidDataSource从而让它们生效 */ @ConfigurationProperties(prefix = &quot;spring.datasource&quot;) @Bean public DataSource druidDataSource() { return new DruidDataSource(); } } Druid数据源具有监控的功能，并提供了一个web界面方便用户查看 //配置 Druid 监控管理后台的Servlet； //内置 Servlet 容器时没有web.xml文件，所以使用 Spring Boot 的注册 Servlet 方式 @Bean public ServletRegistrationBean statViewServlet() { ServletRegistrationBean bean = new ServletRegistrationBean(new StatViewServlet(), &quot;/druid/*&quot;); // 这些参数可以在 com.alibaba.druid.support.http.StatViewServlet // 的父类 com.alibaba.druid.support.http.ResourceServlet 中找到 Map&lt;String, String&gt; initParams = new HashMap&lt;&gt;(); initParams.put(&quot;loginUsername&quot;, &quot;admin&quot;); //后台管理界面的登录账号 initParams.put(&quot;loginPassword&quot;, &quot;123456&quot;); //后台管理界面的登录密码 //后台允许谁可以访问 //initParams.put(&quot;allow&quot;, &quot;localhost&quot;)：表示只有本机可以访问 //initParams.put(&quot;allow&quot;, &quot;&quot;)：为空或者为null时，表示允许所有访问 initParams.put(&quot;allow&quot;, &quot;&quot;); //deny：Druid 后台拒绝谁访问 //initParams.put(&quot;kuangshen&quot;, &quot;192.168.1.20&quot;);表示禁止此ip访问 //设置初始化参数 bean.setInitParameters(initParams); return bean; } 配置 Druid web 监控 filter 过滤器 //配置 Druid 监控 之 web 监控的 filter //WebStatFilter：用于配置Web和Druid数据源之间的管理关联监控统计 @Bean public FilterRegistrationBean webStatFilter() { FilterRegistrationBean bean = new FilterRegistrationBean(); bean.setFilter(new WebStatFilter()); //exclusions：设置哪些请求进行过滤排除掉，从而不进行统计 Map&lt;String, String&gt; initParams = new HashMap&lt;&gt;(); initParams.put(&quot;exclusions&quot;, &quot;*.js,*.css,/druid/*,/jdbc/*&quot;); bean.setInitParameters(initParams); //&quot;/*&quot; 表示过滤所有请求 bean.setUrlPatterns(Arrays.asList(&quot;/*&quot;)); return bean; } 整合Mybatis导入依赖 &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.1&lt;/version&gt; &lt;/dependency&gt; 创建mapper目录以及对应的Mapper接口，如果不使用@Mapper注解，也可以在直接在主程序入口添加Mapper扫描@Mapper(basePackages=&quot;com.xxx.mapper.DepartmentMapper&quot;)。 //@Mapper : 表示本类是一个 MyBatis 的 Mapper @Mapper @Repository public interface DepartmentMapper { // 获取所有部门信息 List&lt;Department&gt; getDepartments(); // 通过id获得部门 Department getDepartment(Integer id); } 对应的Mapper映射文件 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; &lt;mapper namespace=&quot;com.xxx.mapper.DepartmentMapper&quot;&gt; &lt;select id=&quot;getDepartments&quot; resultType=&quot;Department&quot;&gt; select * from department; &lt;/select&gt; &lt;select id=&quot;getDepartment&quot; resultType=&quot;Department&quot; parameterType=&quot;int&quot;&gt; select * from department where id = #{id}; &lt;/select&gt; &lt;/mapper&gt; 如果与Mapper接口放在同一个包下则可以自动扫描到，但是需要配置静态资源过滤。 &lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt; 否则需要在主配置文件中配置扫描地址mybatis.mapper-locations=classpath:mapper/*.xml，但此时不需要配置文件过滤。 编写DepartmentController进行测试 @RestController public class DepartmentController { @Autowired DepartmentMapper departmentMapper; // 查询全部部门 @GetMapping(&quot;/getDepartments&quot;) public List&lt;Department&gt; getDepartments(){ return departmentMapper.getDepartments(); } // 查询全部部门 @GetMapping(&quot;/getDepartment/{id}&quot;) public Department getDepartment(@PathVariable(&quot;id&quot;) Integer id){ return departmentMapper.getDepartment(id); } } 静态资源映射在WebMvcAutoConfiguration下，WebMvcAutoConfigurationAdapter中的addResourceHandler方法可添加资源处理 @Import({WebMvcAutoConfiguration.EnableWebMvcConfiguration.class}) @EnableConfigurationProperties({WebMvcProperties.class, WebProperties.class}) public static class WebMvcAutoConfigurationAdapter implements WebMvcConfigurer, ServletContextAware { // ...... public void addResourceHandlers(ResourceHandlerRegistry registry) { if (!this.resourceProperties.isAddMappings()) { logger.debug(&quot;Default resource handling disabled&quot;); } else { this.addResourceHandler(registry, &quot;/webjars/**&quot;, &quot;classpath:/META-INF/resources/webjars/&quot;); this.addResourceHandler(registry, this.mvcProperties.getStaticPathPattern(), (registration) -&gt; { registration.addResourceLocations(this.resourceProperties.getStaticLocations()); if (this.servletContext != null) { ServletContextResource resource = new ServletContextResource(this.servletContext, &quot;/&quot;); registration.addResourceLocations(new Resource[]{resource}); } }); } } } Webjars本质就是以jar包的方式引入我们的静态资源，导入jQuery的对应依赖即可使用，另一种静态资源映射规则是访问当前项目任意资源/**，在WebMvcProperties.class中定义，在resourceProperties.class中可以找到对应的与访问静态资源有关的参数设置 public static class Resources { private static final String[] CLASSPATH_RESOURCE_LOCATIONS = new String[]{&quot;classpath:/META-INF/resources/&quot;, &quot;classpath:/resources/&quot;, &quot;classpath:/static/&quot;, &quot;classpath:/public/&quot;}; private String[] staticLocations; // ...... public Resources() { this.staticLocations = CLASSPATH_RESOURCE_LOCATIONS; // ...... } } 也可以在SpringBoot的主配置文件中配置，比如spring.resources.static-locations=classpath:/xx/,classpath:/xx/ 设置主页在WebMvcAutoConfiguration下，EnableConfiguration类中定义了起始页面的相关参数设置。还可以在静态资源目录下设置网站图标，不过要先关闭SpringBoot默认图标spring.mvc.favicon.enabled=false private Resource getWelcomePage() { String[] var1 = this.resourceProperties.getStaticLocations(); // 映射规则为&#39;/**&#39; int var2 = var1.length; for(int var3 = 0; var3 &lt; var2; ++var3) { String location = var1[var3]; Resource indexHtml = this.getIndexHtml(location); if (indexHtml != null) { return indexHtml; } } ServletContext servletContext = this.getServletContext(); if (servletContext != null) { return this.getIndexHtml((Resource)(new ServletContextResource(servletContext, &quot;/&quot;))); } else { return null; } } private Resource getIndexHtml(String location) { return this.getIndexHtml(this.resourceLoader.getResource(location)); } private Resource getIndexHtml(Resource location) { try { Resource resource = location.createRelative(&quot;index.html&quot;); if (resource.exists() &amp;&amp; resource.getURL() != null) { return resource; } } catch (Exception var3) { } return null; } MVC自动配置原理Spring MVC Auto-configuration // Spring Boot为Spring MVC提供了自动配置，它可以很好地与大多数应用程序一起工作。 Spring Boot provides auto-configuration for Spring MVC that works well with most applications. // 自动配置在Spring默认设置的基础上添加了以下功能： The auto-configuration adds the following features on top of Spring’s defaults: // 包含视图解析器 Inclusion of ContentNegotiatingViewResolver and BeanNameViewResolver beans. // 支持静态资源文件夹的路径，以及webjars Support for serving static resources, including support for WebJars // 自动注册了Converter： // 转换器，这就是我们网页提交数据到后台自动封装成为对象的东西，比如把&quot;1&quot;字符串自动转换为int类型 // Formatter：【格式化器，比如页面给我们了一个2019-8-10，它会给我们自动格式化为Date对象】 Automatic registration of Converter, GenericConverter, and Formatter beans. // HttpMessageConverters // SpringMVC用来转换Http请求和响应的，比如我们要把一个User对象转换为JSON字符串，可以去看官网文档解释； Support for HttpMessageConverters (covered later in this document). // 定义错误代码生成规则的 Automatic registration of MessageCodesResolver (covered later in this document). // 首页定制 Static index.html support. // 初始化数据绑定器：帮我们把请求数据绑定到JavaBean中！ Automatic use of a ConfigurableWebBindingInitializer bean (covered later in this document). /* 如果您希望保留Spring Boot MVC功能，并且希望添加其他MVC配置（拦截器、格式化程序、视图控制器和其他功能），则可以添加自己 的@configuration类，类型为webmvcconfiguer，但不添加@EnableWebMvc。如果希望提供 RequestMappingHandlerMapping、RequestMappingHandlerAdapter或ExceptionHandlerExceptionResolver的自定义 实例，则可以声明WebMVCregistrationAdapter实例来提供此类组件。 */ If you want to keep Spring Boot MVC features and you want to add additional MVC configuration (interceptors, formatters, view controllers, and other features), you can add your own @Configuration class of type WebMvcConfigurer but without @EnableWebMvc. If you wish to provide custom instances of RequestMappingHandlerMapping, RequestMappingHandlerAdapter, or ExceptionHandlerExceptionResolver, you can declare a WebMvcRegistrationsAdapter instance to provide such components. // 如果您想完全控制Spring MVC，可以添加自己的@Configuration，并用@EnableWebMvc进行注释。 If you want to take complete control of Spring MVC, you can add your own @Configuration annotated with @EnableWebMvc. 在WebMvcAutoConfiguration下，找到内容协商视图解析器ContentNegotiatingViewResolver，在viewResolver方法中，进到这个类里面可以看到有关解析视图的代码，说明其作用就是组合视图解析器。因此可以自己添加一个视图解析器，这个类就会将它与SpringBoot中自动配置的视图解析器组合 @Nullable // 参数可为null public View resolveViewName(String viewName, Locale locale) throws Exception { RequestAttributes attrs = RequestContextHolder.getRequestAttributes(); Assert.state(attrs instanceof ServletRequestAttributes, &quot;No current ServletRequestAttributes&quot;); List&lt;MediaType&gt; requestedMediaTypes = this.getMediaTypes(((ServletRequestAttributes)attrs).getRequest()); if (requestedMediaTypes != null) { // 获取候选的视图对象 List&lt;View&gt; candidateViews = this.getCandidateViews(viewName, locale, requestedMediaTypes); // 选择一个最适合的视图对象，然后把这个对象返回 View bestView = this.getBestView(candidateViews, requestedMediaTypes, attrs); if (bestView != null) { return bestView; } } } // ...... private List&lt;View&gt; getCandidateViews(String viewName, Locale locale, List&lt;MediaType&gt; requestedMediaTypes) throws Exception { List&lt;View&gt; candidateViews = new ArrayList(); if (this.viewResolvers != null) { Assert.state(this.contentNegotiationManager != null, &quot;No ContentNegotiationManager set&quot;); Iterator var5 = this.viewResolvers.iterator(); // 把所有的视图解析器，while循环，挨个解析 while(var5.hasNext()) { ViewResolver viewResolver = (ViewResolver)var5.next(); View view = viewResolver.resolveViewName(viewName, locale); if (view != null) { candidateViews.add(view); } // ...... } } } protected void initServletContext(ServletContext servletContext) { // 这里它是从beanFactory工具中获取容器中的所有视图解析器 // ViewResolver.class 把所有的视图解析器来组合的 Collection&lt;ViewResolver&gt; matchingBeans = BeanFactoryUtils.beansOfTypeIncludingAncestors(this.obtainApplicationContext(), ViewResolver.class).values(); ViewResolver viewResolver; if (this.viewResolvers == null) { this.viewResolvers = new ArrayList(matchingBeans.size()); Iterator var3 = matchingBeans.iterator(); while(var3.hasNext()) { viewResolver = (ViewResolver)var3.next(); if (this != viewResolver) { this.viewResolvers.add(viewResolver); } } // ...... } } SpringBoot自动配置很多组件时，先看容器中有没有用户自己配置的@bean，如果没有就用自动配置的，且有些组件可以存在多个 //应为类型要求为WebMvcConfigurer，所以我们实现其接口 //可以使用自定义类扩展MVC的功能 @Configuration public class MyMvcConfig implements WebMvcConfigurer { @Override public void addViewControllers(ViewControllerRegistry registry) { // 浏览器发送/test ， 就会跳转到test页面； registry.addViewController(&quot;/test&quot;).setViewName(&quot;test&quot;); } } 我们也可以扩展配置。比如设置虚拟目录映射，用于解决文件回显显示的问题 @Configuration public class MyMvcConfig implements WebMvcConfigurer { // 文件保存在真实目录/upload/下， // 访问的时候使用虚路径/upload，比如文件名为1.png，就直接/upload/1.png就ok了。 @Override public void addResourceHandlers(ResourceHandlerRegistry registry) { registry.addResourceHandler(&quot;/upload/**&quot;) .addResourceLocations(&quot;file:&quot;+System.getProperty(&quot;user.dir&quot;)+&quot;/upload/&quot;); } } 在WebMvcAutoConfiguration中，WebMvcAutoConfigurationAdapter上有注解@Import(EnableWebMvcConfiguration.class，对应类继承了DelegatingWebMvcConfiguration父类 public class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport { private final WebMvcConfigurerComposite configurers = new WebMvcConfigurerComposite(); // 从容器中获取所有的webmvcConfigurer @Autowired(required = false) public void setConfigurers(List&lt;WebMvcConfigurer&gt; configurers) { if (!CollectionUtils.isEmpty(configurers)) { this.configurers.addWebMvcConfigurers(configurers); } } protected void addViewControllers(ViewControllerRegistry registry) { this.configurers.addViewControllers(registry); } // ...... } 其中设置viewController中调用了addViewControllers方法，可以看出不止SpringBoot的自动配置类，我们自己编写的扩展配置类也会被调用 public void addViewControllers(ViewControllerRegistry registry) { Iterator var2 = this.delegates.iterator(); while(var2.hasNext()) { // 将所有的WebMvcConfigurer相关配置进行组合调用，包括我们自定义的配置和SpringBoot的自动配置 WebMvcConfigurer delegate = (WebMvcConfigurer)var2.next(); delegate.addViewControllers(registry); } } 而@EnableWebMvc注解类导入了继承父类WebMvcConfigurationSupport的DelegatingWebMvcConfiguration类，而WebMvcConfigurationSupport组件只包含SpringMVC最基本的功能 @Import({DelegatingWebMvcConfiguration.class}) public @interface EnableWebMvc { // ...... } public class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport { // ...... } @Configuration(proxyBeanMethods = false) @ConditionalOnWebApplication(type = Type.SERVLET) @ConditionalOnClass({ Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class }) // 这个注解的意思就是：容器中没有这个组件的时候，这个自动配置类才生效 @ConditionalOnMissingBean(WebMvcConfigurationSupport.class) public class WebMvcAutoConfiguration { // ...... } 使得WebMvcAutoConfiguration自动配置类失效，从而全面接管SpringMVC的配置，因此这是不推荐的 集成Swagger导入依赖 &lt;dependency&gt; &lt;groupId&gt;com.mangofactory&lt;/groupId&gt; &lt;artifactId&gt;swagger-springmvc&lt;/artifactId&gt; &lt;version&gt;1.0.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.10.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.10.5&lt;/version&gt; &lt;/dependency&gt; 编写配置类SwaggerConfig @Configuration // 配置类 @EnableSwagger2 // 开启Swagger2的自动配置 public class SwaggerConfig { @Bean // 配置docket以配置Swagger具体参数 public Docket docket() { // 设置要显示swagger的环境 Profiles of = Profiles.of(&quot;dev&quot;, &quot;test&quot;); // 判断当前是否处于该环境 // 通过 enable() 接收此参数判断是否要显示 boolean b = environment.acceptsProfiles(of); return new Docket(DocumentationType.SWAGGER_2).apiInfo(apiInfo()); // 实例关联上 apiInfo() .enable(b) // 配置是否启用Swagger，如果是false，在浏览器将无法访问 .select() // 通过.select()方法，去配置扫描接口，RequestHandlerSelectors配置如何扫描接口 .apis(RequestHandlerSelectors.basePackage(&quot;com.kuang.swagger.controller&quot;)) .paths(PathSeletors.ant(&quot;/author/**&quot;)) // 配置如何通过path过滤，这里只扫描请求以 /author 开头的接口 .groupName(&quot;hello&quot;) // 配置分组，配置多个分组只需要配置多个docket即可 .build(); } //配置文档信息 private ApiInfo apiInfo() { Contact contact = new Contact(&quot;联系人名字&quot;, &quot;http://xxx.xxx.com/联系人访问链接&quot;, &quot;联系人邮箱&quot;); return new ApiInfo( &quot;Swagger学习&quot;, // 标题 &quot;学习演示如何配置Swagger&quot;, // 描述 &quot;v1.0&quot;, // 版本 &quot;http://terms.service.url/组织链接&quot;, // 组织链接 contact, // 联系人信息 &quot;Apach 2.0 许可&quot;, // 许可 &quot;许可链接&quot;, // 许可连接 new ArrayList&lt;&gt;()// 扩展 ); } } 除了通过包路径配置扫描接口外，还通过配置其他方式扫描接口 any() // 扫描所有，项目中的所有接口都会被扫描到 none() // 不扫描接口 // 通过方法上的注解扫描，如withMethodAnnotation(GetMapping.class)只扫描get请求 withMethodAnnotation(final Class&lt;? extends Annotation&gt; annotation) // 通过类上的注解扫描，如.withClassAnnotation(Controller.class)只扫描有controller注解的类中的接口 withClassAnnotation(final Class&lt;? extends Annotation&gt; annotation) basePackage(final String basePackage) // 根据包路径扫描接口 配置接口扫描过滤 any() // 任何请求都扫描 none() // 任何请求都不扫描 regex(final String pathRegex) // 通过正则表达式控制 ant(final String antPattern) // 通过ant()控制 请求接口的返回值（包括泛型），都会映射到实体类上，@ApiModel和@ApiModelProperty只是为实体类添加注释 .center { width: auto; display: table; margin-left: auto; margin-right: auto; } Swagger注解 简单说明 @Api(tags=”xxx模块说明”) 作用在模块类上 @ApiOperation(“xxx接口说明”) 作用在接口方法上 @ApiModel(“xxxPOJO说明”) 作用在模型类上：如VO、BO @ApiModelProperty(value = “xxx属性说明”,hidden = true) 作用在类方法和属性上，hidden设置为true可以隐藏该属性 @ApiParam(“xxx参数说明”) 作用在参数、方法和字段上，类似@ApiModelProperty 异步任务为了便于后台使用多线程的方式进行异步处理，可以用@Async注解一个异步方法，此时SpringBoot就会自己开一个线程池进行调用，需要在主程序入口上添加一个注解@EnableAsync，开启异步注解功能 定时任务SpringBoot提供了异步执行任务调度的方式，提供了接口TaskExecutor和TaskScheduler，以及注解Scheduled，需要在主程序入口上添加注解@EnableScheduling，开启定时任务功能 @Service public class ScheduledService { //秒 分 时 日 月 周几 //0 * * * * MON-FRI //注意cron表达式的用法； @Scheduled(cron = &quot;0 * * * * 0-7&quot;) // 定义方法的定时执行 public void hello(){ System.out.println(&quot;hello.....&quot;); } } cron 表达式 字段 允许值 允许的特殊字符 秒 0-59 ,-*/ 分 0-59 ,-*/ 小时 0-23 ,-*/ 日期 1-31 ,-*?/L W C 月份 1-12 ,-*/ 星期 0-7或SUN-SAT 0,7是SUN ,-*?/L C W 特殊字符 代表含义 , 枚举 - 区间 * 任意 / 步长 ? 日/星期冲突匹配 L 最后 W 工作日 C 和calendar联系后计算过的值 # 星期，4#2，第2个星期三 邮件任务导入依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt; &lt;/dependency&gt; 查看自动配置类MailSenderAutoConfiguration，开启了自动配置@EnableConfigurationProperties({MailProperties.class})，对应SpringBoot主配置文件中可配置参数 @ConfigurationProperties( prefix = &quot;spring.mail&quot; ) public class MailProperties { private static final Charset DEFAULT_CHARSET; private String host; private Integer port; private String username; private String password; private String protocol = &quot;smtp&quot;; private Charset defaultEncoding; private Map&lt;String, String&gt; properties; private String jndiName; // ...... } 自动配置类中没有注册bean，发现导入类MailSenderJndiConfiguration，其中注册了类JavaMailSenderImpl，其中定义了邮件发送的方法 @Bean JavaMailSenderImpl mailSender(Session session) { JavaMailSenderImpl sender = new JavaMailSenderImpl(); sender.setDefaultEncoding(this.properties.getDefaultEncoding().name()); sender.setSession(session); return sender; } 邮件收发测试 @Autowired JavaMailSenderImpl mailSender; @Test public void contextLoads2() throws MessagingException { // SimpleMailMessage message = new SimpleMailMessage(); // 发送简单邮件 MimeMessage mimeMessage = mailSender.createMimeMessage(); // 复杂邮件 MimeMessageHelper helper = new MimeMessageHelper(mimeMessage, true); helper.setSubject(&quot;主题&quot;); helper.setText(&quot;正文&quot;,true); // 可以插入html样式 //发送附件 helper.addAttachment(&quot;1.jpg&quot;,new File(&quot;&quot;)); helper.addAttachment(&quot;2.jpg&quot;,new File(&quot;&quot;)); helper.setTo(&quot;xxx@qq.com&quot;); helper.setFrom(&quot;xxx@qq.com&quot;); mailSender.send(mimeMessage); } 整合Redis导入依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt; &lt;/dependency&gt; 找到SpringBoot中有关Redis的自动配置RedisAutoConfiguration @AutoConfiguration @ConditionalOnClass({RedisOperations.class}) @EnableConfigurationProperties({RedisProperties.class}) @Import({LettuceConnectionConfiguration.class, JedisConnectionConfiguration.class}) public class RedisAutoConfiguration { public RedisAutoConfiguration() { } @Bean @ConditionalOnMissingBean( name = {&quot;redisTemplate&quot;} ) // 说明可以编写自己的 redisTemplate 来覆盖自动配置的 @ConditionalOnSingleCandidate(RedisConnectionFactory.class) public RedisTemplate&lt;Object, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) { RedisTemplate&lt;Object, Object&gt; template = new RedisTemplate(); template.setConnectionFactory(redisConnectionFactory); return template; } @Bean @ConditionalOnMissingBean @ConditionalOnSingleCandidate(RedisConnectionFactory.class) public StringRedisTemplate stringRedisTemplate(RedisConnectionFactory redisConnectionFactory) { return new StringRedisTemplate(redisConnectionFactory); } } 在RedisProperties.class里发现能在SpringBoot主配置文件中配置的redis相关参数 @ConfigurationProperties( prefix = &quot;spring.redis&quot; ) public class RedisProperties { private int database = 0; private String url; private String host = &quot;localhost&quot;; private String username; private String password; private int port = 6379; private boolean ssl; private Duration timeout; private Duration connectTimeout; private String clientName; private RedisProperties.ClientType clientType; private RedisProperties.Sentinel sentinel; private RedisProperties.Cluster cluster; // ...... } 实体类作为数据传递时需要进行序列化，比如实现serializable接口，或者自定义配置类，修改自动配置中的序列化方法 @Configuration public class RedisConfig { @Bean @SuppresWarnings(&quot;all&quot;) // 定制一个 RedisTemplate public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) { // 一般直接使用 &lt;String, Object&gt; RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;(); template.setConnectionFactory(redisConnectionFactory); //Json序列化配置 Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class); ObjectMapper om = new ObjectMapper(); om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); jackson2JsonRedisSerializer.setObjectMapper(om); StringRedisSerializer stringRedisSerializer = StringRedisSerializer(); // key采用String的序列化方式 template.setKeySerializer(stringRedisSerializer); // hash的key也采用String的序列化方式 template.setHashKeySerializer(stringRedisSerializer); // value序列化方式采用jackson template.setValueSerializer(jackson2JsonRedisSerializer); // hash的value序列化方式采用jackson template.setHashValueSerializer(jackson2JsonRedisSerializer); template.afterPropertiesSet(); return template; } } Redis的基本操作都通过注入的redisTemplate的API进行实现，一般进一步封装成工具类RedisUtil以便开发。 还可以使用Redis来作为Cache的实现，首先在主程序入口加入注解@EnableCaching，发现SpringBoot自动配置了一个RedisCacheManager，它间接实现了Spring中的Cache接口： @Configuration @ConditionalOnClass(RedisConnectionFactory.class) @AutoConfigureAfter(RedisAutoConfiguration.class) @ConditionalOnBean(RedisConnectionFactory.class) @ConditionalOnMissingBean(CacheManager.class) @Conditional(CacheCondition.class) class RedisCacheConfiguration { @Bean public RedisCacheManager cacheManager(RedisConnectionFactory redisConnectionFactory, ResourceLoader resourceLoader) { RedisCacheManagerBuilder builder = RedisCacheManager .builder(redisConnectionFactory) .cacheDefaults(determineConfiguration(resourceLoader.getClassLoader())); List&lt;String&gt; cacheNames = this.cacheProperties.getCacheNames(); if (!cacheNames.isEmpty()) { builder.initialCacheNames(new LinkedHashSet&lt;&gt;(cacheNames)); } returnthis.customizerInvoker.customize(builder.build()); } } @CacheConfig注解在类上使用，用来描述该类中所有方法使用的缓存名称。 @Service @CacheConfig(cacheNames = &quot;c1&quot;) publicclass UserService { } @Cacheable注解一般用在查询方法上，表示将一个方法的返回值缓存起来。默认情况下，缓存的key就是方法的参数，缓存的value就是方法的返回值。 @Cacheable(key = &quot;#id&quot;) // 也可以通过 key 属性来指定键，如果对缓存的键有复杂要求，可以自定义 keyGenerator public User getUserById(Integer id,String username) { System.out.println(&quot;getUserById&quot;); return getUserFromDBById(id); } 也可以使用Spring Cache中提供的root对象： 属性 描述 实例 methodName 当前方法名 #root.methodName method 当前方法 #root.method.name target 当前被调用的对象 #root.target targetClass 当前被调用的对象的class #root.targetClass args 当前方法参数数组 #root.args[0] caches 当前被调用的方法使用的Cache #root.caches[0].name @CachePut注解一般用在更新方法上，当数据库中的数据更新后，缓存中的数据也要跟着更新，使用该注解，可以将方法的返回值自动更新到已经存在的key上。 @CachePut(key = &quot;#user.id&quot;) public User updateUserById(User user) { return user; } @CacheEvict注解一般用在删除方法上，当数据库中的数据删除后，相关的缓存数据也要自动清除，该注解在使用的时候也可以配置按照某种条件删除（condition 属性）或者或者配置清除所有缓存（allEntries 属性）。 @CacheEvict() public void deleteUserById(Integer id) { //在这里执行删除操作，删除是去数据库中删除 } 整合rabbitmq芋道SpringBoot消息队列rabbitmq入门 整合Websocket导入依赖： &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt; &lt;/dependency&gt; 编写配置类WebSocketConfig： @Configuration @EnableWebSocketMessageBroker // 表示使用STOMP协议（webSocket的子协议）来传输基于消息代理的消息 // 此时可以在@Controller类中使用@MessageMapping，类似于@RequestMapping public class WebSocketConfig implements WebSocketMessageBrokerConfigurer { @Override public void registerStompEndpoints(StompEndpointRegistry registry) { /* 注册Stomp的端点 addEndpoint：添加STOMP协议的端点。这个HTTP URL是供WebSocket或SockJS客户端访问的地址 withSockJS：指定端点使用SockJS协议 */ registry.addEndpoint(&quot;/simple&quot;) .setAllowedOrigins(&quot;http://localhost:8080&quot;) // 添加允许跨域访问 .withSockJS(); // sockjs是websocket协议的实现，增加了对浏览器不支持websocket的时候的兼容支持 // SockJS的支持的传输的协议有3类: WebSocket, HTTP Streaming, and HTTP Long Polling // 默认使用websocket，如果浏览器不支持websocket，则使用后两类 } @Override public void configureMessageBroker(MessageBrokerRegistry registry) { /* 配置消息代理 启动简单Broker，消息的发送的地址符合配置的前缀来的消息才发送到这个broker */ registry.enableSimpleBroker(&quot;/topic&quot;); } } 编写controller： @Controller public class WsController { @Autowired SimpMessagingTemplate simpMessagingTemplate; @MessageMapping(&quot;/ws/chat&quot;) // 指定要接收消息的地址，类似@RequestMapping。除了注解到方法上，也可以注解到类上 @SendTo(&quot;/topic/say&quot;) // 注解表示当服务器有消息需要推送的时候，会对订阅了@SendTo中路径的浏览器发送消息 public ResponseMessage say(RequestMessage message) { System.out.pringln(message.getName()); return new ResponseMessage(&quot;welcome&quot; + message.getName() + &quot; !&quot;); } /** * 定时推送消息 */ @Scheduled(fixedRate=1000) public void callback() { // 发现消息 DateFormat df = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); messageingTemplate.convertAndSend(&quot;/topic/callback&quot;, &quot;定时推送消息时间：&quot; + df.format(new Date())); } } 前端调用方式类似如下： var stompClient = null; function connect() { var socket = new SockJS(&#39;http://localhost:8081/simple&#39;); // 连接到/simple节点 stompClient = Stomp.over(socket); stompClient.connect({}, function (frame) { setConnected(true); console.log(&#39;Connected:&#39; + frame); // 会接收到服务器的say方法的返回 stompClient.subscribe(&#39;/topic/say&#39;, function (response) { showResponse(JSON.parse(response.body).responseMessage); }); // 再订阅一下定时任务 stompClient.subscribe(&#39;/topic/callback&#39;, function (response) { showCallback(response.body); }); }); } function disconnect() { if (stompClient != null) { stompClient.disconnect(); } console.log(&#39;Disconnected&#39;); } function sendName() { var name = $(&#39;#name&#39;).val(); console.log(&#39;name:&#39; + name); stompClient.send(&quot;/welcome&quot;, {}, JSON.stringify({&#39;name&#39;: name})); // 想/welcome的url发送消息 } function showResponse(message) { $(&quot;#response&quot;).html(message); } function showCallback(message) { $(&quot;#callback&quot;).html(message); }","categories":[{"name":"生活","slug":"生活","permalink":"http://goodguyjameswin.github.io/categories/生活/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://goodguyjameswin.github.io/tags/学习笔记/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"http://goodguyjameswin.github.io/categories/生活/"}]},{"title":"优先队列","slug":"优先队列","date":"2022-05-15T10:43:39.000Z","updated":"2022-07-20T11:14:47.876Z","comments":false,"path":"2022/05/15/优先队列/","link":"","permalink":"http://goodguyjameswin.github.io/2022/05/15/优先队列/","excerpt":"","text":"堆优先队列是抽象数据类型，而堆是具体的、高效的实现，显然用数组可以实现优先队列，但是无法突破时间复杂度O(N)的限制，可以通过将数组表示成树形结构来实现堆，其优点是不用维护左右子结点、父结点的引用关系。 完全二叉树，指的是在二叉树的基础上，从上至下、从左至右没有空结点。堆是完全二叉树，又分为最大堆和最小堆，前者表示任一结点的数值都大于等于它的两个孩子结点的数值，后者则表示任一结点的数值都小于等于它的两个孩子结点（如存在）的数值，因此它是一个局部有序的结构。 用数组实现堆public class MaxHeap implements Queue { /** * 本实现 0 号下标不存放真正数据，底层使用动态数组是更好的实现 */ private int[] data; /** * 堆中能够存储的元素的最大数量 */ private int capacity; /** * 当前最大堆中真正存储的元素的个数 */ private int size; @Override public int size() { return size; } @Override public boolean isEmpty() { return size == 0; } @Override public int peek() { if (isEmpty()) { throw new IllegalArgumentException(&quot;堆为空。&quot;); } // 下标 0 不存元素 return data[1]; } public MaxHeap(int capacity) { data = new int[capacity + 1]; this.capacity = capacity; size = 0; } @Override public void offer(int item) { if (size + 1 &gt; capacity) { throw new IllegalArgumentException(&quot;堆空间已满。&quot;); } // 把新添加的元素放在数组的最后一位 data[size + 1] = item; // 维护 size 的定义 size++; // 考虑将 data[size] 元素上移到合适的位置 siftUp(size); } private void shiftUp(int k) { // 先暂存，再逐个移动，最后空出位置把先前暂存元素放进去 int temp = data[k]; // 有下标就要考虑索引越界的情况，已经在下标 1 的位置，就没有必要上移了 while (k &gt; 1) { if (data[k / 2] &lt; temp) { data[k] = data[k / 2]; k /= 2; } else { break; } } data[k] = temp; } @Override public int poll() { if (size == 0) { throw new IllegalArgumentException(&quot;堆为空。&quot;); } int ret = data[1]; // 把最后一个元素的值赋值到二叉堆的根结点 data[1] = data[size]; size--; siftDown(1); return ret; } private void shiftDown(int k) { // 先暂存，再逐个移动，最后空出位置把先前暂存元素放进去 int temp = data[k]; // 只要它有孩子，注意这里使用等于号，是因为真正存数据的下标从 1 开始 while (2 * k &lt;= size) { int j = 2 * k; if (j + 1 &lt;= size &amp;&amp; data[j + 1] &gt; data[j]) { // 右边的孩子胜出，此时可以认为没有左孩子， j++; } // 如果当前的元素的值，比右边的孩子节点要大，则逐渐下落的过程到此结束 if (temp &gt;= data[j]) { break; } // 否则，交换位置，继续上浮 data[k] = data[j]; k = j; } data[k] = temp; } public void replace(int item) { if (isEmpty()) { throw new IllegalArgumentException(&quot;堆为空。&quot;); } // 注意：堆顶元素替换，size 不变 data[1] = item; siftDown(1); } } 将数组整理成堆 操作 具体描述 合理性解释 时间复杂度 自顶向下 从非根结点开始逐个上移（siftUp） 每一个结点朝上看是堆有序的 O(NlogN) 自底向上 从非叶子结点开始逐个下移（siftDown） 每一个结点朝下看是堆有序的 O(N) 因此自底向上是一种更高效的使得数组堆有序的方式，每一个元素执行sift down操作，一开始就排除了一半以上的元素，因为完全二叉树中，叶子结点的个数几乎占了整棵树结点总数的一半。 public MaxHeap(int[] arr) { capacity = arr.length + 1; data = new int[capacity]; size = arr.length; for (int i = 0; i &lt; size; i++) { data[i + 1] = arr[i]; } // 从 1 开始编号的堆最后一个非叶子结点的下标是 size / 2 for (int i = size / 2; i &gt;= 1; i--) { siftDown(i); } } 力扣295：中位数是有序列表中间的数。如果列表长度是偶数，中位数则是中间两个数的平均值。例如，[2,3,4]的中位数是3，[2,3]的中位数是(2+3)/2=2.5，设计一个数据结构满足以下操作： void addNum(int num) - 从数据流中添加一个这个念书到数据结构中 double findMedian() - 返回目前所有元素的中位数 查看解析 class MedianFinder { PriorityQueue&lt;Integer&gt; queMin; PriorityQueue&lt;Integer&gt; queMax; // 用两个优先队列`queMax`和`queMin`分别记录大于中位数的数和小于等于中位数的数。当累计添加的数的数量为奇数时，`queMin`中的数的数量比`queMax`多一个，此时中位数为`queMin`的队头。当累计添加的数的数量为偶数时，两个优先队列中的数的数量相同，此时中位数为它们的队头的平均值 public MedianFinder() { queMin = new PriorityQueue&lt;Integer&gt;((a, b) -&gt; (b - a)); queMax = new PriorityQueue&lt;Integer&gt;((a, b) -&gt; (a - b)); } public void addNum(int num) { if (queMin.isEmpty() || num &lt;= queMin.peek()) { queMin.offer(num); if (queMax.size() + 1 &lt; queMin.size()) { queMax.offer(queMin.poll()); } } else { queMax.offer(num); if (queMax.size() &gt; queMin.size()) { queMin.offer(queMax.poll()); } } } public double findMedian() { if (queMin.size() &gt; queMax.size()) { return queMin.peek(); } return (queMin.peek() + queMax.peek()) / 2.0; } } 力扣218：城市的天际线是从远处观看该城市中所有建筑物形成的轮廓的外部轮廓。给你所有建筑物的位置和高度，请返回由这些建筑物形成的天际线。 每个建筑物的几何信息由数组buildings表示，其中三元组building[i]=[lefti,righti,heighti]表示： lefti是第i座建筑物的左边缘的x坐标 righti是第i座建筑物右边缘的x坐标 heighti是第i座建筑物的高度 你可以假设所有的鉴主都是完美的长方形，在高度为0的绝对平坦的表面上。 天际线应该表示为由“关键点”组成的列表，格式[[x1,y1],[x2,y2],...]，并按x坐标进行排序。关键点是水平线段的左端点。列表中最后一个点是最右侧建筑物的终点，y坐标始终为0，仅用于标记天际线的终点。此外，任何两个相邻建筑物中间的地面都应被视为天际线轮廓的一部分。 注意：输出天际线中不得有连续的相同高度的水平线。例如[...[2 3],[4 5],[7 5],[11 5],[12 7]...]是不正确的答案；三条高度为5的线应该在最终输出中合并为一个：[...[2 3],[4 5],[12 7],...] 输入：buildings = [[2,9,10],[3,7,15],[5,12,12],[15,20,10],[19,24,8]] 输出：[[2,10],[3,15],[7,12],[12,0],[15,10],[20,8],[24,0]] 解释： 图A显示输入的所有建筑物的位置和高度， 图B显示由这些建筑物形成的天际线。图B中的红点表示输出列表中的关键点。 查看解析 class Solution { // 关键点的横坐标总是落在建筑的左右边缘上。给出「包含该横坐标」的定义：建筑的左边缘小于等于该横坐标，右边缘大于该横坐标（也就是不考虑建筑的右边缘）。 // 我们首先将「包含该横坐标」的建筑加入到优先队列中，然后不断检查优先队列的队首元素是否「包含该横坐标」，如果不「包含该横坐标」，我们就将该队首元素弹出队列，直到队空或队首元素「包含该横坐标」即可。最后我们用变量 maxn 记录最大高度（即纵坐标的值），当优先队列为空时，maxn=0，否则 maxn 即为队首元素。最后我们还需要再做一步检查：如果当前关键点的纵坐标大小与前一个关键点的纵坐标大小相同，则说明当前关键点无效，我们跳过该关键点即可。 public List&lt;List&lt;Integer&gt;&gt; getSkyline(int[][] buildings) { PriorityQueue&lt;int[]&gt; pq = new PriorityQueue&lt;int[]&gt;((a, b) -&gt; b[1] - a[1]); List&lt;Integer&gt; boundaries = new ArrayList&lt;Integer&gt;(); for (int[] building : buildings) { boundaries.add(building[0]); boundaries.add(building[1]); } Collections.sort(boundaries); List&lt;List&lt;Integer&gt;&gt; ret = new ArrayList&lt;List&lt;Integer&gt;&gt;(); int n = buildings.length, idx = 0; for (int boundary : boundaries) { while (idx &lt; n &amp;&amp; buildings[idx][0] &lt;= boundary) { pq.offer(new int[]{buildings[idx][1], buildings[idx][2]}); idx++; } while (!pq.isEmpty() &amp;&amp; pq.peek()[0] &lt;= boundary) { pq.poll(); } int maxn = pq.isEmpty() ? 0 : pq.peek()[1]; if (ret.size() == 0 || maxn != ret.get(ret.size() - 1).get(1)) { ret.add(Arrays.asList(boundary, maxn)); } } return ret; } } .center { width: auto; display: table; margin-left: auto; margin-right: auto; }","categories":[{"name":"生活","slug":"生活","permalink":"http://goodguyjameswin.github.io/categories/生活/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://goodguyjameswin.github.io/tags/学习笔记/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"http://goodguyjameswin.github.io/categories/生活/"}]},{"title":"springmvc学习","slug":"springmvc学习","date":"2022-05-12T03:35:02.000Z","updated":"2022-07-18T03:57:27.812Z","comments":false,"path":"2022/05/12/springmvc学习/","link":"","permalink":"http://goodguyjameswin.github.io/2022/05/12/springmvc学习/","excerpt":"","text":"构建工程xml配置方式开发新建Maven父工程，导入SpringMVC依赖： &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.3.20&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;4.0.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet.jsp-api&lt;/artifactId&gt; &lt;version&gt;2.3.3&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp.jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; 新建一个Module，添加web的支持： 确保附加库可被打包进web工程： 配置Tomcat： 配置web.xml，注册DispatcherServlet： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;!-- 配置DispatcherServlet --&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;!-- 关联 Spring 的配置文件 --&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;!-- 启动级别：随着服务器启动而启动 --&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!-- / 匹配所有的请求（不包括.jsp），/* 配置所有的请求（包括.jsp） --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!-- 配置 Spring MVC 的乱码过滤 --&gt; &lt;filter&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;/web-app&gt; resources目录下新建Spring的配置文件applicationContext.xml： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!-- 添加处理映射器 --&gt; &lt;bean class=&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;/&gt; &lt;!-- DispatchServlet 调用 HandlerMapping，HandlerMapping 根据请求 url 查找 Handler --&gt; &lt;!-- 添加处理器适配器 --&gt; &lt;bean class=&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;/&gt; &lt;!-- HandlerAdapter 按照特定的规则去执行 Handler，Handler 让具体的 Controller 执行，Controller 将具体的执行信息返回给 HandlerAdapter，HandlerAdapter 将模型视图（ModelAndView）传递给 DispatcherServlet --&gt; &lt;!--添加视图解析器--&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt; &lt;/bean&gt; &lt;!-- DispatcherServlet 调用视图解析器（ViewResolver）来解析 HandlerAdapter 传递的逻辑视图名，DispatcherServlet 调用具体的视图，最终呈现给用户 --&gt; &lt;!-- Handler --&gt; &lt;bean id=&quot;/hello&quot; class=&quot;controller.HelloController&quot;/&gt; &lt;!-- HandlerExecution 表示具体的 Handler，其根据 url 查找 Controller，然后将解析后的信息传递给 DispatcherServlet --&gt; &lt;/beans&gt; 新建Controller层： // 导入 SpringMVC 下的 Controller 接口 public class HelloController implements Controller { public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception{ ModelAndView mv = new ModelAndView(); mv.addObject(&quot;msg&quot;, &quot;HelloSpringMVC!&quot;); mv.setViewName(&quot;hello&quot;); // /WEB-INF/jsp/hello.jsp return mv; } } 注解方式开发修改applicationContext.xml文件： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!--1. 注解驱动--&gt; &lt;mvc:annotation-driven/&gt; &lt;!-- 在 spring 中一般采用 @RequestMapping 注解来完成映射关系，要想使 @RequestMapping 注解生效，必须向上下文中注册 DefaultAnnotationHandlerMapping 和一个 AnnotationMethodHandlerAdapter 实例，这两个实例分别在类级别和方法级别处理，而 annotation-driven 配置帮助我们自动完成上述两个实例的注入 --&gt; &lt;!--2. 静态资源过滤--&gt; &lt;mvc:default-servlet-handler/&gt; &lt;!--3. 扫描包：controller--&gt; &lt;context:component-scan base-package=&quot;controller&quot;/&gt; &lt;!--4. 视图解析器--&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt; &lt;/bean&gt; &lt;/beans&gt; 修改Controller层： @Controller public class HelloController { @RequestMapping(&quot;/hello&quot;) // 也可在类上注解，表示映射方法与映射类的路径拼接关系 public String hello(@RequestParam(&quot;username&quot;) String name, Model model) { // 接受前端用户传递的参数，判断参数的名字，假设名字一致，可以直接使用，假设传递的是一个对象，则匹配对象中的字段名，名字不一致则匹配不到，此时使用 @RequestParam 指定要接收传递的参数名 model.addAttribute(&quot;msg&quot;, &quot;Hello, SpringMVCAnnotation!&quot;); // 封装数据 return &quot;hello&quot;; // 会被视图解析器处理 // 不配置视图解析器的情况下 // return &quot;/WEB-INF/jsp/hello.jsp&quot; // 使用全限定路径表示转发 // return &quot;forward:/WEB-INF/jsp/hello.jsp&quot; // 转发（地址栏不变） // return &quot;redirect:/hello.jsp&quot; // 重定向（地址栏变化） } } // RestFul 风格 @Controller public class RestFulController { // 映射访问路径 @RequestMapping(value = &quot;/add/{a}/{b}&quot;, method = &quot;RequestMethod.POST&quot;) // @PostMapping(&quot;/add/{a}/{b}&quot;) // 方法级别的注解处理地址栏的指定请求方式 public String add(@PathVariable int a, @PathVariable String b, Model model) { // @PathVariable 注解让方法参数的值对应绑定到一个 URL 模板变量 int result = a + b; // Spring MVC 会自动实例化一个 Model 对象用于向视图中传值 model.addAtrribute(&quot;msg&quot;, &quot;结果：&quot; + result); return &quot;hello&quot;; } } json导入jackson依赖： &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.13.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;2.0.4&lt;/version&gt; &lt;/dependency&gt; 修改Controller层： @Controller // @RestController // 表示这个类下的所有方法都不会被视图解析器解析，而是直接返回 public class UserController { // 解决json数据乱码问题（不常用） @RequestMapping(value = &quot;/j1&quot;, produces = &quot;application/json;charset=utf-8&quot;) @ResponseBody // 这个方法被视图解析器解析，而是直接返回一个字符串，与 @RestController 效果相同 public String json() throws JsonProcessingException { // jackson ObjectMapper mapper = new ObjectMapper(); User user = new User(&quot;小明&quot;, 3, &quot;男&quot;); String str = mapper.writeValueAsString(user); // 方法将对象转换为json格式字符串 return str; // fastjson // str = JSON.toJSONString(user); // java 对象转 JSON 字符串 // User user_json = JSON.parseObject(str, User.class); // JSON 字符串转 java 对象 } } 为了解决json乱码问题，在applicationContext.xml文件中添加： &lt;mvc:annotation-driven&gt; &lt;mvc:message-converters register-defaults=&quot;true&quot;&gt; &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt; &lt;constructor-arg value=&quot;UTF-8&quot;/&gt; &lt;/bean&gt; &lt;bean class=&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;&gt; &lt;property name=&quot;objectMapper&quot;&gt; &lt;bean class=&quot;org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean&quot;&gt; &lt;property name=&quot;failOnEmptyBeans&quot; value=&quot;false&quot;/&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt; &lt;/mvc:annotation-driven&gt; 拦截器继承HandlerInterceptor接口： public class MyInterceptor implements HandlerInterceptor { // 请求处理的方法之前执行 // 如果返回 true，放行（如果有，执行下一个拦截器） // 如果返回 false，则拦截 public boolean preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) { System.out.pringln(&quot;-------处理前-------&quot;); return true; } public boolean postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) { System.out.pringln(&quot;-------处理后-------&quot;); } } 在applicationContext.xml文件中添加： &lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;!-- 包括这个请求下面的所有的请求 --&gt; &lt;mvc:mapping path=&quot;/**&quot;/&gt; &lt;bean class=&quot;interceptor.MyInterceptor&quot;/&gt; &lt;/mvc:interceptro&gt; &lt;/mvc:interceptors&gt; 文件上传导入依赖： &lt;!-- 文件上传 --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt; &lt;/dependency&gt; 在applicationContext.xml文件中添加： &lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt; &lt;!-- 请求的编码方式，必须和 jsp 的 pageEncoding 属性一致，以便正确读取表单内容，默认为 ISO-8859-1 --&gt; &lt;property name=&quot;defaultEncoding&quot; value=&quot;utf-8&quot;/&gt; &lt;/bean&gt; 修改Controller层: @RestController public class FileController { // @RequestParam(&quot;file&quot;) 将 name=file 控件得到的文件封装成 CommonsMultipartFile对象 @RequestMapping(&quot;/upload&quot;) public String fileUpload(@RequestParam(&quot;file&quot;) CommonsMultipartFile file, HttpServletRequest request) throws IOException { // 上传路径保存设置 String path = request.getServletContext().getRealPath(&quot;/upload&quot;); File realPath = new File(path); if (!realPath.exists()) { realPath.mkdir(); } // 上传文件地址 System.out.println(&quot;上传文件保存地址:&quot; + realPath); // 通过 CommonsMultipartFile 的方法直接写文件 file.transferTo(new File(realPath + &quot;/&quot; + file.getOriginalFilename())); return &quot;ok&quot;; } }","categories":[{"name":"生活","slug":"生活","permalink":"http://goodguyjameswin.github.io/categories/生活/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://goodguyjameswin.github.io/tags/学习笔记/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"http://goodguyjameswin.github.io/categories/生活/"}]},{"title":"yolov5-dota-obb","slug":"yolov5-dota-obb","date":"2022-05-10T02:19:20.000Z","updated":"2022-07-18T04:13:16.765Z","comments":false,"path":"2022/05/10/yolov5-dota-obb/","link":"","permalink":"http://goodguyjameswin.github.io/2022/05/10/yolov5-dota-obb/","excerpt":"","text":"简介最近出于项目需要，针对旋转目标检测的任务，做一个深度学习方案。浏览过程中看到一个国内大佬，针对yolov5做了修改，引入了长边表示法对旋转矩形检测框的定义，感觉效果还不错，标签的格式也比较好懂，准备上手尝试 好家伙，还是离不开DOTA_devkit的编译，今年四月份左右想入这个坑，就被windows上各种第三方库的编译给劝退了，然后发现旋转目标检测，基本都离不开对这个工具包的编译，因为旋转目标检测网络目前基本都是用DOTA数据集作benchmark，这个工具包可以很好的处理DOTA数据集 后来发现其实编译这个工具包，目的是调用其中有关多边形（旋转矩形框）做NMS（非极大值抑制）的方法，好说，我记得python有个shapely的库，也可以做多边形的IOU（重叠面积占比）运算。 挖坑踩坑这个工程，训练的时候跟原本的yolov5生态环境是一样的，方法调用不需要其他第三方库的支持，比如经典的mosaic数据增强，但是有几个坑 比如原作者的长边表示法是针对opencv4.2以前的版本中minAreaRect这一函数所返回的旋转矩形框所定义的角度做的优化，在高版本的opencv（比如opencv4.5以上）就不支持了。还有就是高版本的pytorch需要针对错误“torch.nn.modules.module.ModuleAttributeError: ‘Hardswish’ object has no attribute ‘inplace’”，找到pytorch的源码部分并做修改 def __init__(self, inplace : bool = False) -&gt; None: super(Hardwish, self).__init__() self.inplace = inplace def forward(self, input : Tensor) -&gt; Tensor: # 源码如下： # return F.hardwish(input, self.inplace) # 修改如下： return F.hardwish(input) 然后重点就是预测的时候，因为需要对经过网络前向推理后的结果（旋转矩形检测框）做NMS，这里需要调用DOTA_devkit工具包里编译好的iou_poly及poly_nms方法，用shapely库重写这一块 from shapely.geometry import Polygon, MultiPoint def iou_rotated_rect(line1, line2): a = np.array(line1).reshape(4, 2) poly1 = Polygon(a).convex_hull b = np.array(line2).reshape(4, 2) poly2 = Polygon(b).convex_hull union_poly = np.concatenate((a, b)) if not poly1.intersects(poly2): # if there is no intersection between two polygons iou = 0 else: inter_area = poly1.intersection(poly2).area # intersection area print(inter_area) union_area = MultiPoint(union_poly).convex_hull.area print(union_area) if union_area == 0: iou = 0 iou = float(inter_area) / union_area return iou def nms_rotated_rect(dets, scores, thresh): obbs = dets[:, 0:-1] x1 = np.min(obbs[:, 0::2], axis=1) y1 = np.min(obbs[:, 1::2], axis=1) x2 = np.max(obbs[:, 0::2], axis=1) y2 = np.max(obbs[:, 1::2], axis=1) areas = (x2 - x1 + 1) * (y2 - y1 + 1) polys = [] for i in range(len(dets)): tm_polygon = [dets[i][0], dets[i][1], dets[i][2], dets[i][3], dets[i][4], dets[i][5], dets[i][6], dets[i][7]] polys.append(tm_polygon) order = scores.argsort()[::-1] keep = [] while order.size &gt; 0: i = order[0] keep.append(i) xx1 = np.maximum(x1[i], x1[order[1:]]) yy1 = np.maximum(y1[i], y1[order[1:]]) xx2 = np.minimum(x2[i], x2[order[1:]]) yy2 = np.minimum(y2[i], y2[order[1:]]) w = np.maximum(0.0, xx2 - xx1) h = np.maximum(0.0, yy2 - yy1) hbb_inter = w * h hbb_ovr = hbb_inter / (areas[i] + areas[order[1:]] - hbb_inter) h_inds = np.where(hbb_ovr &gt; 0)[0] tmp_order = order[h_inds + 1] for j in range(tmp_order.size): iou = iou_rotated_rect(polys[i], polys[tmp_order[j]]) hbb_ovr[h_inds[j]] = iou inds = np.where(hbb_ovr &lt;= thresh)[0] order = order[inds + 1] return keep 然后去掉原工程下detect.py中数据后处理部分对DOTA_devkit工具包的依赖 def rotate_non_max_suppression(...): ... # 源码如下： # i = np.array(py_cpu_nms_poly_fast(np.array(rects), np.array(scores.cpu()), iou_thres)) # 修改如下： i = np.array(nms_rotated_rect(np.array(rects), np.array(scores.cpu()), iou_thres)) ... 修改完毕，用“纯净版”的YOLOv5_DOTA_OBB跑一下demo，发现模型可以正常预测，性能好像也没有损失 然后开始制作自己的数据集，训练并测试，这里我用的是以前用过的标注工具labelimg2 不过输出的格式是voc格式，所以我修改了下源码，让它能生成DOTA数据集格式的标签，在原工程的libs/labelFile.py里添加如下代码，会在当前目录下生成一个labels文件夹，里面存放对应标注图片的DOTA格式标签 label_dir = os.path.join(imgFolderPath, &quot;labels&quot;) if not os.path.exists(label_dir): os.makedirs(label_dir) label_file = os.path.join(label_dir, os.path.splitext(imgFileName)[0] + &#39;.txt&#39;) with open(label_file, &#39;w&#39;) as l: for shape in shapes: points = shape[&#39;points&#39;] label = shape[&#39;label&#39;] l.write(&#39; &#39;.join([str(points[0][0]), str(points[0][1]), str(points[1][0]), str(points[1][1]), str(points[2][0]), str(points[2][1]), str(points[3][0]), str(points[3][1]), label]) + &#39;\\n&#39;) 这里调用我自己修改的脚本，参考原项目，可以设置一下每张图片（标注好的）的增强次数，以及各类数据增强方法的参数 接着根据原作者提供的工具，将带DOTA格式标签的数据转换为“长边表示法”格式的标签数据 有了数据集，接下来就是训练调参了，一开始训练采用的原作者的默认配置，后来loss就是降不下来，测试效果也就肉眼可见的差，翻了翻评论区，结合自己的一点点对超参数的理解，修改hyp_scratch.yaml文件中各部分loss的权重，以及根据评论区原作者建议，调低了mosaic数据增强的启用概率，然后象征性地打开了mixup数据增强 由于原作者使用“长边表示法”表示旋转矩形框的算法具有局限性，标签在高版本opencv上无法成功从DOTA格式转换为longsideformat格式，宽高不等的图片无法作为数据正常送入网络进行训练，这是由于作者是先对图像宽高进行归一化之后再转换标签格式，然后在longsideformat格式下进行图片像素坐标的去归一化（会导致标签由旋转矩形框变成类平行四边形框），有一个好的解决方案是对图片归一化时，宽高都针对两者中的较大值作为归一化的分母做归一化，这样转换标签格式后，图片像素坐标去归一化的分母还是一样的，不会产生标签偏移，最好的解决办法是修改标签转换部分代码以及整个深度学习工程的像素坐标归一化与去归一化过程，但是这样修改起来工作量较大，且可行性得不到验证，因此目前仍建议采用宽高相等的图片作为训练数据 如果数据增强的时候，开启了多种增强方式（如旋转，平移，裁剪），建议训练的时候，将角度、box和置信度的loss权重调高，若不是做多分类，分类部分的loss权重可以调低，生成的训练数据集比较复杂的情况下，mosaic和mixup数据增强方式的启用概率可以适当调低，并且为了保证网络收敛，建议调高epochs，并且采用Adam优化算法 忙活了半天，终于训练出来一个还不错的效果了 640*640的图片，gpu单张预测时间在0.1s左右","categories":[{"name":"技术","slug":"技术","permalink":"http://goodguyjameswin.github.io/categories/技术/"}],"tags":[{"name":"开源项目","slug":"开源项目","permalink":"http://goodguyjameswin.github.io/tags/开源项目/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://goodguyjameswin.github.io/categories/技术/"}]},{"title":"rotated_data_maker","slug":"rotated-data-maker","date":"2022-05-08T13:30:45.000Z","updated":"2022-07-18T03:57:17.841Z","comments":false,"path":"2022/05/08/rotated-data-maker/","link":"","permalink":"http://goodguyjameswin.github.io/2022/05/08/rotated-data-maker/","excerpt":"","text":"简介一个用于数据增广的脚本，实验室的深度学习方案，针对性的真实数据永远都只有几张图，可是网络模型的性能本身就是建立在数据集的多样性上面，合成数据只能在一定程度上缓解数据量不足的问题，而且过度依赖合成数据容易导致模型过拟合，且无法从根本上提高模型的鲁棒性 用于生成可以训练多角度目标检测的网络的合成训练数据， 需要背景图和模板图 然后合成的图片大概长这个样子，也没打算再去做进一步的美化了 合成图片的过程中，将位置信息也记录下来，格式是DOTA数据集的标签样式 因为确实没什么实用性，写了一两天感觉也只是为了完成任务，细节的话，有兴趣可以看看这个贴图脚本","categories":[{"name":"技术","slug":"技术","permalink":"http://goodguyjameswin.github.io/categories/技术/"}],"tags":[{"name":"开源项目","slug":"开源项目","permalink":"http://goodguyjameswin.github.io/tags/开源项目/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://goodguyjameswin.github.io/categories/技术/"}]},{"title":"mybatis学习","slug":"mybatis学习","date":"2022-05-07T01:50:37.000Z","updated":"2022-07-18T03:42:28.720Z","comments":false,"path":"2022/05/07/mybatis学习/","link":"","permalink":"http://goodguyjameswin.github.io/2022/05/07/mybatis学习/","excerpt":"","text":"构建工程Mybatis中文文档 入门新建Maven父工程，导入依赖： &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.9&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.29&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Maven中静态资源过滤 --&gt; &lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt; 从xml文件中构建SqlSessionFactory： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt; &lt;configuration&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;${driver}&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;${url}&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;${username}&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;${password}&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=&quot;org/mybatis/example/BlogMapper.xml&quot;/&gt; &lt;/mappers&gt; &lt;/configuration&gt; 新建工具类： public class MabatisUtils() { private String resource; public MybatisUtils(String resouce) { this.resource = resource; } public static SqlSessionFactory getSqlSessionFactory() { InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); return sqlSessionFactory; } } 从xml文件中构建映射器（Mappers）： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; &lt;mapper namespace=&quot;org.mybatis.example.BlogMapper&quot;&gt; &lt;select id=&quot;selectBlog&quot; resultType=&quot;Blog&quot;&gt; select * from Blog where id = #{id} &lt;/select&gt; &lt;/mapper&gt; 或者使用注解： package org.mybatis.example; public interface BlogMapper { @Select(&quot;SELECT * FROM blog WHERE id = #{id}&quot;) Blog selectBlog(int id); } 新建测试类： import MybatisUtils; public class Test() { public static void main(String[] args) { SqlSessionFactory sqlSessionFactory = MybatisUtils.getSqlSessionFactory(); try (SqlSession session = sqlSessionFactory.openSession()) { BlogMapper mapper = session.getMapper(BlogMapper.class); Blog blog = mapper.selectBlog(101); } } } 结果映射&lt;resultMap id=&quot;userResultMap&quot; type=&quot;User&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;user_id&quot; /&gt; &lt;result property=&quot;username&quot; column=&quot;user_name&quot;/&gt; &lt;result property=&quot;password&quot; column=&quot;hashed_password&quot;/&gt; &lt;/resultMap&gt; &lt;select id=&quot;selectUsers&quot; resultMap=&quot;userResultMap&quot;&gt; select user_id, user_name, hashed_password from some_table where id = #{id} &lt;/select&gt; 关联（多对一） &lt;resultMap id=&quot;blogResult&quot; type=&quot;Blog&quot;&gt; &lt;association property=&quot;author&quot; column=&quot;author_id&quot; javaType=&quot;Author&quot; select=&quot;selectAuthor&quot;/&gt; &lt;/resultMap&gt; &lt;select id=&quot;selectBlog&quot; resultMap=&quot;blogResult&quot;&gt; SELECT * FROM BLOG WHERE ID = #{id} &lt;/select&gt; &lt;select id=&quot;selectAuthor&quot; resultType=&quot;Author&quot;&gt; SELECT * FROM AUTHOR WHERE ID = #{id} &lt;/select&gt; 集合（一对多） &lt;resultMap id=&quot;blogResult&quot; type=&quot;Blog&quot;&gt; &lt;collection property=&quot;posts&quot; javaType=&quot;ArrayList&quot; column=&quot;id&quot; ofType=&quot;Post&quot; select=&quot;selectPostsForBlog&quot;/&gt; &lt;/resultMap&gt; &lt;select id=&quot;selectBlog&quot; resultMap=&quot;blogResult&quot;&gt; SELECT * FROM BLOG WHERE ID = #{id} &lt;/select&gt; &lt;select id=&quot;selectPostsForBlog&quot; resultType=&quot;Post&quot;&gt; SELECT * FROM POST WHERE BLOG_ID = #{id} &lt;/select&gt; 动态SQL根据条件包含 where 子句的一部分，使用 if 标签： &lt;select id=&quot;findActiveBlogLike&quot; resultType=&quot;Blog&quot;&gt; SELECT * FROM BLOG WHERE state = ‘ACTIVE’ &lt;if test=&quot;title != null&quot;&gt; AND title like #{title} &lt;/if&gt; &lt;if test=&quot;author != null and author.name != null&quot;&gt; AND author_name like #{author.name} &lt;/if&gt; &lt;/select&gt; 从多个条件中选择一个，使用 choose、when、otherwise 标签： &lt;select id=&quot;findActiveBlogLike&quot; resultType=&quot;Blog&quot;&gt; SELECT * FROM BLOG WHERE state = ‘ACTIVE’ &lt;choose&gt; &lt;when test=&quot;title != null&quot;&gt; AND title like #{title} &lt;/when&gt; &lt;when test=&quot;author != null and author.name != null&quot;&gt; AND author_name like #{author.name} &lt;/when&gt; &lt;otherwise&gt; AND featured = 1 &lt;/otherwise&gt; &lt;/choose&gt; &lt;/select&gt; trim 用于定制元素的功能： &lt;select id=&quot;findActiveBlogLike&quot; resultType=&quot;Blog&quot;&gt; SELECT * FROM BLOG &lt;where&gt; &lt;if test=&quot;state != null&quot;&gt; state = #{state} &lt;/if&gt; &lt;if test=&quot;title != null&quot;&gt; AND title like #{title} &lt;/if&gt; &lt;if test=&quot;author != null and author.name != null&quot;&gt; AND author_name like #{author.name} &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; &lt;update id=&quot;updateAuthorIfNecessary&quot;&gt; update Author &lt;set&gt; &lt;if test=&quot;username != null&quot;&gt;username=#{username},&lt;/if&gt; &lt;if test=&quot;password != null&quot;&gt;password=#{password},&lt;/if&gt; &lt;if test=&quot;email != null&quot;&gt;email=#{email},&lt;/if&gt; &lt;if test=&quot;bio != null&quot;&gt;bio=#{bio}&lt;/if&gt; &lt;/set&gt; where id=#{id} &lt;/update&gt; &lt;trim prefix=&quot;WHERE&quot; prefixOverrides=&quot;AND |OR &quot;&gt; ... &lt;/trim&gt; &lt;trim prefix=&quot;SET&quot; suffixOverrides=&quot;,&quot;&gt; ... &lt;/trim&gt; 对集合进行遍历： &lt;select id=&quot;selectPostIn&quot; resultType=&quot;domain.blog.Post&quot;&gt; SELECT * FROM POST P &lt;where&gt; &lt;foreach item=&quot;item&quot; index=&quot;index&quot; collection=&quot;list&quot; open=&quot;ID in (&quot; separator=&quot;,&quot; close=&quot;)&quot; nullable=&quot;true&quot;&gt; #{item} &lt;/foreach&gt; &lt;/where&gt; &lt;/select&gt;","categories":[{"name":"生活","slug":"生活","permalink":"http://goodguyjameswin.github.io/categories/生活/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://goodguyjameswin.github.io/tags/学习笔记/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"http://goodguyjameswin.github.io/categories/生活/"}]},{"title":"yolact","slug":"yolact","date":"2022-05-05T03:34:57.000Z","updated":"2022-07-18T03:40:38.551Z","comments":false,"path":"2022/05/05/yolact/","link":"","permalink":"http://goodguyjameswin.github.io/2022/05/05/yolact/","excerpt":"","text":"简介奉老师之命，调试一个实例分割的网络，用来做缺陷检测，至于为什么用实例分割网络做缺陷检测，我也不清楚，反正他老人家的意思是要能够在c++那头部署，好让人家写界面封装。话不多说，开始做数据！ 踩坑挖坑盯上了一个可以用ncnn部署的实例分割网络yolact，先考虑能否使用opencv的dnn库进行网络的部署，参考项目，使用official版yolact工程里自带的训练.pth权重，先转换成.onnx格式。这里有一个坑，貌似低版本的opencv，会报错，安装高版本（如opencv4.5）可以解决权重转换报错。其次就是，训练时使用的pytorch，一定要和.pth权重文件转.onnx格式时使用的pytorch版本对应 然后在c++端进行推理，发现可以成功，300*300的demo图片cpu推理时间在700ms左右，坚定了调试yolact工程的决心 然后去踩yolact网络训练测试的坑，发现同样是opencv版本低带来的坑，读训练图片的时候会报错，升级一下opencv版本就好了 用labelme工具标注图片分割数据，产生的json格式标签，同样的用脚本扩充一下数据集，验证一下标签转换是否正确 然后把标注并且增广后的数据及json格式标签，转换为COCO格式数据集 def main(): parser = argparse.ArgumentParser( formatter_class=argparse.ArgumentDefaultsHelpFormatter ) parser.add_argument(&quot;input_dir&quot;, help=&quot;input annotated directory&quot;) parser.add_argument(&quot;output_dir&quot;, help=&quot;output dataset directory&quot;) parser.add_argument(&quot;--labels&quot;, help=&quot;labels file&quot;, required=True) parser.add_argument( &quot;--noviz&quot;, help=&quot;no visualization&quot;, action=&quot;store_true&quot; ) args = parser.parse_args() if osp.exists(args.output_dir): print(&quot;Output directory already exists:&quot;, args.output_dir) sys.exit(1) os.makedirs(args.output_dir) os.makedirs(osp.join(args.output_dir, os.path.basename(args.input_dir) + &quot;_JPEGImages&quot;)) if not args.noviz: os.makedirs(osp.join(args.output_dir, &quot;Visualization&quot;)) print(&quot;Creating dataset:&quot;, args.output_dir) now = datetime.datetime.now() data = dict( info=dict( description=None, url=None, version=None, year=now.year, contributor=None, date_created=now.strftime(&quot;%Y-%m-%d %H:%M:%S.%f&quot;), ), licenses=[dict(url=None, id=0, name=None,)], images=[ # license, url, file_name, height, width, date_captured, id ], type=&quot;instances&quot;, annotations=[ # segmentation, area, iscrowd, image_id, bbox, category_id, id ], categories=[ # supercategory, id, name ], ) class_name_to_id = {} for i, line in enumerate(open(args.labels).readlines()): class_id = i - 1 # starts with -1 class_name = line.strip() if class_id == -1: assert class_name == &quot;__ignore__&quot; continue class_name_to_id[class_name] = class_id data[&quot;categories&quot;].append( dict(supercategory=None, id=class_id, name=class_name,) ) out_ann_file = osp.join(args.output_dir, os.path.basename(args.input_dir) + &quot;.json&quot;) label_files = glob.glob(osp.join(args.input_dir, &quot;*.json&quot;)) for image_id, filename in enumerate(label_files): print(&quot;Generating dataset from:&quot;, filename) label_file = labelme.LabelFile(filename=filename) base = osp.splitext(osp.basename(filename))[0] out_img_file = osp.join(args.output_dir, os.path.basename(args.input_dir) + &quot;_JPEGImages&quot;, base + &quot;.jpg&quot;) img = labelme.utils.img_data_to_arr(label_file.imageData) imgviz.io.imsave(out_img_file, img) data[&quot;images&quot;].append( dict( license=0, url=None, file_name=osp.relpath(out_img_file, osp.dirname(out_ann_file)), height=img.shape[0], width=img.shape[1], date_captured=None, id=image_id, ) ) masks = {} # for area segmentations = collections.defaultdict(list) # for segmentation for shape in label_file.shapes: points = shape[&quot;points&quot;] label = shape[&quot;label&quot;] group_id = shape.get(&quot;group_id&quot;) shape_type = shape.get(&quot;shape_type&quot;, &quot;polygon&quot;) mask = labelme.utils.shape_to_mask( img.shape[:2], points, shape_type ) if group_id is None: group_id = uuid.uuid1() instance = (label, group_id) if instance in masks: masks[instance] = masks[instance] | mask else: masks[instance] = mask if shape_type == &quot;rectangle&quot;: (x1, y1), (x2, y2) = points x1, x2 = sorted([x1, x2]) y1, y2 = sorted([y1, y2]) points = [x1, y1, x2, y1, x2, y2, x1, y2] else: points = np.asarray(points).flatten().tolist() segmentations[instance].append(points) segmentations = dict(segmentations) for instance, mask in masks.items(): cls_name, group_id = instance if cls_name not in class_name_to_id: continue cls_id = class_name_to_id[cls_name] mask = np.asfortranarray(mask.astype(np.uint8)) mask = pycocotools.mask.encode(mask) area = float(pycocotools.mask.area(mask)) bbox = pycocotools.mask.toBbox(mask).flatten().tolist() data[&quot;annotations&quot;].append( dict( id=len(data[&quot;annotations&quot;]), image_id=image_id, category_id=cls_id, segmentation=segmentations[instance], area=area, bbox=bbox, iscrowd=0, ) ) if not args.noviz: labels, captions, masks = zip( *[ (class_name_to_id[cnm], cnm, msk) for (cnm, gid), msk in masks.items() if cnm in class_name_to_id ] ) viz = imgviz.instances2rgb( image=img, labels=labels, masks=masks, captions=captions, font_size=15, line_width=2, ) out_viz_file = osp.join( args.output_dir, &quot;Visualization&quot;, base + &quot;.jpg&quot; ) imgviz.io.imsave(out_viz_file, viz) with open(out_ann_file, &quot;w&quot;) as f: json.dump(data, f) 简单配置训练信息，开始训练！ 训练完毕，先在python这边测试一下效果，马马虎虎 然后关键是，能否在c++端部署并成功预测，这里又有一个坑，如果是训练自己的数据集，得到的.pth权重文件在转换.onnx文件时，需要保证网络结构部分读取张量的尺寸能对齐（一般来说是图片尺寸通道数或者训练测试类别数的不一致会导致报错） 训练的模型也比较简单，看了下中间过程的mask图，这边生成的分割图还是不够准确，对模型的训练效果要求还是比较高，貌似效果和python那边预测的有点差距，初步估计是网络前向推理后的数据后处理部分还是有区别吧，留个坑，以后有时间再填~","categories":[{"name":"技术","slug":"技术","permalink":"http://goodguyjameswin.github.io/categories/技术/"}],"tags":[{"name":"开源项目","slug":"开源项目","permalink":"http://goodguyjameswin.github.io/tags/开源项目/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://goodguyjameswin.github.io/categories/技术/"}]},{"title":"spring学习","slug":"spring学习","date":"2022-05-02T06:53:05.000Z","updated":"2022-07-18T03:42:15.132Z","comments":false,"path":"2022/05/02/spring学习/","link":"","permalink":"http://goodguyjameswin.github.io/2022/05/02/spring学习/","excerpt":"","text":"IOCxml配置方式开发创建maven父工程，删去冗余目录，导入依赖： &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.3.20&lt;/version&gt; &lt;/dependency&gt; 创建maven子工程，在src目录下新建实体类，resources目录下新建applicationContext.xml文件，注册实体类： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:c=&quot;http://www.springframework.org/schema/c&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!-- 无参构造 --&gt; &lt;!-- 默认为单例模式（singleton），而原型模式（prototype）指每次从容器中get的时候，都会产生一个新对象 --&gt; &lt;bean id=&quot;exampleBean&quot; class=&quot;examples.ExampleBean&quot; name=&quot;example1, example2,...&quot; scope=&quot;singleton, prototype&quot; autowire=&quot;byName, byType&quot;&gt; &lt;!-- 普通值注入 --&gt; &lt;property name=&quot;prop1&quot; value=&quot;1&quot;/&gt; &lt;!-- Bean注入 --&gt; &lt;property name=&quot;prop2&quot; ref=&quot;exampleBean2&quot;/&gt; &lt;!-- instead of using a reference to a target bean, simply define the target bean inline --&gt; &lt;property name=&quot;target&quot;&gt; &lt;bean class=&quot;com.example.Person&quot;&gt; &lt;!-- this is the inner bean --&gt; &lt;property name=&quot;name&quot; value=&quot;Fiona Apple&quot;/&gt; &lt;property name=&quot;age&quot; value=&quot;25&quot;/&gt; &lt;/bean&gt; &lt;/property&gt; &lt;!-- additional collaborators and configuration for this bean go here --&gt; &lt;/bean&gt; &lt;bean id=&quot;exampleBean2&quot; class=&quot;examples.ExampleBean2&quot;/&gt; &lt;!-- p命名空间注入，p指properties --&gt; &lt;bean name=&quot;john-modern&quot; class=&quot;com.example.Person&quot; p:name=&quot;John Doe&quot; p:spouse-ref=&quot;jane&quot;/&gt; &lt;!-- more bean definitions go here --&gt; &lt;!-- c命名空间注入，c指constructor-args --&gt; &lt;bean id=&quot;beanOne&quot; class=&quot;x.y.ThingOne&quot; c:thingTwo-ref=&quot;beanTwo&quot; c:thingThree-ref=&quot;beanThree&quot; c:email=&quot;something@somewhere.com&quot;/&gt; &lt;!-- 取别名 --&gt; &lt;alias name=&quot;exampleBean&quot; alias=&quot;aliasBean&quot;/&gt; &lt;!-- 导入多个配置文件 --&gt; &lt;import resource=&quot;beans1.xml&quot;/&gt; &lt;import resource=&quot;beans2.xml&quot;/&gt; &lt;/beans&gt; 对象交由 Spring 来创建，管理和装配，在配置文件加载的时候，容器中管理的对象就已经初始化了： // create and configure beans ApplicationContext context = new ClassPathXmlApplicationContext(&quot;services.xml&quot;, &quot;daos.xml&quot;); // retrieve configured instance PetStoreService service = context.getBean(&quot;petStore&quot;, PetStoreService.class); // use configured instance List&lt;String&gt; userList = service.getUsernameList(); 有参构造注入： &lt;!-- 有参构造 --&gt; &lt;!-- 参数名 --&gt; &lt;bean id=&quot;exampleBean&quot; class=&quot;examples.ExampleBean&quot;&gt; &lt;constructor-arg name=&quot;years&quot; value=&quot;7500000&quot;/&gt; &lt;constructor-arg name=&quot;ultimateAnswer&quot; value=&quot;42&quot;/&gt; &lt;/bean&gt; &lt;!-- 类型 --&gt; &lt;bean id=&quot;exampleBean&quot; class=&quot;examples.ExampleBean&quot;&gt; &lt;constructor-arg type=&quot;int&quot; value=&quot;7500000&quot;/&gt; &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;42&quot;/&gt; &lt;/bean&gt; &lt;!-- 下标索引 --&gt; &lt;bean id=&quot;exampleBean&quot; class=&quot;examples.ExampleBean&quot;&gt; &lt;constructor-arg index=&quot;0&quot; value=&quot;7500000&quot;/&gt; &lt;constructor-arg index=&quot;1&quot; value=&quot;42&quot;/&gt; &lt;/bean&gt; setter注入： &lt;bean id=&quot;moreComplexObject&quot; class=&quot;example.ComplexObject&quot;&gt; &lt;!-- results in a setAdminEmails(java.util.Properties) call --&gt; &lt;property name=&quot;adminEmails&quot;&gt; &lt;props&gt; &lt;prop key=&quot;administrator&quot;&gt;administrator@example.org&lt;/prop&gt; &lt;prop key=&quot;support&quot;&gt;support@example.org&lt;/prop&gt; &lt;prop key=&quot;development&quot;&gt;development@example.org&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;!-- results in a setSomeList(java.util.List) call --&gt; &lt;property name=&quot;someList&quot;&gt; &lt;list&gt; &lt;value&gt;a list element followed by a reference&lt;/value&gt; &lt;ref bean=&quot;myDataSource&quot; /&gt; &lt;/list&gt; &lt;/property&gt; &lt;!-- results in a setSomeMap(java.util.Map) call --&gt; &lt;property name=&quot;someMap&quot;&gt; &lt;map&gt; &lt;entry key=&quot;an entry&quot; value=&quot;just some string&quot;/&gt; &lt;entry key=&quot;a ref&quot; value-ref=&quot;myDataSource&quot;/&gt; &lt;/map&gt; &lt;/property&gt; &lt;!-- results in a setSomeSet(java.util.Set) call --&gt; &lt;property name=&quot;someSet&quot;&gt; &lt;set&gt; &lt;value&gt;just some string&lt;/value&gt; &lt;ref bean=&quot;myDataSource&quot; /&gt; &lt;/set&gt; &lt;/property&gt; &lt;property name=&quot;email&quot;&gt; &lt;null/&gt; &lt;/property&gt; &lt;/bean&gt; 注解方式开发修改applicationContext.xml配置文件： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!-- 开启注解驱动支持 --&gt; &lt;context:annotation-config/&gt; &lt;!-- 指定要扫描的包（全限定名），这个包下的注解就会生效 --&gt; &lt;context:component:scan base-package=&quot;...&quot;&gt; &lt;/beans&gt; @Autowired默认通过byType方式实现自动装配，参数required置为false与@Nullable效果相同，@Qualifier指定装配的bean，也可使用javax下的@Resource注解实现前两者的组合： public class MovieRecommender { private final CustomerPreferenceDao customerPreferenceDao; @Autowired(required = false) @Qualifier(&quot;...&quot;) private MovieCatalog movieCatalog; @Autowired public MovieRecommender(@Qualifier(&quot;...&quot;) CustomerPreferenceDao customerPreferenceDao) { this.customerPreferenceDao = customerPreferenceDao; } @Resource(name=&quot;...&quot;) public void setMovieCatalogs(Map&lt;String, MovieCatalog&gt; movieCatalogs) { this.movieCatalogs = movieCatalogs; } // ... } @Component（与@Repository、@Service和@Controller功能相同，后三者在springmvc中使用）将实体类注册到Spring中，@value注入简单参数： @Component @Scope(&quot;prototype&quot;) public class User{ public String name; @Value(&quot;...&quot;) public void setName(String name) { this.name = name; } } 通过JavaConfig方式实现（完全去掉applicationContext.xml配置文件），@Import导入其他配置类： // 配置类 @Configuration @ComponentScan(basePackages=&quot;...&quot;) @Import(...) public class AppConfig { // 等价于 &lt;bean id=&quot;myService&quot; class=&quot;com.acme.services.MyServiceImpl&quot;/&gt; @Bean public MyService myService() { return new MyServiceImpl(); } } // 测试类 public static void main(String[] args) { ApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class); MyService myService = ctx.getBean(MyService.class); myService.doStuff(); } AOP动态代理使用jdk反射库里的Proxy类和InvocationHandler类实现： public class ProxyInvocationHandler implements InvocationHandler { // 被代理的接口 private Object target; public void setTarget(Object target) { this.target = target}; // 生成得到代理类 public Object getProxy() { return Proxy.newProxyInstance(this.getClass().getClassLoader(), target.getClass().getInterfaces(), this); } // 处理代理实例，并返回结果： public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { log(method.getName()); Object result = method.invoke(target, args); return result; } public void log(String msg) { System.out.println(&quot;执行了&quot; + msg + &quot;方法&quot;); } } 原生 Spring API 接口和自定义类导入依赖： &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.8&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; 切入点（PoingCut）是通知执行的“地点”的定义；通知（Advice）指切面必须要完成的工作，它是类中的一个方法： public interface MethodBeforeAdvice extends BeforeAdvice { void before(Method m, Object[] args, Object target) throws Throwable; } public class CountingBeforeAdvice implements MethodBeforeAdvice { private int count; public void before(Method m, Object[] args, Object target) throws Throwable { ++count; } public int getCount() { return count; } } 切面（Aspect）指横切关注点被模块化的特殊对象，它是一个类： public class ConcurrentOperationExecutor implements Ordered { private static final int DEFAULT_MAX_RETRIES = 2; private int maxRetries = DEFAULT_MAX_RETRIES; private int order = 1; public void setMaxRetries(int maxRetries) { this.maxRetries = maxRetries; } public int getOrder() { return this.order; } public void setOrder(int order) { this.order = order; } public Object doConcurrentOperation(ProceedingJoinPoint pjp) throws Throwable { int numAttempts = 0; PessimisticLockingFailureException lockFailureException; do { numAttempts++; try { return pjp.proceed(); } catch(PessimisticLockingFailureException ex) { lockFailureException = ex; } } while(numAttempts &lt;= this.maxRetries); throw lockFailureException; } } 注解实现AOP： import org.aspectj.lang.annotation.Aspect; import org.aspectj.lang.annotation.Before; @Aspect public class BeforeExample { @Before(&quot;com.xyz.myapp.CommonPointcuts.dataAccessOperation()&quot;) public void doAccessCheck() { // ... } @Around(&quot;com.xyz.myapp.CommonPointcuts.businessService()&quot;) public Object doBasicProfiling(ProceedingJoinPoint pjp) throws Throwable { // start stopwatch Object retVal = pjp.proceed(); // stop stopwatch return retVal; } } resoureces下新建配置文件applicationContext.xml： &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;!-- 方式一：使用原生 Spring API 接口 --&gt; &lt;!-- this is the object that will be proxied by Spring&#39;s AOP infrastructure --&gt; &lt;bean id=&quot;personService&quot; class=&quot;x.y.service.DefaultPersonService&quot;/&gt; &lt;!-- this is the actual advice itself --&gt; &lt;bean id=&quot;beforeAdvice&quot; class=&quot;x.y.CountingBeforeAdvice&quot;/&gt; &lt;aop:config&gt; &lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* x.y.service.DefaultPersonService.*(..))&quot;/&gt; &lt;!-- 增加执行环绕 --&gt; &lt;aop:advisor advice-ref=&quot;beforeAdvice&quot; pointcut-ref=&quot;pointcut&quot;&gt; &lt;/aop:config&gt; &lt;!-- 方式二：自定义类（切面） --&gt; &lt;aop:config&gt; &lt;aop:aspect id=&quot;concurrentOperationRetry&quot; ref=&quot;concurrentOperationExecutor&quot;&gt; &lt;aop:pointcut id=&quot;idempotentOperation&quot; expression=&quot;execution(* com.xyz.myapp.service.*.*(..))&quot;/&gt; &lt;aop:around pointcut-ref=&quot;idempotentOperation&quot; method=&quot;doConcurrentOperation&quot;/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; &lt;bean id=&quot;concurrentOperationExecutor&quot; class=&quot;com.xyz.myapp.service.impl.ConcurrentOperationExecutor&quot;&gt; &lt;property name=&quot;maxRetries&quot; value=&quot;3&quot;/&gt; &lt;property name=&quot;order&quot; value=&quot;100&quot;/&gt; &lt;/bean&gt; &lt;!-- 方式三：注解 --&gt; &lt;bean id=&quot;BeforeExample&quot; class=&quot;x.y.BeforeExample&quot;/&gt; &lt;!-- 开启注解支持 JDK（默认 proxy-target-class=&quot;false&quot;，cglib（proxy-target-class=&quot;true&quot;））--&gt; &lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot;/&gt; &lt;/beans&gt; 整合MybatisMybatis-Spring中文文档 导入依赖： &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.3.20&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.7&lt;/version&gt; &lt;/dependency&gt; 新建applicationContext.xml配置文件： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx https://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt; &lt;!-- 使用Spring-JDBC提供的数据源 --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;!-- 绑定Mybatis配置文件 --&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt; &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath*:sample/config/mappers/**/*.xml&quot; /&gt; &lt;/bean&gt; &lt;!-- 方式一：SqlSessionTemplate --&gt; &lt;!-- SqlSessionTemplate 对应 SqlSession --&gt; &lt;bean id=&quot;sqlSession&quot; class=&quot;org.mybatis.spring.SqlSessionTemplate&quot;&gt; &lt;!-- 只能使用构造器注入sqlSessionFactory，因为它没有set方法 --&gt; &lt;constructor-arg index=&quot;0&quot; ref=&quot;sqlSessionFactory&quot; /&gt; &lt;/bean&gt; &lt;!-- 注入到DAO bean中 --&gt; &lt;bean id=&quot;userDao&quot; class=&quot;org.mybatis.spring.sample.dao.UserDaoImpl&quot;&gt; &lt;property name=&quot;sqlSession&quot; ref=&quot;sqlSession&quot; /&gt; &lt;/bean&gt; &lt;!-- 方式二：SqlSessionDaoSupport --&gt; &lt;bean id=&quot;userDao&quot; class=&quot;org.mybatis.spring.sample.dao.UserDaoImpl&quot;&gt; &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot; /&gt; &lt;/bean&gt; &lt;!-- 方式三：配置 Dao 接口扫描包，动态实现 Dao 接口注入到 Spring 容器中 --&gt; &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;!-- 注入 sqlSessionFactory --&gt; &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;/&gt; &lt;!-- 要扫描的 Dao 包 --&gt; &lt;property name=&quot;basePackage&quot; value=&quot;org.mybatis.spring.sample.dao&quot;/&gt; &lt;/bean&gt; &lt;!-- 配置声明式事务 --&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;constructor-arg ref=&quot;dataSource&quot; /&gt; &lt;/bean&gt; &lt;!-- 配置事务通知 --&gt; &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt; &lt;!-- 给哪些方法配置事务，配置事务的传播特性 --&gt; &lt;tx:attributes&gt; &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!-- 配置事务织入 --&gt; &lt;aop:config&gt; &lt;aop:pointcut id=&quot;txPointCut&quot; expression=&quot;execution(* x.y.service.DefaultPersonService.*(..))&quot;/&gt; &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;txPointCut&quot;&gt; &lt;/aop:config&gt; &lt;/beans&gt; 新建Dao层实现类： // 方式一 public class UserDaoImpl implements UserDao { private SqlSession sqlSession; public void setSqlSession(SqlSession sqlSession) { this.sqlSession = sqlSession; } public User getUser(String userId) { return sqlSession.selectOne(&quot;org.mybatis.spring.sample.mapper.UserMapper.getUser&quot;, userId); } } // 方式二 public class UserDaoImpl extends SqlSessionDaoSupport implements UserDao { public User getUser(String userId) { return getSqlSession().selectOne(&quot;org.mybatis.spring.sample.mapper.UserMapper.getUser&quot;, userId); } } 新建测试类： public class MyTest { @Test public void test() throws IOException { ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); UserMapper userMapper = context.getBean(&quot;userDao&quot;, UserDao.class); System.out.println(userMapper.selectUser(0)); } }","categories":[{"name":"生活","slug":"生活","permalink":"http://goodguyjameswin.github.io/categories/生活/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://goodguyjameswin.github.io/tags/学习笔记/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"http://goodguyjameswin.github.io/categories/生活/"}]},{"title":"栈与队列","slug":"栈与队列","date":"2022-04-30T10:43:49.000Z","updated":"2022-07-18T03:44:24.551Z","comments":false,"path":"2022/04/30/栈与队列/","link":"","permalink":"http://goodguyjameswin.github.io/2022/04/30/栈与队列/","excerpt":"","text":"动态数组底层仍是数组实现，添加和删除元素的时候，为了维护其他元素的相对顺序，需要将一系列元素进行平行复制，当数组元素满了的时候，需要动态扩容，就是申请一块更大的内存空间，然后把原来的数组元素依次赋值到新的内存空间，才能继续添加元素。也可以做动态缩容，不过为了避免造成数组由于添加删除元素的缘故反复扩容缩容，引起复杂度震荡，可以当数组的真正存放数据的区域减少到数组长度的1/4的时候，才缩减数组的容量，缩减到原来的1/2。 /** * 动态数组，参考了 java.util.ArrayList 类的实现 * * @param &lt;E&gt; */ public class ArrayList&lt;E&gt; { private E[] data; private int size; /** * 构造函数，传入数组的初始化容量 capacity 构造动态数组 * * @param capacity */ public ArrayList(int capacity) { data = (E[]) new Object[capacity]; size = 0; } /** * 无参数的构造函数，默认数组的容量 capacity = 10 */ public ArrayList() { this(10); } /** * 获取数组真正的容量 * * @return */ public int getCapacity() { return data.length; } /** * 获取数组中的元素个数 * * @return */ public int size() { return size; } /** * 返回数组是否为空 * * @return */ public boolean isEmpty() { return size == 0; } /** * 在下标 index 位置插入一个新元素 e * * @param index * @param e */ public void add(int index, E e) { if (index &lt; 0 || index &gt; size) { throw new IndexOutOfBoundsException(String.format(&quot;Index %s out of bounds for length %s&quot;, index, size)); } if (size == data.length) { newCapacity(2 * data.length); } // 插入元素的时候，从后向前逐个向后赋值，留出空位 for (int i = size - 1; i &gt;= index; i--) { data[i + 1] = data[i]; } data[index] = e; size++; } /** * 向所有元素后添加一个新元素 * * @param e */ public void add(E e) { add(size, e); } /** * 获取下标 index 位置的元素 * * @param index * @return */ public E get(int index) { if (index &lt; 0 || index &gt;= size) { throw new IndexOutOfBoundsException(String.format(&quot;Index %s out of bounds for length %s&quot;, index, size)); } return data[index]; } /** * 修改下标 index 位置的元素为 e * * @param index * @param e */ public void set(int index, E e) { if (index &lt; 0 || index &gt;= size) { throw new IllegalArgumentException(&quot;Set failed. Index is illegal.&quot;); } data[index] = e; } /** * 查找数组中是否有元素 e * * @param e * @return */ public boolean contains(E e) { for (int i = 0; i &lt; size; i++) { if (data[i].equals(e)) { return true; } } return false; } /** * 查找数组中元素 e 所在的下标，如果不存在元素e，则返回-1 * * @param e * @return */ public int indexOf(E e) { for (int i = 0; i &lt; size; i++) { if (data[i].equals(e)) { return i; } } return -1; } /** * 注意：该方法下有缩容机制 * * @param index 被删除的元素的下标 * @return 删除的元素 */ public E remove(int index) { if (index &lt; 0 || index &gt;= size) { throw new IllegalArgumentException(&quot;Remove failed. Index is illegal.&quot;); } E ret = data[index]; for (int i = index + 1; i &lt; size; i++) { data[i - 1] = data[i]; } size--; data[size] = null; // 防止复杂度震荡机制，当真正存放的元素的个数成为数组长度的 1 / 4 时，才缩容为原来的 1 / 2 if (size == data.length / 4 &amp;&amp; data.length != 1) { newCapacity(data.length / 2); } return ret; } /** * 从数组中删除元素e * * @param e */ public void removeElement(E e) { int index = indexOf(e); if (index != -1) { remove(index); } } @Override public String toString() { StringBuilder res = new StringBuilder(); res.append(String.format(&quot;数组的长度: size = %d , 容量 = %d\\n&quot;, size, data.length)); res.append(&#39;[&#39;); for (int i = 0; i &lt; size; i++) { res.append(data[i]); if (i != size - 1) { res.append(&quot;, &quot;); } } res.append(&#39;]&#39;); return res.toString(); } /** * 将数组空间的容量变成 capacity大小 * * @param capacity */ private void newCapacity(int capacity) { E[] newData = (E[]) new Object[capacity]; if (size &gt;= 0) { System.arraycopy(data, 0, newData, 0, size); } // 原来的数组 data 内存等待垃圾回收机制 data = newData; } } 栈后进先出的数据结构，可以用java.util.ArrayDeque实现，因为它底层是数组实现的，所以建议添加和删除元素都在ArrayDeque的末尾进行；或者使用java.util.LinkedList实现，链表则可以通过虚拟的头结点很方便地在链表的头部和尾部删除元素。 力扣316：给你一个字符串s，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证返回结果的字典序最小（要求不能打乱其他字符的相对位置）。 输入：s = “cbacdcbc” 输出：”acdb” 查看解析 public class Solution { public String removeDuplicateLetters(String s) { int len = s.length(); if (len &lt; 2) { return s; } char[] charArray = s.toCharArray(); // 记录每个字符出现的最后一个位置 int[] lastIndex = new int[26]; for (int i = 0; i &lt; len; i++) { lastIndex[charArray[i] - &#39;a&#39;] = i; } Deque&lt;Character&gt; stack = new ArrayDeque&lt;&gt;(len); stack.addLast(&#39;a&#39;); // 在栈里放一个永远不会被弹出的元素（哨兵），可以省去栈非空的判断， // 栈中有的字符记录在这里 boolean[] visited = new boolean[26]; for (int i = 0; i &lt; len; i++) { char currentChar = charArray[i]; // 如果栈中已经存在，就跳过 if (visited[currentChar - &#39;a&#39;]) { continue; } // 在 ① 栈非空，② 当前元素字典序 &lt; 栈顶元素，并且 ③ 栈顶元素在以后还会出现，弹出栈顶元素 while (currentChar &lt; stack.peekLast() &amp;&amp; lastIndex[stack.peekLast() - &#39;a&#39;] &gt; i) { char top = stack.removeLast(); visited[top - &#39;a&#39;] = false; } stack.addLast(currentChar); visited[currentChar - &#39;a&#39;] = true; } StringBuilder stringBuilder = new StringBuilder(); // 注意：弹出 size - 1 个元素，无需把哨兵元素弹出 int size = stack.size(); for (int i = 0; i &lt; size - 1; i++) { stringBuilder.insert(0, stack.removeLast()); } return stringBuilder.toString(); } } 单调栈单调栈就是普通的栈，只是在解决一些特定问题的过程中，栈中的元素在数值上恰好保持单调性。 经典问题，力扣42：接雨水 单调栈解法如下： public class Solution { public int trap(int[] height) { int len = height.length; if (len &lt; 3) { // 特判 return 0; } int area = 0; Deque&lt;Integer&gt; stack = new ArrayDeque&lt;&gt;(len); for (int i = 0; i &lt; len; i++) { while (!stack.isEmpty() &amp;&amp; height[stack.peekLast()] &lt; height[i]) { // 作为底部支撑的那个柱形的下标 Integer bottomIndex = stack.removeLast(); // 出栈以后，如果栈为空，说明不能形成凹槽，此时跳过即可 if (stack.isEmpty()) { break; } int width = i - stack.peekLast() - 1; // 根据木桶原理，高度取决于，i 的高度和弹栈以后的新栈顶元素的高度 int currentHeight = Math.min(height[stack.peekLast()], height[i]) - height[bottomIndex]; area += (width * currentHeight); } // 栈中存下标 stack.addLast(i); } return area; } } 力扣84：给定n个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为1。求在该柱状图中，能够勾勒出来的矩形的最大面积。 输入：heights = [2,1,5,6,2,3] 输出：10 解释：最大的矩形为图中红色区域，面积为 10 查看解析 class Solution { public int largestRectangleArea(int[] heights) { int n = heights.length; int[] left = new int[n]; int[] right = new int[n]; // 在遍历结束后，栈中仍然有一些位置，这些位置对应的右边界就是位置为 n 的「哨兵」。我们可以将它们依次出栈并更新右边界，也可以在初始化右边界数组时就将所有的元素的值置为 n Arrays.fill(right, n); Deque&lt;Integer&gt; mono_stack = new ArrayDeque&lt;Integer&gt;(); for (int i = 0; i &lt; n; ++i) { while (!mono_stack.isEmpty() &amp;&amp; heights[mono_stack.peek()] &gt;= heights[i]) { // 确实无法求出正确的右边界，但对最终的答案没有任何影响。这是因为在答案对应的矩形中，如果有若干个柱子的高度都等于矩形的高度，那么最右侧的那根柱子是可以求出正确的右边界的（因此最终的答案还是可以从最右侧的与矩形高度相同的柱子求得的） right[mono_stack.peek()] = i; mono_stack.pop(); } left[i] = (mono_stack.isEmpty() ? -1 : mono_stack.peek()); // 左边界可以正确求出，-1 表示左边界的「哨兵」 mono_stack.push(i); } int ans = 0; for (int i = 0; i &lt; n; ++i) { ans = Math.max(ans, (right[i] - left[i] - 1) * heights[i]); } return ans; } } 队列先进先出的数据结构，可以用数组或链表实现，例如java.util.concurrent.ArrayBlockingQueue就是由数组支持的有界队列，由于数组扩容有性能消耗，因此它不支持扩容，当队列满的时候，它的处理策略是阻塞。一些场合，我们希望在队列的两端都可以进行出队和入队的操作，这种更灵活的数据结构称为双端队列。 经典问题，用栈实现队列：设计用两个栈实现，一个栈用于元素进栈，一个栈用于元素出栈。为保证出队顺序，一定要在元素出栈的栈为空时，才从用于元素进栈的栈中将所有元素倒入用于元素出栈的栈 public class MyQueue { private Deque&lt;Integer&gt; pushStack; private Deque&lt;Integer&gt; popStack; /** * Initialize your data structure here. */ public MyQueue() { pushStack = new ArrayDeque&lt;&gt;(); popStack = new ArrayDeque&lt;&gt;(); } /** * Push element x to the back of queue. */ public void push(int x) { // 在任何时候都可以向 pushStack 推入元素 pushStack.addLast(x); } /** * Removes the element from in front of queue and returns that element. */ public int pop() { // 从 popStack 取出元素 if (!popStack.isEmpty()) { return popStack.removeLast(); } // 走到这里是因为 popStack 为空，此时需要将 pushStack 里的所有元素依次放入 popStack while (!pushStack.isEmpty()) { popStack.addLast(pushStack.removeLast()); } return popStack.removeLast(); } /** * Get the front element. */ public int peek() { // 从 popStack 取出元素 if (!popStack.isEmpty()) { return popStack.peekLast(); } // 走到这里是因为 popStack 为空，此时需要将 pushStack 里的所有元素依次放入 popStack while (!pushStack.isEmpty()) { popStack.addLast(pushStack.removeLast()); } return popStack.peekLast(); } /** * Returns whether the queue is empty. */ public boolean empty() { // 两个栈都为空，才说明队列为空 return pushStack.isEmpty() &amp;&amp; popStack.isEmpty(); } } /** * Your MyQueue object will be instantiated and called as such: * MyQueue obj = new MyQueue(); * obj.push(x); * int param_2 = obj.pop(); * int param_3 = obj.peek(); * boolean param_4 = obj.empty(); */ 经典问题，用队列实现栈：思路是在peek()和pop()的时候，依次将队首出队到队尾： public class MyStack { private Queue&lt;Integer&gt; queue; /** * Initialize your data structure here. */ public MyStack() { queue = new LinkedList&lt;&gt;(); } /** * Push element x onto stack. */ public void push(int x) { queue.add(x); } /** * Removes the element on top of the stack and returns that element. */ public int pop() { int size = queue.size(); for (int i = 0; i &lt; size - 1; i++) { queue.add(queue.poll()); } return queue.poll(); // 获取队尾元素（新队首），满足后进先出 } /** * Get the top element. */ public int top() { int size = queue.size(); for (int i = 0; i &lt; size - 1; i++) { queue.add(queue.poll()); } int res = queue.poll(); queue.add(res); // 为保证下次元素入队顺序的正确性，得到队尾元素之后，要继续将队首元素（旧队尾）移动到队尾 return res; } /** * Returns whether the stack is empty. */ public boolean empty() { return queue.isEmpty(); } } /** * Your MyStack object will be instantiated and called as such: * MyStack obj = new MyStack(); * obj.push(x); * int param_2 = obj.pop(); * int param_3 = obj.top(); * boolean param_4 = obj.empty(); */ 思考题：如何设计一个能在常数时间内检索到最小元素的栈？ 查看解析 class MinStack { Deque&lt;Integer&gt; xStack; Deque&lt;Integer&gt; minStack; // 辅助栈 public MinStack() { xStack = new LinkedList&lt;Integer&gt;(); minStack = new LinkedList&lt;Integer&gt;(); minStack.push(Integer.MAX_VALUE); } public void push(int x) { xStack.push(x); minStack.push(Math.min(minStack.peek(), x)); // 每个入栈的元素都有一个对应当时栈（状态）中的一个最小值 } public void pop() { xStack.pop(); minStack.pop(); // 辅助栈的栈顶元素也一并弹出 } public int top() { return xStack.peek(); } public int getMin() { return minStack.peek(); // 当前栈内元素的最小值总是辅助栈的栈顶元素 } } 经典问题，设计循环队列：依旧是队列的数据结构，但是队尾被连接在队首之后以形成一个环，特点是可以利用这个队列之前用过的空间。 public class MyCircularQueue { private int[] arr; private int capacity; /** * front 指向当前队列中最早入队的元素 */ private int front; /** * rear 指向下一个添加到队尾的元素 */ private int rear; /** * Initialize your data structure here. Set the size of the queue to be k. */ public MyCircularQueue(int k) { // 始终保持 1 个位置不存有效元素，是为了避免判断队列为空和队列为满的条件冲突 capacity = k + 1; arr = new int[capacity]; front = 0; rear = 0; } /** * Insert an element into the circular queue. Return true if the operation is successful. */ public boolean enQueue(int value) { // 队尾为满不可以入队 if (isFull()) { return false; } arr[rear] = value; rear = (rear + 1) % capacity; return true; } /** * Delete an element from the circular queue. Return true if the operation is successful. */ public boolean deQueue() { // 队尾为空不可以出队 if (isEmpty()) { return false; } front = (front + 1) % capacity; return true; } /** * Get the front item from the queue. */ public int Front() { // 队列非空才可以取出队头 if (isEmpty()) { return -1; } return arr[front]; } /** * Get the last item from the queue. */ public int Rear() { // 队列非空才可以取出队尾 if (isEmpty()) { return -1; } // 有数组下标的计算一定要考虑是否越界 return arr[(rear - 1 + capacity) % capacity]; } /** * Checks whether the circular queue is empty or not. */ public boolean isEmpty() { return front == rear; } /** * Checks whether the circular queue is full or not. */ public boolean isFull() { // 有数组下标的计算一定要考虑是否越界 return (rear + 1) % capacity == front; } } 若设计循环双端队列，则需要添加两个方法： /** * Adds an item at the front of Deque. Return true if the operation is successful. */ public boolean insertFront(int value) { if (isFull()) { return false; } front = (front - 1 + capacity) % capacity; // 由于 front 指向第一个队首元素，因此需要先将 front 左移一个单位，然后再赋值，要避免数组下标越界和处理循环 arr[front] = value; return true; } /** * Deletes an item from the rear of Deque. Return true if the operation is successful. */ public boolean deleteLast() { if (isEmpty()) { return false; } rear = (rear - 1 + capacity) % capacity; // 由于 rear 指向 队尾元素的下一个元素，因此需要将 rear 左移一个单位即可，同样要避免数组下标越界和处理循环 return true; } 单调队列同样只是普通的队列，只不过在使用队列的过程中，根据问题的特点保持了队列的单调性。 力扣239：给定一个数组nums，有一个大小为k的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的k个数字。滑动窗口每次只向右移动一位。返回滑动窗口中的最大值。 输入：nums = [1,3,-1,-3,5,3,6,7], k = 3 输出：[3,3,5,5,6,7] 解释： 滑动窗口的位置 最大值 ============= [1 3 -1] -3 5 3 6 7 (3) 1 [3 -1 -3] 5 3 6 7 (3) 1 3 [-1 -3 5] 3 6 7 (5) 1 3 -1 [-3 5 3] 6 7 (5) 1 3 -1 -3 [5 3 6] 7 (6) 1 3 -1 -3 5 [3 6 7] (7) 查看解析 分析题意，需要使用双端队列来实现，整个队列的数值（不是下标）呈现的特征是单调不减的，因此是一个单调队列： 删除队首信息：当滑窗离开左边界的时候，当前最大值需要被删除，这一步需要准确知道队首的下标，因此队列中存的是下标 查看队首信息：队首元素一定是当前滑动窗口的最大值 队尾添加：如果一个数有可能是将来的滑动窗口的最大值，就把它添加到队尾 队尾删除：如果新来的数比当前队尾的数还要大，当前队尾元素一定不可能是滑动窗口的最大值，需要把当前队尾删除，这个过程是循环进行的 public class Solution { public int[] maxSlidingWindow(int[] nums, int k) { int len = nums.length; int[] res = new int[len - k + 1]; // 注意结果集长度 Deque&lt;Integer&gt; deque = new ArrayDeque&lt;&gt;(k); // 双端队列实现的滑动窗口 for (int i = 0; i &lt; len; i++) { // 判断队首元素是否移出滑动窗口 if (i &gt;= k &amp;&amp; deque.peekFirst() == i - k) { deque.removeFirst(); } // 依次判断待添加元素是否比队首元素大，注意可以取等号 while (!deque.isEmpty() &amp;&amp; nums[deque.peekLast()] &lt;= nums[i]) { deque.removeLast(); } // 加入队列的是下标 deque.addLast(i); if (i &gt;= k - 1) { res[i - k + 1] = nums[deque.peekFirst()]; // 队首元素总是对内最大值 } } return res; } } .center { width: auto; display: table; margin-left: auto; margin-right: auto; }","categories":[{"name":"生活","slug":"生活","permalink":"http://goodguyjameswin.github.io/categories/生活/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://goodguyjameswin.github.io/tags/学习笔记/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"http://goodguyjameswin.github.io/categories/生活/"}]},{"title":"链表","slug":"链表","date":"2022-04-28T10:43:57.000Z","updated":"2022-07-19T12:48:36.672Z","comments":false,"path":"2022/04/28/链表/","link":"","permalink":"http://goodguyjameswin.github.io/2022/04/28/链表/","excerpt":"","text":"解决链表中的指针指向问题力扣25：给你链表的头节点head，每k个节点一组进行翻转，请你返回修改后的链表。k是一个正整数，它的值小于或等于链表的长度。如果节点总数不是k的整数倍，那么请将最后剩余的节点保持原有顺序。 你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。 输入：head = [1,2,3,4,5], k = 2 输出：[2,1,4,3,5] 查看解析 class Solution { public ListNode reverseKGroup(ListNode head, int k) { ListNode hair = new ListNode(0); hair.next = head; ListNode pre = hair; while (head != null) { ListNode tail = pre; // 查看剩余部分长度是否大于等于 k for (int i = 0; i &lt; k; ++i) { tail = tail.next; if (tail == null) { return hair.next; } } ListNode nex = tail.next; ListNode[] reverse = myReverse(head, tail); head = reverse[0]; tail = reverse[1]; // 把子链表重新接回原链表 pre.next = head; tail.next = nex; pre = tail; head = tail.next; } return hair.next; } public ListNode[] myReverse(ListNode head, ListNode tail) { ListNode prev = tail.next; ListNode p = head; while (prev != tail) { ListNode nex = p.next; p.next = prev; prev = p; p = nex; } return new ListNode[]{tail, head}; } } 力扣234：给你一个单链表的头节点head，请你判断该链表是否为回文链表。如果是，返回true；否则，返回false。你必须以O(n)时间复杂度和O(1)空间复杂度解决此题。 输入：head = [1,2,2,1] 输出：true 查看解析 // 快指针走到末尾，慢指针刚好到中间。其中慢指针将前半部分反转，然后比较。 public boolean isPalindrome(ListNode head) { if(head == null || head.next == null) { return true; } ListNode slow = head, fast = head; ListNode pre = head, prepre = null; while(fast != null &amp;&amp; fast.next != null) { pre = slow; slow = slow.next; fast = fast.next.next; pre.next = prepre; prepre = pre; } if(fast != null) { slow = slow.next; } while(pre != null &amp;&amp; slow != null) { if(pre.val != slow.val) { return false; } pre = pre.next; slow = slow.next; } return true; } 虚拟头结点力扣23：给你一个链表数组，每个链表都已经按升序排列。请你将所有链表合并到一个升序链表中，返回合并后的链表。 输入：lists = [[1,4,5],[1,3,4],[2,6]] 输出：[1,1,2,3,4,4,5,6] 查看解析 方法一：分治合并 class Solution { public ListNode mergeKLists(ListNode[] lists) { return merge(lists, 0, lists.length - 1); } public ListNode merge(ListNode[] lists, int l, int r) { if (l == r) { return lists[l]; } if (l &gt; r) { return null; } int mid = (l + r) &gt;&gt; 1; return mergeTwoLists(merge(lists, l, mid), merge(lists, mid + 1, r)); } public ListNode mergeTwoLists(ListNode a, ListNode b) { if (a == null || b == null) { return a != null ? a : b; } ListNode head = new ListNode(0); ListNode tail = head, aPtr = a, bPtr = b; while (aPtr != null &amp;&amp; bPtr != null) { if (aPtr.val &lt; bPtr.val) { tail.next = aPtr; aPtr = aPtr.next; } else { tail.next = bPtr; bPtr = bPtr.next; } tail = tail.next; } tail.next = (aPtr != null ? aPtr : bPtr); return head.next; } } 方法二：优先队列 class Solution { PriorityQueue&lt;ListNode&gt; queue = new PriorityQueue&lt;ListNode&gt;((l1, l2) -&gt; l1.val - l2.val); public ListNode mergeKLists(ListNode[] lists) { for (ListNode node: lists) { if (node != null) { queue.offer(node); } } ListNode head = new ListNode(0); ListNode tail = head; while (!queue.isEmpty()) { // 这里选择的操作是先从优先队列里拿出最小的元素，然后再添加，事实上 // 如果优先队列有提供 replace 操作，应该优先选择 replace（替换堆顶元素） ListNode node = queue.poll(); tail.next = node; tail = tail.next; if (node.next != null) { queue.offer(node.next); } } return head.next; } } 力扣86：给你一个链表的头节点head和一个特定值x，请你对链表进行分隔，使得所有小于x的节点都出现在大于或等于x的节点之前。你应当保留两个分区中每个结点的初始相对位置。 输入：head = [1,4,3,2,5,2], x = 3 输出：[1,2,2,4,3,5] 查看解析 class Solution { public ListNode partition(ListNode head, int x) { ListNode small = new ListNode(0); ListNode smallHead = small; ListNode large = new ListNode(0); ListNode largeHead = large; while (head != null) { if (head.val &lt; x) { small.next = head; small = small.next; } else { large.next = head; large = large.next; } head = head.next; } large.next = null; small.next = largeHead.next; return smallHead.next; } } 快慢指针指在链表遍历的过程中，使用两个指针变量同向移动的一种解决问题的技巧，需要注意一下快指针可以前进的条件： 如果快指针以及快指针的下一个结点非空，来到的是中间结点的前一个结点 如果快指针的下一个结点以及快指针的下一个结点的下一个结点非空，来到的是中间结点的后一个结点 环形链表经典问题：编写一个程序，检测一个单链表是否有环。 通常可以用快慢指针的思路，只要进入环，可以认为是快指针在追赶慢指针，它们相遇，肯定是由于快指针从慢指针的后面赶超了慢指针 public class Solution { public boolean hasCycle(ListNode head) { // 特判 if (head == null || head.next == null) { return false; } ListNode slow = head; ListNode fast = head; // 慢指针一次走一步、快指针一次走两步 // 注意：快指针可以走的条件 fast != null &amp;&amp; fast.next != null while (fast != null &amp;&amp; fast.next != null) { slow = slow.next; fast = fast.next.next; if (slow == fast) { return true; } } return false; } } 力扣287：给定一个包含n + 1个整数的数组nums，其数字都在[1, n]范围内（包括1和n），可知至少存在一个重复的整数。假设nums只有一个重复的整数，返回这个重复的数。 输入：nums = [1,3,4,2,2] 输出：2 查看解析 对nums数组建图，每个位置i连一条i-&gt;nums[i]的边。由于存在的重复的数字target，因此target这个位置一定有起码两条指向它的边，因此整张图一定存在环，且我们要找到的target就是这个环的入口。 先设置慢指针slow和快指针fast，慢指针每次走一步，快指针每次走两步，两个指针在有环的情况下一定会相遇。 假设环长为L，从起点到环的入口的步数是a，从环的入口继续走b步到达相遇位置，从相遇位置继续走c步回到环的入口，则有b+c=L，其中L,a,b,c都是正整数。根据上述定义，慢指针走了a+b步，快指针走了2(a+b)步。从另一角度考虑，在相遇位置，快指针比慢指针多走了若干圈，因此快指针走的步数还可以表示成a+b+kL，其中k表示快指针在环上走的圈数。联立等式，可以得到：2(a+b)=a+b+kL，解得a=kL-b，整理可得：a=(k-1)L+(L-b)=(k-1)L+c。 从上述等式可知，如果慢指针从起点出发，快指针从相遇位置出发，每次两个指针都移动一步，则慢指针走了a步之后到达环的入口，快指针在环里走了k-1圈之后又走了c步，由于从相遇位置继续走c步即可回到环的入口，因此快指针也到达环的入口。两个指针在环的入口相遇，相遇点就是答案。 // 看成是链表，数组下标i是当前节点，nums[i] 是下一个节点，如果成环,按照这种方式遍历链表会无限循环 class Solution { // 当存在多个重复值，也就是多个环时，只会在最小环中无限循环，也就是重复元素第2次出现的位置形成的环，不会走到后面更大的环 public int findDuplicate(int[] nums) { // 因此可以用环形链表的解法来找出环的入口 int slow = 0, fast = 0; do { slow = nums[slow]; fast = nums[nums[fast]]; } while (slow != fast); slow = 0; while (slow != fast) { slow = nums[slow]; fast = nums[fast]; } return slow; } } 相交链表经典问题：编写一个程序，找到两个单链表相交的起始节点。 方法一：考虑截断长的链表中多的部分，分别使用两个变量指向两个链表的第一个结点，让长的链表先走一些步数，这个步数就是长短链表的长度差，然后再让这两个变量齐头并进，在遍历的过程中只要检测到这两个变量指向同一个结点，这个结点就是两个链表的第一个公共结点。 public class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { // 特判 if (headA == null || headB == null) { return null; } int aLen = getLenOfListNode(headA); int bLen = getLenOfListNode(headB); // 总是让 A 链表是短链表 if (aLen &gt; bLen) { ListNode temp = headA; headA = headB; headB = temp; } // 注意：这里要取绝对值 int distance = Math.abs(aLen - bLen); for (int i = 0; i &lt; distance; i++) { headB = headB.next; } while (headA != headB) { headA = headA.next; headB = headB.next; } return headA; } private int getLenOfListNode(ListNode head) { int len = 0; while (head != null) { head = head.next; len++; } return len; } } 方法二：想办法让两个链表等长，具体方法是让链表A在遍历完成以后转向链表B，同时让链表B在遍历完成以后转向链表A。如果两个链表有公共结点，它们第一次相遇的时候返回的结点一定是两个链表的公共结点。 public class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { // 特判 if (headA == null || headB == null) { return null; } ListNode head1 = headA; ListNode head2 = headB; while (head1 != head2) { if (head1 != null) { head1 = head1.next; } else { head1 = headB; } if (head2 != null) { head2 = head2.next; } else { head2 = headA; } } return head1; } } .center { width: auto; display: table; margin-left: auto; margin-right: auto; }","categories":[{"name":"生活","slug":"生活","permalink":"http://goodguyjameswin.github.io/categories/生活/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://goodguyjameswin.github.io/tags/学习笔记/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"http://goodguyjameswin.github.io/categories/生活/"}]},{"title":"data-augtools","slug":"data-augtools","date":"2022-04-25T07:14:03.000Z","updated":"2022-07-18T04:21:41.477Z","comments":false,"path":"2022/04/25/data-augtools/","link":"","permalink":"http://goodguyjameswin.github.io/2022/04/25/data-augtools/","excerpt":"","text":"简介在原项目的基础上，添加了针对标注工具labelimg2的数据增强 在labelme的数据增强部分添加了旋转和裁剪处理，并做了标签增强： # 旋转 def _rotate_pic_bboxes(self, img, json_info, degree = 5): # ---------------------- 旋转图像 ---------------------- height, width = img.shape[:2] heightNew = int(width * fabs(sin(radians(degree))) + height * fabs(cos(radians(degree)))) widthNew = int(height * fabs(sin(radians(degree))) + width * fabs(cos(radians(degree)))) matRotation = cv2.getRotationMatrix2D((width // 2, height // 2), degree, 1) matRotation[0, 2] += (widthNew - width) // 2 matRotation[1, 2] += (heightNew - height) // 2 # imgRotation = cv2.warpAffine(img, matRotation, (widthNew, heightNew), borderValue=(255, 255, 255)) imgRotation = cv2.warpAffine(img, matRotation, (widthNew, heightNew), borderValue=(0, 0, 0)) # ---------------------- 调整boundingbox ---------------------- json_dict = {} for key, value in json_info.items(): if key == &#39;imageHeight&#39;: json_dict[key] = imgRotation.shape[0] elif key == &#39;imageWidth&#39;: json_dict[key] = imgRotation.shape[1] else: json_dict[key] = value for item in json_dict[&#39;shapes&#39;]: for key, value in item.items(): if key == &#39;points&#39;: for item2 in range(len(value)): pt1 = np.dot(matRotation, np.array([[value[item2][0]], [value[item2][1]], [1]])) value[item2][0], value[item2][1] = pt1[0][0], pt1[1][0] return imgRotation, json_dict # ... 修改后","categories":[{"name":"技术","slug":"技术","permalink":"http://goodguyjameswin.github.io/categories/技术/"}],"tags":[{"name":"开源项目","slug":"开源项目","permalink":"http://goodguyjameswin.github.io/tags/开源项目/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://goodguyjameswin.github.io/categories/技术/"}]},{"title":"排序","slug":"排序","date":"2022-04-23T10:42:11.000Z","updated":"2022-07-24T09:25:02.514Z","comments":false,"path":"2022/04/23/排序/","link":"","permalink":"http://goodguyjameswin.github.io/2022/04/23/排序/","excerpt":"","text":"选择排序选择排序每一轮都选取未排定部分的最小元素，然后将它交换到未排定部分的第一个位置。 public class Solution { public int[] selectSort(int[] nums) { int len = nums.length; // 最后一轮只有一个元素，一定是最大的元素，因此写 i &lt; len - 1 for (int i = 0; i &lt; len - 1; i++) { // 在 [i + 1, len - 1] 区间里选择最小的元素的下标 int minIndex = i; for (int j = i + 1; j &lt; len; j++) { if (nums[j] &lt; nums[minIndex]) { minIndex = j; } } swap(nums, minIndex, i); } return nums; } private void swap(int[] nums, int index1, int index2) { int temp = nums[index1]; nums[index1] = nums[index2]; nums[index2] = temp; } } 选择排序的每一轮循环没有为下一次循环记录更多的信息。堆可以帮助我们在每次未排定的部分里快速地选择出当前最小的元素。因此堆排序是选择排序的优化排序算法。 堆排序堆排序每一次以O(logN)的时间复杂度选取出当前未排定部分的最大元素，基本思路是让堆顶元素和当前堆的最后一个元素交换，当前最大元素就被交换到此时数组的末尾，这个位置就被排定了。接下来只需要让这个数组的前半部分继续称为一个堆即可。 public class Solution { public int[] sortArray(int[] nums) { int len = nums.length; // 第 1 步：先整理成最大堆 heapify(nums, len); // 第 2 步：先交换，再将堆顶元素下沉 // 注意：这里 i 表示当前二叉树所表示的数组的结尾下标 for (int i = len - 1; i &gt;= 1; ) { swap(nums, 0, i); i--; siftDown(nums, 0, i); } return nums; } private void heapify(int[] nums, int len) { // 下标从0开始整理成堆（也可从1开始） for (int i = (len - 1) / 2; i &gt;= 0; i--) { siftDown(nums, i, len - 1); } } private void siftDown(int[] nums, int k, int end) { while (2 * k + 1 &lt;= end) { int j = 2 * k + 1; if (j + 1 &lt;= end &amp;&amp; nums[j + 1] &gt; nums[j]) { j++; } if (nums[j] &gt; nums[k]) { swap(nums, j, k); } else { break; } k = j; } } private void swap(int[] nums, int index1, int index2) { int temp = nums[index1]; nums[index1] = nums[index2]; nums[index2] = temp; } } 冒泡排序冒泡排序的内循环使用相邻双指针j, j+1从左至右遍历，依次比较相邻元素大小，若左元素大于右元素则将它们交换，遍历完成时，最大元素会被交换至数组最右边；外循环不断重复内循环，每轮将当前最大元素交换至剩余未排序数组最右边，直至所有元素都被交换至正确位置时结束。 public class Solution { public int[] bubbleSort(int[] nums) { int N = nums.length; for (int i = 0; i &lt; N - 1; i++) { // 外循环 for (int j = 0; j &lt; N - i - 1; j++) { // 内循环 if (nums[j] &gt; nums[j + 1]) { // 交换 nums[j], nums[j + 1] swap(nums, j, j + 1); } } } } private void swap(int[] nums, int index1, int index2) { int temp = nums[index1]; nums[index1] = nums[index2]; nums[index2] = temp; } } 插入排序插入排序将一个元素插入到一个有序数组中，使之成为更长的有序数组。插入排序内层循环可以提前终止，如果待排序的数组是 接近有序 的数组（即数组中的元素离它最终排定以后的位置很近）和元素个数较少的数组，插入排序就可以很快完成。 public class Solution { public int[] sortArray(int[] nums) { int len = nums.length; // 循环不变量：将 nums[i] 插入到区间 [0, i) 使之有序 for (int i = 1; i &lt; len; i++) { // 先暂存这个元素，然后之前数值严格小于 temp 的所有元素逐个后移 int temp = nums[i]; int j = i; // 注意边界 j &gt; 0 while (j &gt; 0 &amp;&amp; nums[j - 1] &gt; temp) { nums[j] = nums[j - 1]; j--; } // 最后这一步容易忽略 nums[j] = temp; } return nums; } } 在内层循环里都有j &gt; 0这个判断条件，有一种插入排序的写法，先找到整个数组中最小的那个元素，把它交换到数组的第一个位置（下标为0），后面的逻辑就可以去掉j &gt; 0。这样的技巧有一个很形象的名字，叫哨兵，即放置一个元素，通常是边界位置，它能帮助我们回避边界条件，从而减少分类讨论。 希尔排序希尔排序使用的是缩小增量（或者称有间隔的）的插入排序方法，以增量为步长划分子序列（与子数组不同，子序列不要求在原始序列中是连续的，但要保证数组中的元素位置相对顺序不变，子序列的长度可以为1），即属于同一子序列的元素，下标的步长等于增量。对每一个子序列应用插入排序，不断缩小增量，当增量为1时所有的数组元素都在一个子序列中，执行一次插入排序，数组最终有序。 public class Solution { // 希尔排序，使用 Shell 建议的序列 N/2,N/4,...,2,1 public int[] sortArray(int[] nums) { int len = nums.length; int h = 1; int gap = len / 2; while (gap &gt;= 1) { // 缩小增量的插入排序 for (int i = h; i &lt; len; i++) { insertionForDelta(nums, gap, i); } gap /= 2; } return nums; } /** * 将 nums[end] 插入到对应分组的正确位置上，其实就是将原来 1 的部分改成 gap * * @param nums * @param gap 间隔 * @param end */ private void insertionForDelta(int[] nums, int gap, int end) { int temp = nums[end]; int j = end; while (j &gt;= gap &amp;&amp; nums[j - gap] &gt; temp) { nums[j] = nums[j - gap]; j -= gap; } nums[j] = temp; } } 归并排序将两个或两个以上的有序序列合并成一个新的有序序列，数组的归并需要使用额外的空间。 public class Solution { // 列表大小等于或小于该大小，将优先于 mergesort 使用插入排序 private static final int INSERTION_SORT_THRESHOLD = 47; public int[] sortArray(int[] nums) { int len = nums.length; 优化3：全局使用一份临时数组 int[] temp = new int[len]; mergeSort(nums, 0, len - 1, temp); return nums; } // 对数组 nums 的子区间 [left, right] 进行归并排序，左右边界都可以取到 private void mergeSort(int[] nums, int left, int right, int[] temp) { if (left == right) { return; } // 优化1：小区间使用插入排序 if (right - left &lt;= INSERTION_SORT_THRESHOLD) { insertionSort(nums, left, right); return; } int mid = left + (right - left) / 2; mergeSort(nums, left, mid); mergeSort(nums, mid + 1, right); // 优化2：数组已经有序的情况下，不再合并 if (nums[mid] &lt;= nums[mid + 1]) { return; } mergeOfTwoSortedArray(nums, left, mid, right); } // 合并两个有序数组：先把值复制到临时数组，再合并回去，[left, mid] 有序，[mid + 1, right] 有序 private void mergeOfTwoSortedArray(int[] nums, int left, int mid, int right, int[] temp) { for (int i = left; i&lt;= right; ++i) { temp[i] = nums[i]; } // i 和 j 分别指向前有序数组和后有序数组的起始位置 int i = left; int j = mid + 1; for (int k = left; k &lt;= right; ++k) { // 先写 i 和 j 越界的情况 if (i == mid + 1) { nums[k] = temp[j]; j++; } else if (j == right + 1) { nums[k] = temp[i]; i++; } else if (temp[i] &lt;= temp[j]) { // 这里是 &lt;= ，否则归并排序就变成了非稳定的排序 nums[k] = temp[i]; i++; } else { nums[k] = temp[j]; j++; } } } // 对数组给定的部分使用插入排序，左右边界都能取到 private void insertionSort(int[] arr, int left, int right) { for (int i = left + 1; i &lt;= right; ++i) { int temp = arr[i]; int j = i; while (j &gt; left &amp;&amp; arr[j - 1] &gt; temp) { arr[j] = arr[j - 1]; j--; } arr[j] = temp; } } } 力扣315：给你一个整数数组nums，按要求返回一个新数组counts。数组counts有该性质：counts[i]的值是nums[i]右侧小于nums[i]的元素的数量。 输入：nums = [5,2,6,1] 输出：[2,1,1,0] 解释： 5 的右侧有 2 个更小的元素（2 和 1） 2 的右侧仅有 1 个更小的元素（1） 6 的右侧有 1 个更小的元素（1） 1 的右侧有 0 个更小的元素 查看解析 public class Solution { public List&lt;Integer&gt; countSmaller(int[] nums) { List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); int len = nums.length; if (len == 0) { return result; } int[] temp = new int[len]; int[] res = new int[len]; // 索引数组，作用：归并回去的时候，方便知道是哪个下标的元素 int[] indexes = new int[len]; for (int i = 0; i &lt; len; i++) { indexes[i] = i; } mergeAndCountSmaller(nums, 0, len - 1, indexes, temp, res); // 把 int[] 转换成为 List&lt;Integer&gt;，没有业务逻辑 for (int i = 0; i &lt; len; i++) { result.add(res[i]); } return result; } /** * 针对数组 nums 指定的区间 [left, right] 进行归并排序，在排序的过程中完成统计任务 * * @param nums * @param left * @param right */ private void mergeAndCountSmaller(int[] nums, int left, int right, int[] indexes, int[] temp, int[] res) { if (left == right) { return; } int mid = left + (right - left) / 2; mergeAndCountSmaller(nums, left, mid, indexes, temp, res); mergeAndCountSmaller(nums, mid + 1, right, indexes, temp, res); // 归并排序的优化，如果索引数组有序，则不存在逆序关系，没有必要合并 if (nums[indexes[mid]] &lt;= nums[indexes[mid + 1]]) { return; } mergeOfTwoSortedArrAndCountSmaller(nums, left, mid, right, indexes, temp, res); } /** * [left, mid] 是排好序的，[mid + 1, right] 是排好序的 * * @param nums * @param left * @param mid * @param right * @param indexes * @param temp * @param res */ private void mergeOfTwoSortedArrAndCountSmaller(int[] nums, int left, int mid, int right, int[] indexes, int[] temp, int[] res) { for (int i = left; i &lt;= right; i++) { temp[i] = indexes[i]; } int i = left; int j = mid + 1; for (int k = left; k &lt;= right; k++) { if (i &gt; mid) { indexes[k] = temp[j]; j++; } else if (j &gt; right) { indexes[k] = temp[i]; i++; res[indexes[k]] += (right - mid); } else if (nums[temp[i]] &lt;= nums[temp[j]]) { // 注意：这里是 &lt;= ，保证稳定性 indexes[k] = temp[i]; i++; res[indexes[k]] += (j - mid - 1); } else { indexes[k] = temp[j]; j++; } } } } 快速排序最重要的思想是划分（partition），partition先选取一个元素作为基准元素（随机选择），一次划分将数组分为两个部分，跳过大于等于基准元素的元素，继续遍历，遇到小的元素，就把它们依次交换到数组的前面去。 public class Solution { private static final Random RANDOM = new Random(); public int[] sortArray(int[] nums) { int len = nums.length; quickSort(nums, 0, len - 1); return nums; } private void quickSort(int[] nums, int left, int right) { // 与归并排序不同，这里包括 &gt; 的情况 if (left &gt;= right) { return; } int p = partition(nums, left, right); quickSort(nums, left, p - 1); quickSort(nums, p + 1, right); } private int partition(int[] nums, int left, int right) { // 随机选择一个元素作为切分元素 int randomIndex = left + RANDOM.nextInt(right - left + 1); swap(nums, randomIndex, left); int pivot = nums[left]; // 循环不变量：lt 意即 less than // [left + 1, lt] &lt; pivot // [lt + 1, i) &gt;= pivot int lt = left; for (int i = left + 1; i &lt;= right; ++i) { if (nums[i] &lt; pivot) { ++lt; swap(nums, lt, i); } } // 最后要记得交换到起始位置 swap(nums, left, lt); return lt; } private void swap(int[] nums, int index1, int index2) { int temp = nums[index1]; nums[index1] = nums[index2]; nums[index2] = temp; } } 力扣80：给你一个有序数组nums。请你原地删除重复出现的元素，使得出现次数超过两次的元素只出现k次，返回删除后数组的新长度。不能使用额外的数组空间，你必须原地修改输入数组并仅使用O(1)的额外空间。 输入：nums = [1,1,1,2,2,3]，k = 2 输出：5, nums = [1,1,2,2,3] 解释：函数应返回新长度 length = 5，并且原数组的前五个元素被修改为 1, 1, 2, 2, 3。不需要考虑数组中超出新长度的后面的元素。 查看解析 class Solution { public int removeDuplicates(int[] nums, int k) { int n = nums.length; if (n &lt;= k) { return n; } int slow = k, fast = k; while (fast &lt; n) { if (nums[slow - k] != nums[fast]) { nums[slow] = nums[fast]; ++slow; } ++fast; } return slow; } } 指针对撞的快速排序：当输入数组中有大量重复元素的数据时，需要把和pivot相等的元素平均分到数组的两边，使得递归树平衡。 public class Solution { private static final Random RANDOM = new Random(); public int[] sortArray(int[] nums) { int len = nums.length; quickSort(nums, 0, len - 1); return nums; } private void quickSort(int[] nums, int left, int right) { // 注意：这里包括 &gt; 的情况，与归并排序不同，请通过调试理解这件事情 if (left &gt;= right) { return; } int p = partition(nums, left, right); quickSort(nums, left, p - 1); quickSort(nums, p + 1, right); } /** * 目标：与切分元素相等的元素均匀地分布在切分元素最终所在位置的两侧 * 这个定义非常重要，直接影响我们的算法初始值定义 * [left + 1, i) 全部小于标定点 * (j, right] 全部大于标定点 * 在指针对撞的过程中，和标定点相同的元素就被挤到了中间 * * @param nums * @param left * @param right * @return */ public int partition(int[] nums, int left, int right) { int randomIndex = left + RANDOM.nextInt(right - left + 1); swap(nums, randomIndex, left); // 循环不变量，le = less equals，ge = greater equals // all in [left + 1, le) &lt;= pivot // all in (ge, right] &gt;= pivot // le &gt; ge 的时候终止 int pivot = nums[left]; int le = left + 1; int ge = right; while (true) { // 注意：这里一定是 nums[le] &lt; pivot，等于 pivot 的元素是被交换过来得到的 while (le &lt;= ge &amp;&amp; nums[le] &lt; pivot) { le++; } // 此时 le 来到第 1 个大于等于 pivot 的位置 while (le &lt;= ge &amp;&amp; nums[ge] &gt; pivot) { ge--; } // 此时 ge 来到第 1 个小于等于 pivot 的位置 if (le &gt; ge) { break; } swap(nums, le, ge); le++; ge--; } // 循环退出后，ge 来到 le 的左边，根据循环不变量，它所指向的元素一定是小于等于 pivot 的，因此交换 left 与 ge 位置上的元素，这时排定的元素 ge 对应的元素，应该把 ge 返回回去 swap(nums, left, ge); return ge; } private void swap(int[] nums, int index1, int index2) { int temp = nums[index1]; nums[index1] = nums[index2]; nums[index2] = temp; } } 力扣215：给定整数数组nums和整数k，请返回数组中第k个最大的元素。请注意，你需要找的是数组排序后的第k个最大的元素，而不是第k个不同的元素。 输入：[3,2,1,5,6,4] 和 k = 2 输出：5 查看解析 class Solution { private final static Random random = new Random(System.currentTimeMillis()); public int findKthLargest(int[] nums, int k) { // 第 1 大的数，下标是 len - 1; // 第 2 大的数，下标是 len - 2; // ... // 第 k 大的数，下标是 len - k; int len = nums.length; int target = len - k; int left = 0; int right = len - 1; while (true) { // 无需使用递归调用栈，通过二分查找的方式即可逐步缩小搜索区间 int pivotIndex = partition(nums, left, right); if (pivotIndex == target) { return nums[pivotIndex]; } else if (pivotIndex &lt; target) { left = pivotIndex + 1; } else { // pivotIndex &gt; target right = pivotIndex - 1; } } } private int partition(int[] nums, int left, int right) { int randomIndex = left + random.nextInt(right - left + 1); swap(nums, left, randomIndex); // all in nums[left + 1..le) &lt;= pivot; // all in nums(ge..right] &gt;= pivot; int pivot = nums[left]; int le = left + 1; int ge = right; while (true) { while (le &lt;= ge &amp;&amp; nums[le] &lt; pivot) { le++; } while (le &lt;= ge &amp;&amp; nums[ge] &gt; pivot) { ge--; } if (le &gt;= ge) { break; } swap (nums, le, ge); le++; ge--; } swap(nums, left, ge); return ge; } private void swap(int[] nums, int index1, int index2) { int temp = nums[index1]; nums[index1] = nums[index2]; nums[index2] = temp; } } 三向切分的快速排序：如果执行partition的子区间当中，有很多元素都和基准元素相等，那么这些元素在这一轮中都被挤到了中间，它们前面的元素都比pivot小，它们后面的元素都比pivot大，因此它们就位于排序以后最终应该在的位置。 public class Solution { private static final Random RANDOM = new Random(); public int[] sortArray(int[] nums) { int len = nums.length; quickSort(nums, 0, len - 1); return nums; } private void quickSort(int[] nums, int left, int right) { if (left &gt;= right) { return; } int randomIndex = left + RANDOM.nextInt(right - left + 1); swap(nums, randomIndex, left); // all in [left + 1, lt] &lt; pivot // all in [lt + 1, i) = pivot // all in [gt, right] &gt; pivot // 因为 i 是循环变量，定义为“遍历之前的元素”更好理解 int pivot = nums[left]; // 如下初始化，可保证遍历开始时三个区间都为空 int lt = left; int gt = right + 1; int i = left + 1; while (i &lt; gt) { if (nums[i] &lt; pivot) { lt++; swap(nums, i, lt); i++; } else if (nums[i] == pivot) { i++; } else { gt--; swap(nums, i, gt); // 此时 i 无需移动，因为交换过来是一个未访问过的元素，需要在下一轮循环中继续判断 } } swap(nums, left, lt); // 注意这里，大大减少了分治的区间，区间 [lt, gt - 1] 不必递归求解 quickSort(nums, left, lt - 1); quickSort(nums, gt, right); } private void swap(int[] nums, int index1, int index2) { int temp = nums[index1]; nums[index1] = nums[index2]; nums[index2] = temp; } } 计数排序对于每一个输入数组的元素，计算严格小于它的元素的个数（前缀和计数数组），进而把它放到输出数组对应的位置上。 public class CountingSort { public void sort(int[] nums) { int len = nums.length; int max = nums[0]; // 检验数据有效性 // 找到数组中的最大值，以确定计数数组的长度 for (int i = 1; i &lt; len; i++) { if (nums[i] &gt; max) { max = nums[i]; } // 数据有效性校验，因为要将数值作为数组 count 的下标使用，因此 nums[i] 不能小于 0 if (nums[i] &lt; 0) { throw new IllegalArgumentException(&quot;该数组不适合使用计数排序&quot;); } } // 第 1 步：对原始数组进行计数，这里将原始数组的值，作为了计数数组的下标 int[] count = new int[max + 1]; // 遍历原始数组，完成计数 for (int i = 0; i &lt; len; i++) { count[nums[i]] += 1; } // 第 2 步：将 count 数组改造成前缀和数组，我们需要的是前缀和，在原地进行变换即可 // 由前缀和数组就可以推出这个元素所在的位置 for (int i = 1; i &lt;= max; i++) { count[i] += count[i - 1]; } // 为了写回去，需要对原始数组做一个拷贝 int[] numsCopy = new int[len]; System.arraycopy(nums, 0, numsCopy, 0, len); // 第 3 步：从后向前扫描，依次把看到的数写回原始数组，从后向前是为了保证稳定性 for (int i = len - 1; i &gt;= 0; i--) { // 位置有一个偏移，在纸上写出来就很容易发现规律 int position = count[numsCopy[i]] - 1; // 把看到的数覆盖回去 nums[position] = numsCopy[i]; // 前缀和减一，作为下一个看到的相同数存放位置的依据 count[numsCopy[i]]--; } } } 基数排序越高位的排序是放在后面进行的，在高位相同的情况下，需要比较次高位，需要比较次高位，而次高位在之前的排序中已经排好序。 public class RadixSort { public void sort(int[] nums) { int len = nums.length; // 第 1 步：找出最大的数字 int max = nums[0]; for (int i = 0; i &lt; len; i++) { if (nums[i] &gt; max) { max = nums[i]; } // 数据有效性校验，因为要将数值作为 count 的索引用，因此 nums[i] 不能小于 0 if (nums[i] &lt; 0) { throw new IllegalArgumentException(&quot;该数组不适合使用计数排序&quot;); } } // 第 2 步：计算出最大的数字有几位，这个数值决定了我们要将整个数组看几遍 int maxLen = getMaxLen(max); // 第 3 步：每一趟都使用计数排序 int[] count = new int[10]; int[] temp = new int[len]; int divisor = 1; // 有几位数，外层循环就得执行几次 for (int i = 0; i &lt; maxLen; i++) { // 每一步都使用计数排序，保证排序结果是稳定的，这一步需要额外空间保存结果集，因此把结果保存在 temp 中 countingSort(nums, temp, divisor, len, count); System.arraycopy(temp, 0, nums, 0, len); divisor *= 10; } } /** * * @param nums 原始数组 * @param temp 在计数排序的过程中使用的辅助数组，这一次基于 divisor 关键字的排序结果存在这里 * @param divisor * @param len 原始数组的长度（冗余变量） * @param count 计数数组 */ private void countingSort(int[] nums, int[] temp, int divisor, int len, int[] count) { // 内层循环得把数组从头到尾看一遍 for (int j = 0; j &lt; len; j++) { // 计算数位上的数是几，先取个位，再十位、百位 int remainder = (nums[j] / divisor) % 10; count[remainder]++; } for (int j = 1; j &lt; 10; j++) { count[j] += count[j - 1]; } for (int j = len - 1; j &gt;= 0; j--) { int remainder = (nums[j] / divisor) % 10; int index = count[remainder] - 1; temp[index] = nums[j]; count[remainder]--; } // 重置数组 count，以便下次使用 for (int j = 0; j &lt; 10; j++) { count[j] = 0; } } /** * 获取一个整数的最大位数 * * @param num * @return */ private int getMaxLen(int num) { int maxLen = 0; while (num &gt; 0) { num /= 10; maxLen++; } return maxLen; } } 桶排序将待排序数组分配到若干个桶内，然后再对每个桶各自执行一次排序任务。桶内的排序可以使用不同的排序方法，每个桶内排序完成以后，依次将每个桶内的元素取出来，最终得到一个有序数组。 public class BucketSort { public void sort(int[] nums) { int len = nums.length; int max = nums[0]; // 第 1 步：找到数组中的最大值，以确定计数数组的长度 for (int i = 1; i &lt; len; i++) { if (nums[i] &gt; max) { max = nums[i]; } // 数据有效性校验，因为要将数值作为 count 的索引用，因此 nums[i] 不能小于 0 if (nums[i] &lt; 0) { throw new IllegalArgumentException(&quot;该数组不适合使用计数排序&quot;); } } // 第 2 步：计算出最大的数字有几位，这个数值决定了桶的个数 int maxLen = getMaxLen(max); // 步长 int step = 1000; // 决定设置几个桶 if (maxLen &lt; 5) { // 如果最大数小于 10000 // 3 位数就设置 100 个桶 // 2 位数就设置 10 个桶 step = (int) Math.pow(10, maxLen - 1); } // System.out.println(&quot;步长：&quot; + step); // 桶的个数 int bucketLen = max / step + 1; // System.out.println(&quot;桶的个数：&quot; + bucketLen); // 因为不能确定每个桶存放的数据量，因此每个桶的长度都设置为 len int[][] temp = new int[bucketLen][len]; int[] next = new int[bucketLen]; // 第 3 步：分桶 for (int i = 0; i &lt; len; i++) { // 找到所在的桶的索引 int bucketIndex = nums[i] / step; // 在该桶中放入元素 temp[bucketIndex][next[bucketIndex]] = nums[i]; // 该桶存放的元素个数 + 1 next[bucketIndex]++; } // 第 4 步：对于每个桶执行插入排序 for (int i = 0; i &lt; bucketLen; i++) { insertionSort(temp[i], next[i] - 1); } // 第 5 步：从桶里依次取出来 int index = 0; for (int i = 0; i &lt; bucketLen; i++) { int curLen = next[i]; for (int j = 0; j &lt; curLen; j++) { nums[index] = temp[i][j]; index++; } } } private void insertionSort(int[] arr, int endIndex) { for (int i = 1; i &lt;= endIndex; i++) { int temp = arr[i]; int j = i; while (j &gt; 0 &amp;&amp; arr[j - 1] &gt; temp) { arr[j] = arr[j - 1]; j--; } arr[j] = temp; } } /** * 获取一个整数的最大位数 * * @param num * @return */ private int getMaxLen(int num) { int maxLen = 0; while (num &gt; 0) { num /= 10; maxLen++; } return maxLen; } } 力扣41：给你一个未排序的整数数组nums，请你找出其中没有出现的最小的正整数。 输入：nums = [1,2,0] 输出：3 查看解析 public class Solution { public int firstMissingPositive(int[] nums) { int len = nums.length; for (int i = 0; i &lt; len; i++) { while (nums[i] &gt; 0 &amp;&amp; nums[i] &lt;= len &amp;&amp; nums[nums[i] - 1] != nums[i]) { // 满足在指定范围内、并且没有放在正确的位置上，才交换 // 例如：数值 3 应该放在索引 2 的位置上 swap(nums, nums[i] - 1, i); } } // [1, -1, 3, 4] for (int i = 0; i &lt; len; i++) { if (nums[i] != i + 1) { return i + 1; } } // 都正确则返回数组长度 + 1 return len + 1; } private void swap(int[] nums, int index1, int index2) { int temp = nums[index1]; nums[index1] = nums[index2]; nums[index2] = temp; } } 给你一个整数数组nums和一个整数k，请你返回其中出现频率前k高的元素。你可以按任意顺序返回答案。 输入：nums = [1,1,1,2,2,3], k = 2 输出：[1,2] 查看解析 方法一：基于快速排序（求出出现次数数组的前k大的值） class Solution { public int[] topKFrequent(int[] nums, int k) { Map&lt;Integer, Integer&gt; occurrences = new HashMap&lt;Integer, Integer&gt;(); for (int num : nums) { occurrences.put(num, occurrences.getOrDefault(num, 0) + 1); } List&lt;int[]&gt; values = new ArrayList&lt;int[]&gt;(); for (Map.Entry&lt;Integer, Integer&gt; entry : occurrences.entrySet()) { int num = entry.getKey(), count = entry.getValue(); values.add(new int[]{num, count}); } int[] ret = new int[k]; qsort(values, 0, values.size() - 1, ret, 0, k); return ret; } public void qsort(List&lt;int[]&gt; values, int start, int end, int[] ret, int retIndex, int k) { int picked = (int) (Math.random() * (end - start + 1)) + start; Collections.swap(values, picked, start); int pivot = values.get(start)[1]; int index = start; for (int i = start + 1; i &lt;= end; i++) { if (values.get(i)[1] &gt;= pivot) { Collections.swap(values, index + 1, i); index++; } } Collections.swap(values, start, index); if (k &lt;= index - start) { qsort(values, start, index - 1, ret, retIndex, k); } else { for (int i = start; i &lt;= index; i++) { ret[retIndex++] = values.get(i)[0]; } if (k &gt; index - start + 1) { qsort(values, index + 1, end, ret, retIndex, k - (index - start + 1)); } } } } 方法二：桶排序： class Solution { public List&lt;Integer&gt; topKFrequent(int[] nums, int k) { List&lt;Integer&gt; res = new ArrayList(); // 使用字典，统计每个元素出现的次数，元素为键，元素出现的次数为值 HashMap&lt;Integer,Integer&gt; map = new HashMap(); for(int num : nums){ if (map.containsKey(num)) { map.put(num, map.get(num) + 1); } else { map.put(num, 1); } } //桶排序 //将频率作为数组下标，对于出现频率不同的数字集合，存入对应的数组下标 List&lt;Integer&gt;[] list = new List[nums.length+1]; for(int key : map.keySet()){ // 获取出现的次数作为下标 int i = map.get(key); if(list[i] == null){ list[i] = new ArrayList(); } list[i].add(key); } // 倒序遍历数组获取出现顺序从大到小的排列 for(int i = list.length - 1;i &gt;= 0 &amp;&amp; res.size() &lt; k;i--){ if(list[i] == null) continue; res.addAll(list[i]); } return res; } } 力扣220：给你一个整数数组nums和两个整数k和t。请你判断是否存在两个不同下标i和j，使得abs(nums[i] - nums[j]) &lt;= t，同时又满足abs(i - j) &lt;= k。如果存在则返回true，不存在返回false。 输入：nums = [1,2,3,1], k = 3, t = 0 输出：true 查看解析 方法一：滑动窗口+有序集合 class Solution { public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) { // 维护一个大小为 k 的滑动窗口，每次遍历到元素 x 时，滑动窗口中包含元素 x 前面的最多 k 个元素，我们检查窗口中是否存在元素落在区间 [x−t,x+t] 中即可 int n = nums.length; TreeSet&lt;Long&gt; set = new TreeSet&lt;Long&gt;(); for (int i = 0; i &lt; n; i++) { Long ceiling = set.ceiling((long) nums[i] - (long) t); if (ceiling != null &amp;&amp; ceiling &lt;= (long) nums[i] + (long) t) { return true; } set.add((long) nums[i]); if (i &gt;= k) { set.remove((long) nums[i - k]); } } return false; } } 方法二：桶 class Solution { public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) { // 同一个桶中的任两个元素之差的绝对值小于等于t，相邻桶中的某两个元素之差的绝对值可能小于等于t（通过计算判断是否真的小于等于t），不同相邻的桶中的元素之差的绝对值不可能满足小于等于t int n = nums.length; Map&lt;Long, Long&gt; map = new HashMap&lt;Long, Long&gt;(); long w = (long) t + 1; // t 可能为 0 for (int i = 0; i &lt; n; i++) { long id = getID(nums[i], w); if (map.containsKey(id)) { return true; } if (map.containsKey(id - 1) &amp;&amp; Math.abs(nums[i] - map.get(id - 1)) &lt; w) { return true; } if (map.containsKey(id + 1) &amp;&amp; Math.abs(nums[i] - map.get(id + 1)) &lt; w) { return true; } map.put(id, (long) nums[i]); if (i &gt;= k) { map.remove(getID(nums[i - k], w)); } } return false; } // 我们将 int 范围内的每一个整数 x 表示为：x=(t+1)×a+b(0≤b≤t) 的形式，这样 x 即归属于编号为 a 的桶。一个桶内至多只会有一个元素 public long getID(long x, long w) { if (x &gt;= 0) { return x / w; } return (x + 1) / w - 1; } } 最坏时间复杂度 平均时间复杂度 最好时间复杂度 额外空间复杂度 稳定性 是否原地排序 选择排序 O(N2) O(N2) O(N2) O(1) 不稳定 原地排序 堆排序 O(NlogN) O(NlogN) O(NlogN) O(1) 不稳定 原地排序 冒泡排序 O(N2) O(N2) O(N) O(1) 稳定 原地排序 插入排序 O(N2) O(N2) O(N) O(1) 稳定 原地排序 希尔排序 O(N2) O(n1.25)~O(1.6n1.25) (没有相关研究) O(1) 不稳定 原地排序 归并排序 O(NlogN) O(NlogN) O(NlogN) O(N) 稳定 非原地排序 快速排序 O(N2) O(NlogN) O(NlogN) O(logN) 不稳定 原地排序 计数排序 O(N+k) O(N+K) O(N+K) O(N+K) 稳定 非原地排序 基数排序 O(kN) O(KN) O(N2) O(N+K) 稳定 非原地排序 桶排序 O(N2) O(N) O(N) 视情况而定 稳定 非原地排序 .center { width: auto; display: table; margin-left: auto; margin-right: auto; }","categories":[{"name":"生活","slug":"生活","permalink":"http://goodguyjameswin.github.io/categories/生活/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://goodguyjameswin.github.io/tags/学习笔记/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"http://goodguyjameswin.github.io/categories/生活/"}]},{"title":"PaddleOCR","slug":"PaddleOCR","date":"2022-04-20T02:20:57.000Z","updated":"2022-09-11T08:51:13.263Z","comments":false,"path":"2022/04/20/PaddleOCR/","link":"","permalink":"http://goodguyjameswin.github.io/2022/04/20/PaddleOCR/","excerpt":"","text":"简介由于项目需求，直接调用PaddleOCR官方训练好的中英文通用检测识别权重，把检测字符和识别串联的代码结构合并了一下，然后修改了分行的判别机制 原项目 修改前： 修改后： cpu串联推理结合mkldnn设置，速度大概提升了30%","categories":[{"name":"技术","slug":"技术","permalink":"http://goodguyjameswin.github.io/categories/技术/"}],"tags":[{"name":"开源项目","slug":"开源项目","permalink":"http://goodguyjameswin.github.io/tags/开源项目/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://goodguyjameswin.github.io/categories/技术/"}]},{"title":"双指针与滑动窗口","slug":"双指针与滑动窗口","date":"2022-04-18T10:44:18.000Z","updated":"2022-07-18T03:43:57.989Z","comments":false,"path":"2022/04/18/双指针与滑动窗口/","link":"","permalink":"http://goodguyjameswin.github.io/2022/04/18/双指针与滑动窗口/","excerpt":"","text":"滑动窗口滑动窗口算法的两个指针变量的移动方向是相同的，形成了一个窗口在直线上滑动的效果。 力扣3：给定一个字符串s，请你找出其中不含有重复字符的最长字串的长度。 输入：s = “abcabcbb” 输出：3 解释：因为无重复字符的最长字串是 “abc”，所以其长度为 3。 查看解析 public class Solution { // 在遍历的过程中，记录元素出现的位置 public int lengthOfLongestSubstring(String s) { // 重复元素上一次出现的位置很重要 int len = s.length(); if (len &lt; 2) { return len; } // 当做哈希表使用。key：字符的 ASCII 值，value：最新下标，-1 表示当前字符在遍历的时候还未出现过 int[] window = new int[128]; for (int i = 0; i &lt; 128; i++) { window[i] = -1; } char[] charArray = s.toCharArray(); int res = 1; int left = 0; // [left, right) 没有重复元素 for (int right = 0; right &lt; len; right++) { // 当有重复元素出现的时候，只要这个元素之前出现的下标 大于等于 当前滑动窗口左边界的下标，就可以直接跳过来；如果重复元素之前出现的下标 严格小于 当前滑动窗口左边界的下标，左边界不用移动 if (window[charArray[right]] != -1) { left = Math.max(left, window[charArray[right]] + 1); } window[charArray[right]] = right; // 注意理解这里为什么是 + 1 res = Math.max(res, right - left + 1); } return res; } } 力扣76：给你一个字符串s，一个字符串t。返回s中涵盖t所有字符的最小字串。如果s中不存在涵盖t所有字符的字串，则返回空字符串&quot;&quot;。 对于t中重复字符，我们寻找的子字符串中该字符数量必须不少于t中该字符数量 如果s中存在这样的字串，我们保证它是唯一的答案 输入：s = “ADOBECODEBANC”, t = “ABC” 输出：”BANC” 查看解析 public class Solution { public String minWindow(String s, String t) { int[] window = new int[128]; int[] pattern = new int[128]; // 对 t 做频数统计 final int A = &#39;A&#39;; for (Character c : t.toCharArray()) { pattern[c - A]++; } int distance = 0; // 记录 t 中一共有多少个不同的字母 for (int i = 0; i &lt; 128; i++) { if (pattern[i] &gt; 0) { distance++; } } int sLen = s.length(); int start = 0; int left = 0; int right = 0; int match = 0; int minLen = sLen + 1; while (right &lt; sLen) { Character curChar = s.charAt(right); if (pattern[curChar - A] &gt; 0) { window[curChar - A]++; // 只对 t 中出现的字符做统计 if (window[curChar - A] == pattern[curChar - A]) { match++; // 表示滑动窗口内的字符种类与 t 的差距减少了 1 } } right++; while (match == distance) { if (right - left &lt; minLen) { start = left; minLen = right - left; } // 考虑左边界向右边走 Character leftChar = s.charAt(left); if (pattern[leftChar - A] &gt; 0) { window[leftChar - A]--; if (window[leftChar - A] &lt; pattern[leftChar - A]) { match--; } } left++; } } return minLen == sLen + 1 ? &quot;&quot; : s.substring(start, start + minLen); } } 力扣438：给定两个字符串s和p，找到s中所有p的异位词的字串，返回这些子串的起始索引。不考虑答案输出的顺序。异位词指由相同字母重排列形成的字符串（包括相同的字符串）。 输入：s = “cbaebabacd”, p = “abc” 输出：[0,6] 解释：起始索引等于 0 的字串是 “cba”，它是 “abc” 的异位词。起始索引等于 6 的字串是 “bac”，它是 “abc” 的异位词。 查看解析 维护一个长度与字符串p的长度相同的滑动窗口，当窗口中每种字母的数量与字符串p中每种字母的数量相同时，则说明当前窗口为字符串p的异位词。 class Solution { public List&lt;Integer&gt; findAnagrams(String s, String p) { int sLen = s.length(), pLen = p.length(); // 当字符串 s 的长度小于字符串 p 的长度时，字符串 s 中一定不存在字符串 p 的异位词 if (sLen &lt; pLen) { return new ArrayList&lt;Integer&gt;(); } List&lt;Integer&gt; ans = new ArrayList&lt;Integer&gt;(); int[] sCount = new int[26]; int[] pCount = new int[26]; for (int i = 0; i &lt; pLen; ++i) { ++sCount[s.charAt(i) - &#39;a&#39;]; ++pCount[p.charAt(i) - &#39;a&#39;]; } if (Arrays.equals(sCount, pCount)) { ans.add(0); } for (int i = 0; i &lt; sLen - pLen; ++i) { --sCount[s.charAt(i) - &#39;a&#39;]; ++sCount[s.charAt(i + pLen) - &#39;a&#39;]; if (Arrays.equals(sCount, pCount)) { ans.add(i + 1); } } return ans; } } 也可以不分别统计滑动窗口和字符串 p 中每种字母的数量，而是统计滑动窗口和字符串 p 中每种字母数量的差，并引入变量 differ 来记录当前窗口与字符串 p 中数量不同的字母的个数。 class Solution { public List&lt;Integer&gt; findAnagrams(String s, String p) { int sLen = s.length(), pLen = p.length(); if (sLen &lt; pLen) { return new ArrayList&lt;Integer&gt;(); } List&lt;Integer&gt; ans = new ArrayList&lt;Integer&gt;(); int[] count = new int[26]; for (int i = 0; i &lt; pLen; ++i) { ++count[s.charAt(i) - &#39;a&#39;]; --count[p.charAt(i) - &#39;a&#39;]; } int differ = 0; for (int j = 0; j &lt; 26; ++j) { if (count[j] != 0) { ++differ; } } if (differ == 0) { ans.add(0); } for (int i = 0; i &lt; sLen - pLen; ++i) { if (count[s.charAt(i) - &#39;a&#39;] == 1) { // 窗口中字母 s[i] 的数量与字符串 p 中的数量从不同变得相同 --differ; } else if (count[s.charAt(i) - &#39;a&#39;] == 0) { // 窗口中字母 s[i] 的数量与字符串 p 中的数量从相同变得不同 ++differ; } --count[s.charAt(i) - &#39;a&#39;]; if (count[s.charAt(i + pLen) - &#39;a&#39;] == -1) { // 窗口中字母 s[i+pLen] 的数量与字符串 p 中的数量从不同变得相同 --differ; } else if (count[s.charAt(i + pLen) - &#39;a&#39;] == 0) { // 窗口中字母 s[i+pLen] 的数量与字符串 p 中的数量从相同变得不同 ++differ; } ++count[s.charAt(i + pLen) - &#39;a&#39;]; if (differ == 0) { ans.add(i + 1); } } return ans; } } 力扣424：给你一个字符串s和一个整数k。你可以选择字符串中的任一字符，并将其更改为任何其他大写英文字符。该操作最多可执行k次。在执行上述操作后，返回包含相同字母的最长子字符串的长度。 输入：s = “ABAB”, k = 2 输出：4 解释：用两个’A’替换为两个’B’，反之亦然。 查看解析 每次滑动窗口右移，更新右移位置的字符出现的次数，然后尝试用它更新重复字符出现次数的历史最大值，最后我们使用该最大值计算出区间内非最长重复字符的数量，以此判断左指针是否需要右移即可，左边界只须要向右移动一格以后，右边界就又可以开始向右移动了，继续尝试找到更长的目标子串。 class Solution { public int characterReplacement(String s, int k) { int[] num = new int[26]; int n = s.length(); int maxn = 0; int left = 0, right = 0; while (right &lt; n) { num[s.charAt(right) - &#39;A&#39;]++; maxn = Math.max(maxn, num[s.charAt(right) - &#39;A&#39;]); if (right - left + 1 - maxn &gt; k) { num[s.charAt(left) - &#39;A&#39;]--; left++; } right++; } return right - left; } } 双指针双指针的问题，通常是两个变量一头一尾，向着中间移动。 力扣15：给你一个包含n个整数的数组nums，判断nums中是否存在三个元素a, b, c，使得a+b+c=0?请你找出所有和为0且不重复的三元组。答案中不能包含重复的三元组。 输入：nums = [-1,-,1,2,-1,-4] 输出：[[-1,-1,2],[-1,0,1]] 查看解析 public class Solution { public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) { List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); int len = nums.length; if (len &lt; 3) { return res; } // 预处理 Arrays.sort(nums); for (int i = 0; i &lt; len - 2; i++) { // 剪枝 2 if (nums[i] &gt; 0) { break; } // 剪枝 3 if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) { continue; } // 在 [i + 1, len - 1] 区间里查找两数之和为 -nums[i] // 因为有序，因此可以可以把 j 和 k 分别从区间的两端向中间靠拢 // 由此省去一个循环 int target = -nums[i]; int left = i + 1; int right = len - 1; while (left &lt; right) { if (nums[left] + nums[right] &lt; target) { left++; } else if (nums[left] + nums[right] &gt; target) { right--; } else { List&lt;Integer&gt; cur = new ArrayList&lt;&gt;(3); cur.add(nums[i]); cur.add(nums[left]); cur.add(nums[right]); res.add(cur); // 剪枝 1: 找到了一个解以后 while (left &lt; right &amp;&amp; nums[left] == nums[left + 1]) { left++; } while (left &lt; right &amp;&amp; nums[right] == nums[right - 1]) { right--; } left++; right--; } } } return res; } } 力扣42：给定n个非负整数表示每个宽度为1的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。 输入：height = [0,1,0,2,1,0,1,3,2,1,2,1] 输出：6 解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水） 查看解析 public class Solution { // 双指针 public int trap(int[] height) { int len = height.length; // 特判 if (len &lt; 3) { return 0; } int res = 0; int leftMax = height[0]; int rightMax = height[len - 1]; // 注意初值的选取，前面做了特判，因此这里不会越界 // 头和尾都不存雨水 int left = 1; int right = len - 2; // 强调：这里是等于 while (left &lt;= right) { // 调试代码 // System.out.println(&quot;left = &quot; + left + &quot; right = &quot; + right + &quot; leftMax = &quot; + leftMax + &quot; rightMax = &quot; + rightMax+ &quot; res = &quot; + res ); int minVal = Math.min(leftMax, rightMax); if (minVal == leftMax) { if (minVal &gt; height[left]) { res += minVal - height[left]; } leftMax = Math.max(leftMax, height[left]); left++; } else { if (minVal &gt; height[right]) { res += minVal - height[right]; } rightMax = Math.max(rightMax, height[right]); right--; } } return res; } } .center { width: auto; display: table; margin-left: auto; margin-right: auto; }","categories":[{"name":"生活","slug":"生活","permalink":"http://goodguyjameswin.github.io/categories/生活/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://goodguyjameswin.github.io/tags/学习笔记/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"http://goodguyjameswin.github.io/categories/生活/"}]},{"title":"text_generator","slug":"text-generator","date":"2022-04-15T04:37:14.000Z","updated":"2022-07-18T04:14:05.237Z","comments":false,"path":"2022/04/15/text-generator/","link":"","permalink":"http://goodguyjameswin.github.io/2022/04/15/text-generator/","excerpt":"","text":"引言用pillow的ImageFont模块去生成可供ocr模型训练的文本检测和识别训练数据，原项目暂时没找到。。 修改引入背景roi 就像上面这张图，有时候场景文本检测和识别任务中，文字只会出现在场景图片特定的语义区域中。因此在制作文本数据时，就需要限定文本出现的范围 调用opencv-python里的api： import cv2 class UseCv: def __init__(self): self.path = &#39;bg.jpg&#39; def cut(self): img = cv2.imread(self.path, flags=cv2.IMREAD_COLOR) bbox = cv2.selectROI(img, False) cut = img[bbox[1]:bbox[1] + bbox[3], bbox[0]:bbox[0] + bbox[2]] cv2.imwrite(&#39;bg_cut.jpg&#39;, cut) 更改： self.roi = cv2.selectROI(cv2.imread(self.bg, 1), False) if x + w &gt; (self.roi[0] + self.roi[2] - 10) or y + h &gt; (self.roi[1]+ self.roi[3] - 10): return draw, (w, h), False tl_x = random.randrange(self.roi[0], self.roi[0] + self.roi[2]) # 字体位置 tl_y = random.randrange(self.roi[1], self.roi[1] + self.roi[3]) 使用命令行调用生成语料： 9CHCAV1 6TXYQ WNVKWX 9OMKKCM5Y X4EPT1J- 9ZG4GB HUTTQRF KDB6TFFP 1ZNKT45E ULR26VPJE 选择roi 运行 结果","categories":[{"name":"技术","slug":"技术","permalink":"http://goodguyjameswin.github.io/categories/技术/"}],"tags":[{"name":"开源项目","slug":"开源项目","permalink":"http://goodguyjameswin.github.io/tags/开源项目/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://goodguyjameswin.github.io/categories/技术/"}]},{"title":"二分查找","slug":"二分查找","date":"2022-04-12T14:15:01.000Z","updated":"2022-07-19T14:02:35.289Z","comments":false,"path":"2022/04/12/二分查找/","link":"","permalink":"http://goodguyjameswin.github.io/2022/04/12/二分查找/","excerpt":"","text":"排除法二分下标// 排除法实现二分查找 public class Solution { public int search(int[] nums, int target) { int len = nums.length; int left = 0; int right = len - 1; // 目标元素可能存在在区间 [left, right] while (left &lt; right) { int mid = left + (right - left) / 2; if (nums[mid] &lt; target) { // 下一轮搜索区间是 [mid + 1, right] left = mid + 1; } else { // 下一轮搜索区间是 [left, mid] right = mid; } // int mid = left + (right - left + 1) / 2; // if (nums[mid] &gt; target) { // // 下一轮搜索区间是 [left, mid - 1] // right = mid - 1; // } else { // // 下一轮搜索区间是 [mid, right] // left = mid; // } } if (nums[left] == target) { return left; } return -1; } } 力扣34：给你一个按照非递减顺序排列的整数数组nums，和一个目标值target。请你找出给定目标值在数组中的开始位置和结束位置。如果数组中不存在目标值target，返回[-1, -1]。 输入：nums = [5,7,7,8,8,10]，target = 8 输出：[3,4] 查看解析 public class Solution { public int[] searchRange(int[] nums, int target) { int len = nums.length; if (len == 0) { return new int[]{-1, -1}; } int firstPosition = searchFirstPosition(nums, target); if (firstPosition == -1) { return new int[]{-1, -1}; } // 能走到这里，一定是数组中存在目标元素 int lastPosition = searchLastPosition(nums, target); return new int[]{firstPosition, lastPosition}; } private int searchLastPosition(int[] nums, int target) { int left = 0; int right = nums.length - 1; while (left &lt; right) { int mid = (left + right + 1) / 2; if (nums[mid] &gt; target) { // mid 以及 mid 的右边一定不是目标元素最后一次出现的位置 // 下一轮搜索的区间是 [left, mid - 1] right = mid - 1; } else { // 下一轮搜索的区间是 [mid, right] left = mid; } } return left; } private int searchFirstPosition(int[] nums, int target) { int left = 0; int right = nums.length - 1; while (left &lt; right) { int mid = (left + right) / 2; if (nums[mid] &lt; target) { // mid 以及 mid 的左边一定不是目标元素第 1 次出现的位置 // 下一轮搜索的区间是 [mid + 1, right] left = mid + 1; } else { // 下一轮搜索的区间是 [left, mid] right = mid; } } if (nums[left] == target) { return left; } return -1; } } 力扣153：已知一个长度为n的数组，预先按照升序排列，经由1到n次旋转后，得到输入数组。例如，原数组nums = [0,1,2,4,5,6,7]在变化后可能得到： 若旋转4次，则可以得到[4,5,6,7,0,1,2] 若旋转7次，则可以得到[0,1,2,4,5,6,7] 注意，数组[a[0], a[1], a[2], ..., a[n-1]]旋转一次 的结果为数组[a[n-1], a[0], a[1], a[2], ..., a[n-2]]给你一个元素值互不相同的数组nums，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的最小元素。 输入：nums = [3,4,5,1,2] 输出：1 解释：原数组为 [1,2,3,4,5]，旋转3次得到输入数组。 查看解析 class Solution { public int findMin(int[] nums) { int low = 0; int high = nums.length - 1; while (low &lt; high) { int pivot = low + (high - low) / 2; // 说明 nums[pivot] 是最小值右侧的元素，因此可以忽略二分查找区间的右半部分 if (nums[pivot] &lt; nums[high]) { high = pivot; } else { // 说明 nums[pivot] 是最小值左侧的元素，因此可以忽略二分查找区间的左半部分 low = pivot + 1; } } return nums[low]; } } 若数组中可能存在重复元素，需要单独讨论： class Solution { public int findMin(int[] nums) { int low = 0; int high = nums.length - 1; while (low &lt; high) { int pivot = low + (high - low) / 2; if (nums[pivot] &lt; nums[high]) { high = pivot; } else if (nums[pivot] &gt; nums[high]) { low = pivot + 1; } else { high -= 1; // 由于 nums[pivot] == nums[high]，因此可以忽略二分查找区间的右端点 } } return nums[low]; } } 力扣33：搜索旋转排序数组 输入：nums = [4,5,6,7,0,1,2]，target = 0 输出：4 查看解析 class Solution { public int search(int[] nums, int target) { int n = nums.length; if (n == 0) { return -1; } if (n == 1) { return nums[0] == target ? 0 : -1; } int l = 0, r = n - 1; while (l &lt;= r) { int mid = (l + r) / 2; if (nums[mid] == target) { return mid; } if (nums[0] &lt;= nums[mid]) { if (nums[0] &lt;= target &amp;&amp; target &lt; nums[mid]) { r = mid - 1; } else { l = mid + 1; } } else { if (nums[mid] &lt; target &amp;&amp; target &lt;= nums[n - 1]) { l = mid + 1; } else { r = mid - 1; } } } return -1; } } 若数组中可能存在重复元素，需要单独讨论： class Solution { public boolean search(int[] nums, int target) { int n = nums.length; if (n == 0) { return false; } if (n == 1) { return nums[0] == target; } int l = 0, r = n - 1; while (l &lt;= r) { int mid = (l + r) / 2; if (nums[mid] == target) { return true; } // 此时可以将当前二分区间的左边界加一，有边界减一，然后在新区间上继续二分查找 if (nums[l] == nums[mid] &amp;&amp; nums[mid] == nums[r]) { ++l; --r; } else if (nums[l] &lt;= nums[mid]) { if (nums[l] &lt;= target &amp;&amp; target &lt; nums[mid]) { r = mid - 1; } else { l = mid + 1; } } else { if (nums[mid] &lt; target &amp;&amp; target &lt;= nums[n - 1]) { l = mid + 1; } else { r = mid - 1; } } } return false; } } 力扣1095：给定一个山脉数组moutainArr，请你返回能够使得mountainArr.get(index)等于target最小的下标index值。如果不存在这样的下标index，则返回-1。 如果数组A是一个山脉数组的话，那它满足如下条件：首先，A.length &gt;= 3，其次，在0 &lt; i &lt; A.length - 1条件下，存在i使得： A[0] &lt; A[1] &lt; … A[i-1] &lt; A[i] A[i] &gt; A[i+1] &gt; … &gt; A[A.length - 1] 你将不能直接访问该山脉数组，必须通过MountainArray接口来获取数据： MountainArray.get(k) - 会返回数组中索引为k的元素（下标从0开始） MountainArray.length() - 会返回该数组的长度 输入：array = [1,2,3,4,5,3,1], target = 3 输出：2 解释：3 在数组中出现了两次，下标分别为 2 和 5，我们返回最小的下标 2。 查看解析 class Solution { public int findInMountainArray(int target, MountainArray mountainArr) { int l = 0, r = mountainArr.length() - 1; // 先寻找“山峰” while (l &lt; r) { int mid = (l + r) / 2; if (mountainArr.get(mid) &lt; mountainArr.get(mid + 1)) { l = mid + 1; } else { r = mid; } } int peak = l; // 山峰两侧即为有序数组，可直接进行二分查找 int index = binarySearch(mountainArr, target, 0, peak, true); if (index != -1) { return index; } return binarySearch(mountainArr, target, peak + 1, mountainArr.length() - 1, false); } public int binarySearch(MountainArray mountainArr, int target, int l, int r, boolean flag) { if (!flag) { target *= -1; } while (l &lt;= r) { int mid = (l + r) / 2; int cur = mountainArr.get(mid) * (flag ? 1 : -1); if (cur == target) { return mid; } else if (cur &lt; target) { l = mid + 1; } else { r = mid - 1; } } return -1; } } 力扣4：给定两个大小分别为m和n的正序（从小到大）数组nums1和nums2。请你找出并返回这两个正序数组的中位数。 输入：nums1 = [1,3], nums2 = [2] 输出：2.00000 解释：合并数组 = [1,2,3], 中位数 2 查看解析 class Solution { public double findMedianSortedArrays(int[] nums1, int[] nums2) { int length1 = nums1.length, length2 = nums2.length; int totalLength = length1 + length2; if (totalLength % 2 == 1) { int midIndex = totalLength / 2; double median = getKthElement(nums1, nums2, midIndex + 1); return median; } else { int midIndex1 = totalLength / 2 - 1, midIndex2 = totalLength / 2; double median = (getKthElement(nums1, nums2, midIndex1 + 1) + getKthElement(nums1, nums2, midIndex2 + 1)) / 2.0; return median; } } public int getKthElement(int[] nums1, int[] nums2, int k) { /* 要找到第 k (k&gt;1) 小的元素，那么就取 pivot1 = nums1[k/2-1] 和 pivot2 = nums2[k/2-1] 进行比较 * 这里的 &quot;/&quot; 表示整除 * nums1 中小于等于 pivot1 的元素有 nums1[0 .. k/2-2] 共计 k/2-1 个 * nums2 中小于等于 pivot2 的元素有 nums2[0 .. k/2-2] 共计 k/2-1 个 * 取 pivot = min(pivot1, pivot2)，两个数组中小于等于 pivot 的元素共计不会超过 (k/2-1) + (k/2-1) &lt;= k-2 个 * 这样 pivot 本身最大也只能是第 k-1 小的元素 * 如果 pivot = pivot1，那么 nums1[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 &quot;删除&quot;，剩下的作为新的 nums1 数组 * 如果 pivot = pivot2，那么 nums2[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 &quot;删除&quot;，剩下的作为新的 nums2 数组 * 由于我们 &quot;删除&quot; 了一些元素（这些元素都比第 k 小的元素要小），因此需要修改 k 的值，减去删除的数的个数 */ int length1 = nums1.length, length2 = nums2.length; int index1 = 0, index2 = 0; int kthElement = 0; while (true) { // 边界情况 if (index1 == length1) { return nums2[index2 + k - 1]; } if (index2 == length2) { return nums1[index1 + k - 1]; } if (k == 1) { return Math.min(nums1[index1], nums2[index2]); } // 正常情况 int half = k / 2; int newIndex1 = Math.min(index1 + half, length1) - 1; int newIndex2 = Math.min(index2 + half, length2) - 1; int pivot1 = nums1[newIndex1], pivot2 = nums2[newIndex2]; if (pivot1 &lt;= pivot2) { k -= (newIndex1 - index1 + 1); index1 = newIndex1 + 1; } else { k -= (newIndex2 - index2 + 1); index2 = newIndex2 + 1; } } } } 二分答案如果题目要求一个整数，并且知晓这个整数它可能的最小值和最大值时，可以考虑使用二分查找算法找到这个目标值。 力扣1300：给你一个整数数组arr和一个目标值target，请你返回一个整数value，使得将数组中所有大于value的值变成value后，数组的和最接近target（最接近表示两者之差的绝对值最小）。 如果有多种使得和最接近target的方案，请你返回这些整数中的最小值。 请注意，答案不一定是arr中的数字。 输入：arr = [4,9,3], target = 10 输出：3 解释：当选择 value 为 3 时，数组会变成 [3,3,3]，和为 9，这是最接近 target 的方案。 查看解析 class Solution { public int findBestValue(int[] arr, int target) { Arrays.sort(arr); int n = arr.length; int[] prefix = new int[n + 1]; for (int i = 1; i &lt;= n; ++i) { prefix[i] = prefix[i - 1] + arr[i - 1]; } int l = 0, r = arr[n - 1], ans = -1; while (l &lt;= r) { int mid = (l + r) / 2; int index = Arrays.binarySearch(arr, mid); if (index &lt; 0) { index = -index - 1; } int cur = prefix[index] + (n - index) * mid; if (cur &lt;= target) { ans = mid; l = mid + 1; } else { r = mid - 1; } } // 在 [0,max(arr)] 的范围之内，随着 value 的增大，数组的和是严格单调递增的，因此可以通过二分查找的方式找到最接近且不大于 target 和最接近且大于 target 的两个数，显然后者等于前者加一，取两者中最接近 target 的值即为答案 int chooseSmall = check(arr, ans); int chooseBig = check(arr, ans + 1); return Math.abs(chooseSmall - target) &lt;= Math.abs(chooseBig - target) ? ans : ans + 1; } public int check(int[] arr, int x) { int ret = 0; for (int num : arr) { ret += Math.min(num, x); } return ret; } } 还有一类问题是根据目标变量具有的单调性质编写判别函数。目标变量和另一个变量有相关关系（一般而言是线性关系），目标变量的性质不好推测，但是另一个变量的性质相对容易推测。这样的问题的判别函数通常会写成一个函数的形式。 力扣410：给定一个非负整数数组nums和一个整数m，你需要将这个数组分成m个非空的连续子数组。 设计一个算法使得这m个子数组各自和的最大值最小。 输入：nums = [7,2,5,10,8], m = 2 输出：18 解释：一共有四种方法将 nums 分割为 2 个子数组。其中最好的方式是将其分为 [7,2,5] 和 [10,8]。因为此时这两个子数组各自的和的最大值为 18，在所有情况中最小。 查看解析 public class Solution { public int splitArray(int[] nums, int m) { int max = 0; int sum = 0; // 计算「子数组各自的和的最大值」的上下界 for (int num : nums) { max = Math.max(max, num); sum += num; } // 使用「二分查找」确定一个恰当的「子数组各自的和的最大值」，使得它对应的「子数组的分割数」恰好等于 m int left = max; int right = sum; while (left &lt; right) { int mid = left + (right - left) / 2; int splits = split(nums, mid); if (splits &gt; m) { // 如果分割数太多，说明「子数组各自的和的最大值」太小，此时需要将「子数组各自的和的最大值」调大 // 下一轮搜索的区间是 [mid + 1, right] left = mid + 1; } else { // 下一轮搜索的区间是上一轮的反面区间 [left, mid] right = mid; } } return left; } /*** * * @param nums 原始数组 * @param maxIntervalSum 子数组各自的和的最大值 * @return 满足不超过「子数组各自的和的最大值」的分割数 */ private int split(int[] nums, int maxIntervalSum) { // 至少是一个分割 int splits = 1; // 当前区间的和 int curIntervalSum = 0; for (int num : nums) { // 尝试加上当前遍历的这个数，如果加上去超过了「子数组各自的和的最大值」，就不加这个数，另起炉灶 if (curIntervalSum + num &gt; maxIntervalSum) { curIntervalSum = 0; splits++; } curIntervalSum += num; } return splits; } } 力扣287：给定一个包含n + 1个整数的数组nums，其数字都在[1, n]范围内（包括1和n），可知至少存在一个重复的整数。假设nums只有一个重复的整数，返回这个重复的数。 输入：nums = [1,3,4,2,2] 输出：2 查看解析 class Solution { // 定义 cnt[i] 表示 nums 数组中小于等于 i 的数有多少个，cnt[] 数组随数字 i 逐渐增大具有单调性 public int findDuplicate(int[] nums) { int n = nums.length; int l = 1, r = n - 1, ans = -1; while (l &lt;= r) { int mid = (l + r) &gt;&gt; 1; int cnt = 0; for (int i = 0; i &lt; n; ++i) { if (nums[i] &lt;= mid) { cnt++; } } if (cnt &lt;= mid) { l = mid + 1; } else { r = mid - 1; ans = mid; } } return ans; } } .center { width: auto; display: table; margin-left: auto; margin-right: auto; }","categories":[{"name":"思维","slug":"思维","permalink":"http://goodguyjameswin.github.io/categories/思维/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://goodguyjameswin.github.io/tags/学习笔记/"}],"keywords":[{"name":"思维","slug":"思维","permalink":"http://goodguyjameswin.github.io/categories/思维/"}]},{"title":"yolo_icdar","slug":"yolo_icdar","date":"2022-04-10T12:30:01.000Z","updated":"2022-07-18T03:40:24.305Z","comments":false,"path":"2022/04/10/yolo_icdar/","link":"","permalink":"http://goodguyjameswin.github.io/2022/04/10/yolo_icdar/","excerpt":"","text":"引言第一篇文章（水文）！研一参与的第一个项目，用yolo来检测（识别）图片中的喷码字符，然后很长一段时间都在给数据打标签 问题在于用yolo去做逐字符的检测，输出的框顺序并不像我们所认知的那样，分行排列，从上至下，从左至右 yolo格式标签&lt;object-class&gt; &lt;x&gt; &lt;y&gt; &lt;width&gt; &lt;height&gt; x，y是检测框的中心坐标；width，height是检测框的宽和高。这些坐标是通过归一化的，其中x，width是使用原图的width进行归一化；而y，height是使用原图的height进行归一化 icdar格式标签path/to/img [{&quot;transcription&quot;: &quot;content&quot;, &quot;points&quot;: [[x1, y1], [x2, y2], [x3, y3], [x4, y4]]}, {...}] 标签是包含多个字典的list，字典中的 points 表示文本框的四个点的坐标(x, y)，从左上角的点开始顺时针排列。 transcription 表示当前文本框的内容 实现把问题转换为对yolo输出检测框的排序。已知量是每个检测框的横、纵坐标，思路是先把所有检测框按纵坐标分成不同行，每行再按横坐标排序 原先的项目数据里，待识别的图片样式基本不变，可以直接在界面里设置每行文本的字符个数，当时的代码就是直接根据这一条件来对检测框排序。然后就检测条形码和二维码去了 后来项目的数据样式变多了，感觉原来的方法行不通了，最近在用paddleocr做文本识别，需要把以前训练yolo的一些数据标签转成icdar格式，所以又要重新面对这个yolo检测框的排序问题，那就趁着这个机会把代码写清楚 自然断点法a = np.array([5, 35, 38, 41, 65, 68, 98, 99, 100, 99, 105, 106, 102, 104, 103, 100, 110, 69, 64, 70, 75, 71, 73, 72, 42, 46, 40, 36, 37, 6, 8, 11, 4, 15, 10, 9, 4, 8, 135]) 思路还是先把检测框按纵坐标分行，想了半天，放弃 后来在pycharm里边写代码边debug，发现对数组View as Array的时候有个Colored cells选项，可以把一维数组分块，联想到yolo检测框按纵坐标分行，然后上网去搜有没有一维数组的聚类方法 发现可以用python的机器学习算法库里一个叫核密度估计的方法，实现对多维数据分布规律的曲线模拟。那把一维数组扩充到多维不就好了？（大材小用），搜了下这个库的调用方法 a = np.array([5, 35, 38, 41, 65, 68, 98, 99, 100, 99, 105, 106, 102, 104, 103, 100, 110, 69, 64, 70, 75, 71, 73, 72, 42, 46, 40, 36, 37, 6, 8, 11, 4, 15, 10, 9, 4, 8, 135]).reshape(-1, 1) kde = KernelDensity(kernel=&#39;gaussian&#39;, bandwidth=3).fit(a[:, 0].reshape(-1, 1)) # 构造指定数据的核密度估计 s = np.linspace(0, 140) e = kde.score_samples(s.reshape(-1, 1)) # 在特定数据上用核函数拟合 观察了下拟合出来的曲线，确实求个极值就可以找到断点了 mi, ma = argrelextrema(e, np.less)[0], argrelextrema(e, np.greater)[0] # 计算数组指定轴的相对极值 Minima: [25.71428571 54.28571429 85.71428571 122.85714286] Maxima: [8.57142857 37.14285714 71.42857143 100. 134.28571429] 然后根据断点把一维数组分块，还行 [5 6 8 11 4 15 10 9 4 8] [35 38 41 42 46 40 36 37] [65 68 69 64 70 75 71 73 72] [98 99 100 99 105 106 102 104 103 100 110] [135] 后话最后整合到标签转换脚本里去，转换速度还行。。吧 这样就可以用上学长的data_maker了哈哈哈 虽然我个人倾向于用python的pillow库函数ImageFont来制作字符数据，但是喷码样式的字体文件着实不好搞，字符贴图的背景区域定位那块代码也一直想吐槽，之后抽个时间优化下吧，顺便再水一篇文章","categories":[{"name":"技术","slug":"技术","permalink":"http://goodguyjameswin.github.io/categories/技术/"}],"tags":[{"name":"开源项目","slug":"开源项目","permalink":"http://goodguyjameswin.github.io/tags/开源项目/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://goodguyjameswin.github.io/categories/技术/"}]}]}