{"meta":{"title":"zt's blog","subtitle":null,"description":"没有记流水帐的习惯~","author":"Terry Joe","url":"http://goodguyjameswin.github.io"},"pages":[{"title":"","date":"2021-09-02T07:22:26.499Z","updated":"2021-09-02T07:21:51.283Z","comments":true,"path":"404.html","permalink":"http://goodguyjameswin.github.io/404.html","excerpt":"","text":"页面没有找到 | zt's Blog body { background: #00c4b6; } #not_found { position: fixed; top: 50%; left: 50%; transform: translateY(-50%) translateX(-50%) scale(1.2); width: 80%; height: auto; } (function () { var lastTime = 0; var vendors = ['ms', 'moz', 'webkit', 'o']; for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) { window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame']; window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] || window[vendors[x] + 'CancelRequestAnimationFrame']; } if (!window.requestAnimationFrame) window.requestAnimationFrame = function (callback, element) { var currTime = new Date().getTime(); var timeToCall = Math.max(0, 16 - (currTime - lastTime)); var id = window.setTimeout(function () { callback(currTime + timeToCall); }, timeToCall); lastTime = currTime + timeToCall; return id; }; if (!window.cancelAnimationFrame) window.cancelAnimationFrame = function (id) { clearTimeout(id); }; })(); //math2 utils var Math2 = {}; Math2.random = function (t, n) { return Math.random() * (n - t) + t; }, Math2.map = function (t, n, r, a, o) { return (o - a) * ((t - n) / (r - n)) + a; }, Math2.randomPlusMinus = function (t) { return t = t ? t : .5, Math.random() > t ? -1 : 1; }, Math2.randomInt = function (t, n) { return n += 1, Math.floor(Math.random() * (n - t) + t); }, Math2.randomBool = function (t) { return t = t ? t : .5, Math.random() < t ? !0 : !1; }, Math2.degToRad = function (t) { return rad = t * Math.PI / 180, rad; }, Math2.radToDeg = function (t) { return deg = 180 / (Math.PI * t), deg; }, Math2.rgbToHex = function (t) { function n(t) { return (\"0\" + parseInt(t).toString(16)).slice(-2); } t = t.match(/^rgb((d+),s*(d+),s*(d+))$/); var r = n(t[1]) + n(t[2]) + n(t[3]); return r.toUpperCase(); }, Math2.distance = function (t, n, r, a) { return Math.sqrt((r - t) * (r - t) + (a - n) * (a - n)); }; //mouse var mousePos = { x: 0, y: 0 }; window.onmousemove = function (e) { e = e || window.event; var pageX = e.pageX; var pageY = e.pageY; if (pageX === undefined) { pageX = e.clientX + document.body.scrollLeft + document.documentElement.scrollLeft; pageY = e.clientY + document.body.scrollTop + document.documentElement.scrollTop; } mousePos = { x: pageX, y: pageY }; }; var options = { width: window.innerWidth, height: window.innerHeight, keyword: \"404\", density: 10, densityText: 3, minDist: 20 }; // initialize canvas var canvas = document.createElement('canvas'); canvas.width = options.width; canvas.height = options.height; canvas.style.width = options.width / 2; canvas.style.height = options.height / 2; canvas.getContext('2d').scale(2, 2); var renderer = new PIXI.autoDetectRenderer(options.width, options.height, { transparent: true }); var stage = new PIXI.Stage(\"0X000000\", true); document.body.appendChild(renderer.view); renderer.view.id = \"not_found\"; var imageData = false; var particles = []; function init() { positionParticles(); positionText(); } function positionParticles() { var canvas = document.createElement(\"canvas\"); canvas.width = 500; canvas.height = 350; var context = canvas.getContext(\"2d\"); context.fillStyle = \"#000000\"; context.font = \"300px 'Arial', sans-serif\"; context.fillText(options.keyword, 0, 250); var imageData = context.getImageData(0, 0, 350, 500); data = imageData.data; // Iterate each row and column for (var i = 0; i < imageData.height; i += options.density) { for (var j = 0; j < imageData.width; j += options.density) { // Get the color of the pixel var color = data[j * (imageData.width * 4) + i * 4 - 1]; // If the color is black, draw pixels if (color == 255) { var newPar = particle(); newPar.setPosition(i, j); particles.push(newPar); stage.addChild(newPar); } } } } function positionText() { var canvas = document.createElement(\"canvas\"); canvas.width = 400; canvas.height = 200; var context = canvas.getContext(\"2d\"); context.fillStyle = \"#000000\"; context.font = \"80px 'Arial', sans-serif\"; context.fillText(\"Not Found\", 0, 80); var imageData = context.getImageData(0, 0, 400, 400); data = imageData.data; // Iterate each row and column for (var i = 0; i < imageData.height; i += options.densityText) { for (var j = 0; j < imageData.width; j += options.densityText) { // Get the color of the pixel var color = data[j * (imageData.width * 4) + i * 4 - 1]; // If the color is black, draw pixels if (color == 255) { var newPar = particle(true); newPar.setPosition(i, j); particles.push(newPar); stage.addChild(newPar); } } } } function particle(text) { $this = new PIXI.Graphics(); if (text == true) { $this.text = true; } $this.beginFill(0XFFFFFF); var radius; $this.radius = radius = $this.text ? Math.random() * 3.5 : Math.random() * 10.5; $this.drawCircle(0, 0, radius); $this.size = this.radius; $this.x = -this.width; $this.y = -this.height; $this.free = false; $this.timer = Math2.randomInt(0, 100); $this.v = Math2.randomPlusMinus() * Math2.random(.5, 1); $this.hovered = false; $this.alpha = Math2.randomInt(10, 100) / 100; $this.vy = -5 + parseInt(Math.random() * 10) / 2; $this.vx = -4 + parseInt(Math.random() * 8); $this.setPosition = function (x, y) { if ($this.text) { $this.x = x + (options.width / 2 - 180); $this.y = y + (options.height / 2 + 100); } else { $this.x = x + (options.width / 2 - 250); $this.y = y + (options.height / 2 - 175); } }; return $this; } function update() { renderer.render(stage); for (i = 0; i < particles.length; i++) { var p = particles[i]; if (mousePos.x > p.x && mousePos.x < p.x + p.size && mousePos.y > p.y && mousePos.y < p.y + p.size) { p.hovered = true; } p.scale.x = p.scale.y = scale = Math.max(Math.min(2.5 - Math2.distance(p.x, p.y, mousePos.x, mousePos.y) / 160, 160), 1); p.x = p.x + .2 * Math.sin(p.timer * .15); p.y = p.y + .2 * Math.cos(p.timer * .15); p.timer = p.timer + p.v; } window.requestAnimationFrame(update); } init(); update();"},{"title":"bangumi","date":"2021-09-04T13:32:48.000Z","updated":"2021-09-08T00:52:34.864Z","comments":false,"path":"bangumi/index.html","permalink":"http://goodguyjameswin.github.io/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"about","date":"2021-09-04T14:14:36.000Z","updated":"2021-09-08T00:52:21.259Z","comments":false,"path":"about/index.html","permalink":"http://goodguyjameswin.github.io/about/index.html","excerpt":"","text":"[WHUTのTerryJoe] 与&nbsp; Kirito&nbsp; （ Asuna ） 对话中... bot_ui_ini()","keywords":"关于我"},{"title":"categories","date":"2021-09-04T16:40:09.000Z","updated":"2021-09-11T09:08:23.098Z","comments":false,"path":"categories/index.html","permalink":"http://goodguyjameswin.github.io/categories/index.html","excerpt":"","text":"","keywords":"分类图"},{"title":"comment","date":"2021-09-04T15:13:48.000Z","updated":"2021-09-08T00:52:58.243Z","comments":true,"path":"comment/index.html","permalink":"http://goodguyjameswin.github.io/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"rss","date":"2021-09-04T15:09:03.000Z","updated":"2021-09-08T00:53:21.547Z","comments":true,"path":"rss/index.html","permalink":"http://goodguyjameswin.github.io/rss/index.html","excerpt":"","text":""},{"title":"links","date":"2021-09-04T15:11:06.000Z","updated":"2021-10-07T02:55:28.044Z","comments":false,"path":"links/index.html","permalink":"http://goodguyjameswin.github.io/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"music","date":"2021-09-04T15:14:28.000Z","updated":"2021-10-07T08:23:31.367Z","comments":false,"path":"music/index.html","permalink":"http://goodguyjameswin.github.io/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"tags","date":"2021-09-05T15:13:48.000Z","updated":"2021-09-11T09:08:30.171Z","comments":false,"path":"tags/index.html","permalink":"http://goodguyjameswin.github.io/tags/index.html","excerpt":"","text":"","keywords":"标签云"},{"title":"video","date":"2021-09-04T15:14:38.000Z","updated":"2021-09-08T00:53:48.250Z","comments":false,"path":"video/index.html","permalink":"http://goodguyjameswin.github.io/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"}],"posts":[{"title":"贪心","slug":"贪心","date":"2022-06-23T13:24:26.000Z","updated":"2022-07-18T03:58:46.410Z","comments":false,"path":"2022/06/23/贪心/","link":"","permalink":"http://goodguyjameswin.github.io/2022/06/23/贪心/","excerpt":"","text":"","categories":[{"name":"生活","slug":"生活","permalink":"http://goodguyjameswin.github.io/categories/生活/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://goodguyjameswin.github.io/tags/学习笔记/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"http://goodguyjameswin.github.io/categories/生活/"}]},{"title":"并查集","slug":"并查集","date":"2022-06-17T10:43:27.000Z","updated":"2022-07-18T03:51:38.795Z","comments":false,"path":"2022/06/17/并查集/","link":"","permalink":"http://goodguyjameswin.github.io/2022/06/17/并查集/","excerpt":"","text":"","categories":[{"name":"生活","slug":"生活","permalink":"http://goodguyjameswin.github.io/categories/生活/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://goodguyjameswin.github.io/tags/学习笔记/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"http://goodguyjameswin.github.io/categories/生活/"}]},{"title":"shape_based_matching","slug":"shape_based_matching","date":"2022-06-15T02:13:12.000Z","updated":"2022-07-18T03:51:28.272Z","comments":false,"path":"2022/06/15/shape_based_matching/","link":"","permalink":"http://goodguyjameswin.github.io/2022/06/15/shape_based_matching/","excerpt":"","text":"环境配置新建VS空工程，然后在VS-视图-属性管理器，配置opencv环境，VC++目录-包含目录添加： ..\\opencv\\build\\include ..\\opencv\\build\\include\\opencv ..\\opencv\\build\\include\\opencv2 VC++目录-库目录添加： ..\\opencv\\build\\x64\\vc15\\lib 链接器-输入-附加依赖项添加： opencv_world346d.lib 将原工程根目录下的源文件和头文件添加到新建VS工程里，修改fusion.h和line2Dup.h文件里的路径： #include &quot;MIPP/mipp.h&quot; // for SIMD in different platforms 修改test.cpp里的prefix变量路径，指向资源文件： static std::string prefix = &quot;../test/&quot;; api调用原作者分别对模板做了角度、尺度方面的测试，以及noise_test（NMS筛选）。这里假设模板是工业器件，且由于拍摄角度和器件摆放位置的随机性，需要简单写个my_test函数来调用api void my_test(string mode = &quot;test&quot;, bool use_rot = true) { int num_feature = 16; // 特征点数量 line2Dup::Detector detector(num_feature, { 4, 8 }); if (mode != &quot;test&quot;) { Mat img = imread(prefix + &quot;case3/train.jpg&quot;); // 训练图片 assert(!img.empty() &amp;&amp; &quot;check your img path&quot;); // crop the template from the original train image Rect roi(90, 35, 65, 35); img = img(roi).clone(); Mat mask = Mat(img.size(), CV_8UC1, { 255 }); // padding to avoid rotating out int padding = 25; cv::Mat padded_img = cv::Mat(img.rows + 2 * padding, img.cols + 2 * padding, img.type(), cv::Scalar::all(0)); img.copyTo(padded_img(Rect(padding, padding, img.cols, img.rows))); cv::Mat padded_mask = cv::Mat(mask.rows + 2 * padding, mask.cols + 2 * padding, mask.type(), cv::Scalar::all(0)); mask.copyTo(padded_mask(Rect(padding, padding, img.cols, img.rows))); shape_based_matching::shapeInfo_producer shapes(padded_img, padded_mask); shapes.angle_range = { 0, 360 }; // 模板库尺度范围 shapes.angle_step = 1; // 模板库尺度步长 shapes.scale_range = { 0.5f, 1.5f }; // 模板库角度范围 shapes.scale_step = 0.1f; // 模板库角度步长 //shapes.scale_range = { 1.0f }; shapes.produce_infos(); std::vector&lt;shape_based_matching::shapeInfo_producer::Info&gt; infos_have_templ; string class_id = &quot;gongjian&quot;; // 模板类名 bool is_first = true; // for other scales you want to re-extract points: // set shapes.scale_range then produce_infos; set is_first = false; int first_id = 0; float first_angle = 0; float first_scale = 0; for (auto&amp; info : shapes.infos) { Mat to_show = shapes.src_of(info); /********************/ // 通用场景 std::cout &lt;&lt; &quot;\\ninfo.angle: &quot; &lt;&lt; info.angle &lt;&lt; std::endl; int templ_id = detector.addTemplate(shapes.src_of(info), class_id, shapes.mask_of(info), int(num_feature * info.scale)); // todo: 模板图尺度没有变化的场景 //（第一次需要成功记录模板，尽量保证模板完整，轮廓层次分明） //（如果报错数组越界，先尝试改善模板图片质量，不行再尝试调小num_feature的值，但建议至少为8） /*std::cout &lt;&lt; &quot;\\ninfo.angle: &quot; &lt;&lt; info.angle &lt;&lt; std::endl; int templ_id; if (is_first) { templ_id = detector.addTemplate(shapes.src_of(info), class_id, shapes.mask_of(info), int(num_feature * info.scale)); first_id = templ_id; first_angle = info.angle; first_scale = info.scale; if (use_rot) is_first = false; } else { templ_id = detector.addTemplate_rotate(class_id, first_id, info.angle - first_angle, { shapes.src.cols / 2.0f, shapes.src.rows / 2.0f }); }*/ /********************/ std::cout &lt;&lt; &quot;templ_id: &quot; &lt;&lt; templ_id &lt;&lt; std::endl; if (templ_id != -1) { auto templ = detector.getTemplates(&quot;gongjian&quot;, templ_id); for (int i = 0; i &lt; templ[0].features.size(); i++) { auto feat = templ[0].features[i]; cv::circle(to_show, { feat.x + templ[0].tl_x, feat.y + templ[0].tl_y }, 3, { 0, 0, 255 }, -1); } infos_have_templ.push_back(info); // will be faster if not showing this imshow(&quot;train&quot;, to_show); waitKey(1); } if (fabs(info.scale - first_scale) &gt; 0.002f) { is_first = true; std::cout &lt;&lt; &quot;info_scale: &quot; &lt;&lt; info.scale &lt;&lt; std::endl; } } detector.writeClasses(prefix + &quot;case3/%s_templ.yaml&quot;); // 模板库 shapes.save_infos(infos_have_templ, prefix + &quot;case3/gongjian_info.yaml&quot;); // 模板信息 std::cout &lt;&lt; &quot;train end&quot; &lt;&lt; std::endl &lt;&lt; std::endl; } else if (mode == &quot;test&quot;) { std::vector&lt;std::string&gt; ids; ids.push_back(&quot;gongjian&quot;); detector.readClasses(ids, prefix + &quot;case3/%s_templ.yaml&quot;); // angle &amp; scale are saved here, fetched by match id auto infos = shape_based_matching::shapeInfo_producer::load_infos(prefix + &quot;case3/gongjian_info.yaml&quot;); Mat test_img = imread(prefix + &quot;case3/ori.jpg&quot;); // 测试图片 assert(!test_img.empty() &amp;&amp; &quot;check your img path&quot;); // padding to avoid rotating out int padding = 150; cv::Mat padded_img = cv::Mat(test_img.rows + 2 * padding, test_img.cols + 2 * padding, test_img.type(), cv::Scalar::all(0)); test_img.copyTo(padded_img(Rect(padding, padding, test_img.cols, test_img.rows))); int stride = 32; int n = padded_img.rows / stride; int m = padded_img.cols / stride; Rect roi(0, 0, stride * m, stride * n); Mat img = padded_img(roi).clone(); assert(img.isContinuous()); // cvtColor(img, img, CV_BGR2GRAY); // todo:训练模板用灰度图，测试图片也用灰度图，然后观察推理速度和效果 std::cout &lt;&lt; &quot;test img size: &quot; &lt;&lt; img.rows * img.cols &lt;&lt; std::endl &lt;&lt; std::endl; // check time span auto start_time = GetTickCount(); //Timer timer; auto matches = detector.match(img, 90, ids); // 匹配阈值 //timer.out(); std::cout &lt;&lt; &quot;matches.size(): &quot; &lt;&lt; matches.size() &lt;&lt; std::endl; vector&lt;Rect&gt; boxes; vector&lt;float&gt; scores; vector&lt;int&gt; idxs; for (auto match : matches) { Rect box; box.x = match.x; box.y = match.y; auto templ = detector.getTemplates(&quot;gongjian&quot;, match.template_id); box.width = templ[0].width; box.height = templ[0].height; boxes.push_back(box); scores.push_back(match.similarity); } cv_dnn::NMSBoxes(boxes, scores, 90, 0, idxs); // 筛选阈值 auto end_time = GetTickCount(); cout &lt;&lt; &quot;匹配算法耗时：&quot; &lt;&lt; (end_time - start_time) &lt;&lt; &quot;ms.&quot; &lt;&lt; endl; if (img.channels() == 1) cvtColor(img, img, CV_GRAY2BGR); for (auto idx : idxs) { auto match = matches[idx]; /*size_t top5 = 10; if (top5 &gt; matches.size()) top5 = matches.size(); for (size_t i = 0; i &lt; top5; i++) { auto match = matches[i];*/ auto templ = detector.getTemplates(&quot;gongjian&quot;, // 读取训练好的模板类 match.template_id); // 65 is width of template image, 35 is height of template image // 25 is padding when training // tl_x/y: template croping topleft corner when training float x_scaled = 60 / 2.0f * infos[match.template_id].scale; float y_scaled = 35 / 2.0f * infos[match.template_id].scale; // scaling won&#39;t affect this, because it has been determined by warpAffine // cv::warpAffine(src, dst, rot_mat, src.size()); last param float train_img_half_width = 60 / 2.0f + 25; float train_img_half_height = 35 / 2.0f + 25; // center x,y of train_img in test img float x = match.x - templ[0].tl_x + train_img_half_width; float y = match.y - templ[0].tl_y + train_img_half_height; cv::Vec3b randColor; randColor[0] = rand() % 155 + 100; randColor[1] = rand() % 155 + 100; randColor[2] = rand() % 155 + 100; for (int i = 0; i &lt; templ[0].features.size(); i++) { auto feat = templ[0].features[i]; cv::circle(img, { feat.x + match.x, feat.y + match.y }, 3, randColor, -1); } cv::putText(img, to_string(int(round(match.similarity))), Point(match.x + x_scaled - 10, match.y - 3), FONT_HERSHEY_PLAIN, 2, randColor); cv::RotatedRect rotatedRectangle({ x, y }, { 2 * x_scaled, 2 * y_scaled }, -infos[match.template_id].angle); cv::Point2f vertices[4]; rotatedRectangle.points(vertices); for (int i = 0; i &lt; 4; i++) { int next = (i + 1 == 4) ? 0 : (i + 1); cv::line(img, vertices[i], vertices[next], randColor, 2); } std::cout &lt;&lt; &quot;\\nmatch.template_id: &quot; &lt;&lt; match.template_id &lt;&lt; std::endl; std::cout &lt;&lt; &quot;match.similarity: &quot; &lt;&lt; match.similarity &lt;&lt; std::endl; } imshow(&quot;img&quot;, img); waitKey(0); std::cout &lt;&lt; &quot;test end&quot; &lt;&lt; std::endl &lt;&lt; std::endl; } } 效果训练 测试","categories":[{"name":"技术","slug":"技术","permalink":"http://goodguyjameswin.github.io/categories/技术/"}],"tags":[{"name":"开源项目","slug":"开源项目","permalink":"http://goodguyjameswin.github.io/tags/开源项目/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://goodguyjameswin.github.io/categories/技术/"}]},{"title":"mybatis-plus学习","slug":"mybatis-plus学习","date":"2022-06-10T08:16:21.000Z","updated":"2022-07-18T03:58:34.891Z","comments":false,"path":"2022/06/10/mybatis-plus学习/","link":"","permalink":"http://goodguyjameswin.github.io/2022/06/10/mybatis-plus学习/","excerpt":"","text":"构建工程Mybatis-Plus中文文档 入门新建Maven父工程，导入依赖： &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.24&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.h2database&lt;/groupId&gt; &lt;artifactId&gt;h2&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; resources目录下新建application.yml配置文件中添加H2数据库的相关配置： # DataSource Config spring: datasource: driver-class-name: org.h2.Driver schema: classpath:db/schema=h2.sql data: classpath:db/data-h2.sql url: jdbc:h2:mem:test username: root password: test 在 Spring Boot 启动类中添加 @MapperScan 注解，扫描 Mapper 文件夹： @SpringBootApplication @MapperScan(&quot;scan.your.mapper.package&quot;) public class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); } } Mapper包下的UserMapper接口只需要继承BaseMapper&lt;T&gt;类即可（泛型指定封装数据类型） 配置日志mybatis-plus: configuration: log-impl: org.apache.ibatis.logging.stdout.StdOutImpl 主键策略主键注解@TableId(&quot;AUTO&quot;)，设置数据库ID自增，用在实体类的主键字段，数据库对应列也应当设置为自增 自动填充功能注解填充字段 @TableField(.. fill = FieldFill.INSERT) public class User { @TableField(fill = FieldFill.INSERT) private String createTime; @TableField(fill = FieldFill.INSERT_UPDATE) private String updateTime; ... } 实现元对象处理器接口：com.baomidou.mybatisplus.core.handlers.MetaObjectHandler @Slf4j @Component public class MyMetaObjectHandler implements MetaObjectHandler { @Override public void insertFill(MetaObject metaObject) { log.info(&quot;start insert fill ....&quot;); this.setFieldValByName(&quot;createTime&quot;, new Date(), metaObject); this.setFieldValByName(&quot;updateTime&quot;, new Date(), metaObject) } @Override public void updateFill(MetaObject metaObject) { log.info(&quot;start update fill ....&quot;); this.setFieldValByName(&quot;updateTime&quot;, new Date(), metaObject) } } 乐观锁当要更新一条记录时，希望这条记录没有被别人更新，实现方式为： 去除记录时，获取当前version 更新时，带上这个 version 执行更新时， set version = newVersion where version = oldVersion 如果 version 不对，就更新失败 @Configuration @MapperScan(&quot;scan.your.mapper.package&quot;) public class MybatisPlusConfig { @Bean public MybatisPlusInterceptor mybatisPlusInterceptor() { MybatisPlusInterceptor mybatisPlusInterceptor = new MybatisPlusInterceptor(); mybatisPlusInterceptor.addInnerInterceptor(new OptimisticLockerInnerInterceptor()); return mybatisPlusInterceptor; } } 在对应的实体类字段上加上@Version注解即可 分页配置拦截器 @Configuration @MapperScan(&quot;scan.your.mapper.package&quot;) public class MybatisPlusConfig { /** * 新的分页插件,一缓和二缓遵循mybatis的规则,需要设置 MybatisConfiguration#useDeprecatedExecutor = false 避免缓存出现问题 */ @Bean public MybatisPlusInterceptor mybatisPlusInterceptor() { MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor(); interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.H2)); return interceptor; } @Bean public ConfigurationCustomizer configurationCustomizer() { return configuration -&gt; configuration.setUseDeprecatedExecutor(false); } } 直接使用Page对象即可 逻辑删除增加一个字段，标记用户对数据库中数据的删除操作，实际上数据库中的数据未被删除（实际上进行的是更新操作），类似于回收站，后续管理员可根据需要进行数据库的清理 配置application.yml或者编写配置类 mybatis-plus: global-config: db-config: logic-delete-field: flag # 全局逻辑删除的实体字段名(配置后可以忽略配置类) logic-delete-value: 1 # 逻辑已删除值(默认为 1) logic-not-delete-value: 0 # 逻辑未删除值(默认为 0) @Configuration @MapperScan(&quot;scan.your.mapper.package&quot;) public class MybatisPlusConfig { @Bean public ISqlInjector sqlInjector() { return new LogicSqlInjector(); } } 对应实体类字段上加上@TableLogic注解即可 性能分析SQL执行效率插件 @Configuration @MapperScan(&quot;scan.your.mapper.package&quot;) public class MybatisPlusConfig { @Bean @Profile({&quot;dev&quot;, &quot;test&quot;}) // 设置 dev test 环境开启，保证效率，注意在 SpringBoot 环境中配置 spring.profiles.active=dev/test public PerformanceInterceptor performanceInterceptor() { PerformanceInterceptor performanceInterceptor = new PerformanceInterceptor(); performanceInterceptor.setMaxTime(100); // ms 设置sql执行的最大时间，如果超过了则不执行 performanceInterceptor.setFormat(true); // 是否格式化代码 return performanceInterceptor; } } 条件构造器@Test void contextLoads() { QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;(); // 链式编程 wrapper .isNotNull(&quot;name&quot;) // name 不为空 .isNotNull(&quot;email&quot;) // 邮箱不为空 .ge(&quot;age&quot;, 12); // 年龄大于等于12 // wrapper // 模糊查询 // .notLike(&quot;name&quot;, &quot;e&quot;); // name NOT LIKE &#39;%e%&#39; // .likeRight(&quot;email&quot;, &quot;t&quot;); // email LIKE &#39;t%&#39; // wrapper // .inSql(&quot;id&quot;, &quot;select id from user where id &lt; 3&quot;) // 子查询 // .orderByDsc(&quot;id&quot;); // 根据 id 进行降序排序 userMapper.selectList(wrapper).forEach(System.out::println); } 代码生成器导入依赖 &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt; &lt;version&gt;最新版本&lt;/version&gt; &lt;/dependency&gt; FastAutoGenerator.create(&quot;url&quot;, &quot;username&quot;, &quot;password&quot;) .globalConfig(builder -&gt; { builder.author(&quot;baomidou&quot;) // 设置作者 .enableSwagger() // 开启 swagger 模式 .fileOverride() // 覆盖已生成文件 .outputDir(&quot;/src/main/java&quot;); // 指定输出目录 }) .packageConfig(builder -&gt; { builder.parent(&quot;com.baomidou.mybatisplus.samples.generator&quot;) // 设置父包名 .moduleName(&quot;system&quot;) // 设置父包模块名 .pathInfo(Collections.singletonMap(OutputFile.xml, &quot;D://&quot;)); // 设置mapperXml生成路径 }) .strategyConfig(builder -&gt; { builder.addInclude(&quot;user&quot;) // 设置需要生成的表名 .addTablePrefix(&quot;t_&quot;, &quot;c_&quot;); // 设置过滤表前缀 }) .templateEngine(new FreemarkerTemplateEngine()) // 使用Freemarker引擎模板，默认的是Velocity引擎模板 .execute();","categories":[{"name":"生活","slug":"生活","permalink":"http://goodguyjameswin.github.io/categories/生活/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://goodguyjameswin.github.io/tags/学习笔记/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"http://goodguyjameswin.github.io/categories/生活/"}]},{"title":"动态规划","slug":"动态规划","date":"2022-06-05T07:25:26.000Z","updated":"2022-07-18T03:51:52.873Z","comments":false,"path":"2022/06/05/动态规划/","link":"","permalink":"http://goodguyjameswin.github.io/2022/06/05/动态规划/","excerpt":"","text":"自底向上递推0-1背包问题有若干个物品，每个物品有两个属性：价值和重量。现在考虑将这些物品装入一个容器，称为背包，背包只有一个属性：最大承重，每个物品只有一件。问如何选择物品，使得所选物品的重量总和在不超过背包的最大承重的前提下，这些物品的价值总和最大。 为满足无后效性，有约束可以在状态数组的后面增加一维。对于下标为i的物品，有选和不选两种方案，选出两者中较好的即可。 public class Solution { public int backpack01(int W, int[] weights, int[] values) { int N = weights.length; if (N == 0) { return 0; } // dp[i][j] 表示：考虑物品区间 [0..i] 里，不超过背包容量，能够获得的最大价值 int[][] dp = new int[N + 1][W + 1]; // 递推开始，以 dp 数组为视角，从 1 开始，到 N 为止 // 注意：遇到物品的下标都减 1 for (int i = 1; i &lt;= N; i++) { for (int j = 0; j &lt;= W; j++) { // 下标为 i 的行参考了下标为 i - 1 的行的状态值。为了让 i - 1 &gt;= 0，下标为 0 的行需要初始化。事实上，可以将状态二维数组多设置一行，表示 添加了一个重量为 0、价值为 0 的物品，计算结果与原问题等价 dp[i][j] = dp[i - 1][j]; if (weights[i - 1] &lt;= j) { dp[i][j] = Math.max(dp[i][j], dp[i - 1][j - weights[i - 1]] + values[i - 1]); } } } return dp[N][W]; } } 空间优化方法：状态值的更新只和它上边和左边的元素有关，我们可以把空间投影到一行，执行状态转移（填表）的时候，从右边到左边更新状态值，从而保证新状态值得计算可以参考到正确得旧状态值。 public class Solution { public int backpack01(int W, int[] weights, int[] values) { int N = weights.length; if (N == 0) { return 0; } int[] dp = new int[W + 1]; // 注意：这里 i 从 1 开始，到 N 结束，N 可以取到 for (int i = 1; i &lt;= N; i++) { for (int j = W; j &gt;= weights[i - 1]; j--) { dp[j] = Math.max(dp[j], dp[j - weights[i - 1]] + values[i - 1]); } } return dp[W]; } } 力扣474：给你一个二进制字符串数组strs和两个整数m和n。请你找出返回strs的最大子集的长度，该子集中最多有m个0和n个1。如果x的所有元素也是y的元素，集合x是集合y的子集。 输入：strs = [“10”,”0001”,”111001”,”1”,”0”], m = 5, n = 3 输出：4 解释：最多有 5 个 0 和 3 个 1 的最大子集是 {“10”,”0001”,”1”,”0”}，因此答案是 4。其他满足题意但较小的子集包括 {“0001”,”1”} 和 {“10”,”1”,”0”}。{“1110001”} 不满足题意，因为它包含 4 个 1，大于 n 的值 3。 查看解析 public class Solution { public int findMaxForm(String[] strs, int m, int n) { int len = strs.length; int[][][] dp = new int[len + 1][m + 1][n + 1]; // 阶段 for (int i = 1; i &lt;= len; i++) { int[] cnt = countZeroAndOne(strs[i - 1]); // 状态 1 for (int j = 0; j &lt;= m; j++) { // 状态 2 for (int k = 0; k &lt;= n; k++) { // 按照「0-1 背包问题」的状态转移过程，先把上一行的值抄下来 dp[i][j][k] = dp[i - 1][j][k]; int zeros = cnt[0]; int ones = cnt[1]; // 决策 if (j &gt;= zeros &amp;&amp; k &gt;= ones) { dp[i][j][k] = Math.max(dp[i - 1][j][k], dp[i - 1][j - zeros][k - ones] + 1); } } } } return dp[len][m][n]; } /** * 分别统计每个单词 0 和 1 出现的次数 * * @param str * @return */ private int[] countZeroAndOne(String str) { int[] counter = new int[2]; for (char c : str.toCharArray()) { counter[c - &#39;0&#39;]++; } return counter; } } 还有一类问题要求恰好能够装满总重量为 j 的背包，需要区分清楚恰好能够装满和装入不超过背包容量的物品的区别 力扣416：给你一个只包含正整数得非空数组nums。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。 输入：nums = [1,5,11,15] 输出：true 解释：数组可以分割成 [1,5,5] 和 [11]。 查看解析 public class Solution { public boolean canPartition(int[] nums) { int len = nums.length; // Java8 以后推出的流式语法求数组所有元素的和 int sum = Arrays.stream(nums).sum(); // 如果输入数组所有元素的和为奇数，一定找不到这样的子集 if (sum % 2 != 0) { return false; } // 背包的总重量 int target = sum / 2; // dp[i][j]：前缀区间 [0..i] 里是否有一部分元素的和恰好为 j boolean[][] dp = new boolean[len][target + 1]; // 初始化：nums[0] 只能填满容积为 nums[0] 的背包 if (nums[0] &lt;= target) { dp[0][nums[0]] = true; } // 递推开始 for (int i = 1; i &lt; len; i++) { for (int j = 0; j &lt;= target; j++) { // 不选：把上一行照抄下来 dp[i][j] = dp[i - 1][j]; if (nums[i] &lt;= j) { // 选：二者之中有一个为 true 即可 dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i]]; } } // 如果某一行最后一列为 true，最后一行最后一列一定为 true，提前终止程序 if (dp[i][target]) { return true; } } return dp[len - 1][target]; } } 力扣494：给你一个整数数组nums和一个整数target。向数组中的每个整数前添加&#39;+&#39;或&#39;-&#39;，然后串联起所有整数，可以构造一个表达式： 例如，nums = [2,1]，可以在2之前添加&#39;+&#39;，在1之前添加&#39;-&#39;，然后串联起来得到表达式&quot;+2-1&quot;。 返回可以通过上述方法构造的、运算结果等于target的不同表达式的数目。 输入：nums = [1,1,1,1,1], target = 3 输出：5 解释：一共有 5 种方法让最终目标和为 3。 -1 + 1 + 1 + 1 + 1 = 3 +1 - 1 + 1 + 1 + 1 = 3 +1 + 1 - 1 + 1 + 1 = 3 +1 + 1 + 1 - 1 + 1 = 3 +1 + 1 + 1 + 1 - 1 = 3 查看解析 dp[i][j]表示：使用数组的前缀区间[0..i]里的部分元素，并且它们的和为j的方法数。考虑nums[i]，它的前面可能被添加正好+，也可能被添加负号-。两种情况都要考虑到，由于计数问题，总数就是两种方法数之和（分类计数加法原理）。 转换为0-1背包问题：sum（所有添加正号的数） + sum（所有添加负号的数） = sum；sum（所有添加正号的数） - sum（所有添加负号的数） = target。两式相加得到sum（所有添加正号的数） = （sum + target）/ 2 public class Solution { public int findTargetSumWays(int[] nums, int S) { int len = nums.length; if (len == 0) { return 0; } int sum = Arrays.stream(nums).sum(); if (S &gt; sum) { return 0; } int target = sum + S; // 需要保证和为整数 if ((target % 2) != 0) { return 0; } target /= 2; int[][] dp = new int[len][target + 1]; dp[0][0] = 1; for (int j = 0; j &lt;= target; j++) { if (nums[0] == j) { dp[0][j] += 1; } } for (int i = 1; i &lt; len; i++) { for (int j = 0; j &lt; target + 1; j++) { // 至少是不选这个物品时候的种数 dp[i][j] += dp[i - 1][j]; if (j &gt;= nums[i]) { dp[i][j] += dp[i - 1][j - nums[i]]; } } } return dp[len - 1][target]; } } 完全背包问题重点在于： 每种物品都有无限件可用 一种物品可以使用多个，且不计算顺序 状态转移的时候，每一件物品在背包有限制的前提下可以使用多少个需要全部考虑进去，如果将每一种物品可以考虑的件数平铺开来，就可以转换成为0-1背包问题。dp[i][j] = max(dp[i-1][j], dp[i][j-w[i]] + v[i]) public class Solution { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); // 读第 1 行 int N = scanner.nextInt(); int V = scanner.nextInt(); // 读后面的体积和价值 int[] weight = new int[N]; int[] value = new int[N]; for (int i = 0; i &lt; N; i++) { weight[i] = scanner.nextInt(); value[i] = scanner.nextInt(); } int[] dp = new int[V + 1]; // 先写第 1 行 // 优化空间 for (int i = 1; i &lt;= N; i++) { // 细节，j 从 weight[i - 1] 开始遍历 for (int j = weight[i - 1]; j &lt;= V; j++) { // 完全背包问题中，当前状态参考当前行的值，所以优化空间采用正序填表 dp[j] = Math.max(dp[j], dp[j - weight[i - 1]] + value[i - 1]); } } // 输出 System.out.println(dp[V]); } } 力扣322：给你一个整数数组coins，表示不同面额的硬币；以及一个整数amount，表示总金额。 计算并返回可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回-1。你可以认为每种硬币的数量是无限的。 输入：coins = [1,2,5], amount = 11 输出：3 解释：11 = 5 + 5 + 1 查看解析 public class Solution { public int coinChange(int[] coins, int amount) { int len = coins.length; // 定义：使用区间 [0..i) 里的硬币，能够凑出面值总和恰好为 j 的最少硬币数 int[][] dp = new int[len + 1][amount + 1]; // 要找最小值，所以初始化的时候全部设置为一个不可能的较大值 for (int[] row : dp) { Arrays.fill(row, amount + 1); } dp[0][0] = 0; // 通过多设置一行状态数组可以省去下面的初始化，体会这个思路 // for (int j = coins[0]; j &lt;= amount; j++) { // if (dp[0][j - coins[0]] != amount + 1) { // dp[0][j] = dp[0][j - coins[0]] + 1; // } // } // 递推开始 for (int i = 1; i &lt;= len; i++) { for (int j = 0; j &lt;= amount; j++) { // 因为问题转换成为 恰好装入容量为 amount 的背包，体会这里的判断条件 if (coins[i - 1] &lt;= j &amp;&amp; dp[i][j - coins[i - 1]] != amount + 1) { dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - coins[i - 1]] + 1); } else { dp[i][j] = dp[i - 1][j]; } } } // 输出 if (dp[len][amount] == amount + 1) { dp[len][amount] = -1; } return dp[len][amount]; } } 此题条件不变，若问题转换为“求可以凑成总金额的硬币组合数”，解法如下： public class Solution { public int change(int amount, int[] coins) { int len = coins.length; // 定义：使用区间 [0, i) 里的硬币，恰好可以凑出面值为 j 的方案总数 int[][] dp = new int[len + 1][amount + 1]; // 初始化 dp[0][0] = 1; // 递推开始 for (int i = 1; i &lt;= len; i++) { for (int j = 0; j &lt;= amount; j++) { dp[i][j] = dp[i - 1][j]; if (j - coins[i - 1] &gt;= 0) { dp[i][j] += dp[i][j - coins[i - 1]]; } } } return dp[len][amount]; } } .center { width: auto; display: table; margin-left: auto; margin-right: auto; }","categories":[{"name":"思维","slug":"思维","permalink":"http://goodguyjameswin.github.io/categories/思维/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://goodguyjameswin.github.io/tags/学习笔记/"}],"keywords":[{"name":"思维","slug":"思维","permalink":"http://goodguyjameswin.github.io/categories/思维/"}]},{"title":"DiyTomcat","slug":"diytomcat","date":"2022-06-01T07:35:38.000Z","updated":"2022-07-18T03:58:16.119Z","comments":false,"path":"2022/06/01/diytomcat/","link":"","permalink":"http://goodguyjameswin.github.io/2022/06/01/diytomcat/","excerpt":"","text":"内容部分转载自how2j实践项目，自学笔记，仅作学习交流用 Hello diyTomcat通过socket可简单模拟浏览器和服务端通信： while (true) { // 外套循环，表示处理掉一个Socket连接请求之后，再处理下一个连接请求 Socket s = ss.accept(); // 表示收到浏览器客户端的请求 InputStream is = s.getInputStream(); // ... is.read(buffer); String requestString = new String(buffer, StandardCharsets.UTF_8); System.out.println(&quot;浏览器的输入信息：\\r\\n&quot; + requestString); OutputStream os = s.getOutputStream(); // 因为作为web服务器和浏览器之间通信，需要遵循http协议 String response_head = &quot;HTTP/1.1 200 Ok\\r\\n&quot; + &quot;Content-Type:text/html\\r\\n\\r\\n&quot;; // ... os.write(responseString.getBytes()); s.close(); } MiniBrowser实现一个迷你浏览器，浏览器主要用于获取html内容和响应头信息，关键在于通过socket发送http协议给服务端： public static byte[] getHttpBytes(String url) { URL u = new URL(url); int port = u.getPort(); InetSocketAddress inetSocketAddress = new InetSocketAddress(u.getHost(), port); client.connect(inetSocketAddress, 1000); // 浏览器（客户端）与服务端建立连接 Map&lt;String,String&gt; requestHeaders = new HashMap&lt;&gt;(); // ... httpRequestString.append(&quot;GET&quot; + u.getPath() + &quot; HTTP/1.1\\r\\n&quot;); // ... PrintWriter pWriter = new PrintWriter(client.getOutputStream(), true); pWriter.println(httpRequestString); // 浏览器发送请求 InputStream is = client.getInputStream(); // 接受回传数据 ByteArrayOutputStream baos = new ByteArrayOutputStream(); byte buffer[] = new byte[1024]; while(true) { // 服务端回传过来的信息很有可能长度不是刚好1024，如果超过或者低于都会存在信息丢失，故采用循环读取 int length = is.read(buffer); if(-1==length) break; baos.write(buffer, 0, length); if(length!=buffer_size) break; } } Request和Response对象request对象用于解析http请求字符串，主要是uri： private void parseUri() { if(StrUtil.isEmpty(requestString)) return; String temp; // 请求的uri就是刚开始的两个空格之间的数据 temp = StrUtil.subBetween(requestString, &quot; &quot;, &quot; &quot;); // 判断有无参数 if (!StrUtil.contains(temp, &#39;?&#39;)) { uri = temp; return; } temp = StrUtil.subBefore(temp, &#39;?&#39;, false); uri = temp; } response对象实现HttpServletResponse中response.getWriter().println()类似风格： public Response(){ this.stringWriter = new StringWriter(); // 用于存放返回的html文本 // response.getWriter().println() 写进去的数据最后都写到stringWriter里面去了 this.writer = new PrintWriter(stringWriter); this.contentType = &quot;text/html&quot;; // 对应响应头里面的Content-type } 线程池处理多请求： ThreadPoolExecutor threadPool = new ThreadPoolExecutor(20, 20, 60, TimeUnit.SECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(10)); // 创建包含20个线程的线程池 for(int i = 0; i&lt;3; i++){ threadPool.execute(new Runnable(){ public void run() { getContentString(&quot;/timeConsume.html&quot;); // 获取响应内容 } }); } threadPool.shutdown(); // 尝试关闭线程池，如果其中有任务在运行，就不会强制关闭 threadPool.awaitTermination(1, TimeUnit.HOURS); // 若一小时后仍在运行任务，强制关闭线程池 服务端在每个请求到来的时候，创建一个Runnable任务，并且把他丢到线程池运行即可，然后去准备接受下一个请求： while(true) { Socket s = ss.accept(); Runnable r = new Runnable(){ @Override public void run() { try { Request request = new Request(s); Response response = new Response(); String uri = request.getUri(); if(&quot;/&quot;.equals(uri)){ // 默认请求 String html = &quot;Hello DIY Tomcat from how2j.cn&quot;; response.getWriter().println(html); } else{ // 请求资源 String fileName = StrUtil.removePrefix(uri, &quot;/&quot;); File file = FileUtil.file(Constant.rootFolder,fileName); if(file.exists()){ String fileContent = FileUtil.readUtf8String(file); response.getWriter().println(fileContent); if(fileName.equals(&quot;timeConsume.html&quot;)){ // 耗时任务 ThreadUtil.sleep(1000); } } else{ // 资源未找到 response.getWriter().println(&quot;File Not Found&quot;); } } // ... // 处理请求 } catch (IOException e) { e.printStackTrace(); } } }; ThreadPoolUtil.run(r); // 放入线程池 } 多应用添加访问路径与对应服务端文件系统中文件位置的映射contextMap，Request对象中增加对Context对象（代表一个应用）的处理： private void parseContext() { String path = StrUtil.subBetween(uri, &quot;/&quot;, &quot;/&quot;); if (null == path) path = &quot;/&quot;; else path = &quot;/&quot; + path; context = Bootstrap.contextMap.get(path); if (null == context) context = Bootstrap.contextMap.get(&quot;/&quot;); // Context对象找不到，则返回默认的ROOT Context } 就可以通过客户端请求，获取对应的Context对象，根据这个对象获取信息： Context context = request.getContext(); // ... File file = FileUtil.file(context.getDocBase(), fileName); // 得到请求资源对应在文件系统中的位置 server.xml还可以通过配置文件注册Context对象： &lt;Server&gt; &lt;Context path=&quot;/b&quot; docBase=&quot;d:/java_proj/diytomcat/b&quot; /&gt; &lt;/Server&gt; 引入Tomcat各内置对象： &lt;Server&gt; &lt;!--表示服务器本身--&gt; &lt;Service name=&quot;Catalina&quot;&gt; &lt;!--代表tomcat提供的服务--&gt; &lt;Connector port=&quot;18080&quot;/&gt; &lt;!--配置多端口监听--&gt; &lt;Connector port=&quot;18081&quot;/&gt; &lt;Connector port=&quot;18082&quot;/&gt; &lt;!--表示servlet引擎，用来处理servlet的请求--&gt; &lt;Engine defaultHost=&quot;localhost&quot;&gt; &lt;!--默认的 Host 是名称是 &quot;localhost&quot; 的 Host--&gt; &lt;!--Host表示虚拟主机--&gt; &lt;Host name=&quot;localhost&quot;&gt; &lt;Context path=&quot;/b&quot; docBase=&quot;d:/java_proj/diytomcat/b&quot; /&gt; &lt;/Host&gt; &lt;/Engine&gt; &lt;/Service&gt; &lt;/Server&gt; 利用jsoup解析xml文件： public static List&lt;Context&gt; getContexts() { List&lt;Context&gt; result = new ArrayList&lt;&gt;(); String xml = FileUtil.readUtf8String(Constant.serverXmlFile); Document d = Jsoup.parse(xml); Elements es = d.select(&quot;Context&quot;); // 选择器通过标签名获取元素 for (Element e : es) { String path = e.attr(&quot;path&quot;); String docBase = e.attr(&quot;docBase&quot;); Context context = new Context(path, docBase); result.add(context); } return result; } 可以看到启动服务端时，控制台打印类似官方Tomcat风格的日志： 404和500响应注明响应头： public static final String response_head_404 = &quot;HTTP/1.1 404 Not Found\\r\\n&quot; + &quot;Content-Type: text/html\\r\\n\\r\\n&quot;; public static final String response_head_500 = &quot;HTTP/1.1 500 Internal Server Error\\r\\n&quot; + &quot;Content-Type: text/html\\r\\n\\r\\n&quot;; 处理404请求： protected void handle404(Socket s, String uri) throws IOException { OutputStream os = s.getOutputStream(); String responseText = StrUtil.format(Constant.textFormat_404, uri, uri); responseText = Constant.response_head_404 + responseText; // 响应页面可直接延用官方Tomcat页面 byte[] responseByte = responseText.getBytes(&quot;utf-8&quot;); os.write(responseByte); } 处理500请求，需要打印异常堆栈信息： StackTraceElement[] stes = e.getStackTrace(); // 拿到Exception的异常堆栈，可以看到依次调用的类的方法的信息 欢迎页编写Tomcat的配置文件conf/web.xml： &lt;web-app&gt; &lt;!--存放关于tomcat的默认配置--&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;/web-app&gt; 设置每个应用对应的起始页： public static String getWelcomeFile(Context context) { String xml = FileUtil.readUtf8String(webXmlFile); Document d = Jsoup.parse(xml); Elements es = d.select(&quot;welcome-file&quot;); for (Element e : es) { String welcomeFileName = e.text(); File f = new File(context.getDocBase(), welcomeFileName); if (f.exists()) return f.getName(); } return &quot;index.html&quot;; } mime-type网页仅识别mime-type类型的资源文件，因此需要配置文件类型与mime-type类型的映射： &lt;!-- --&gt; &lt;mime-mapping&gt; &lt;extension&gt;zip&lt;/extension&gt; &lt;mime-type&gt;application/zip&lt;/mime-type&gt; &lt;/mime-mapping&gt; &lt;!-- --&gt; 初始化时加载一次： private static void initMimeType() { String xml = FileUtil.readUtf8String(webXmlFile); Document d = Jsoup.parse(xml); Elements es = d.select(&quot;mime-mapping&quot;); for (Element e : es) { String extName = e.select(&quot;extension&quot;).first().text(); String mimeType = e.select(&quot;mime-type&quot;).first().text(); mimeTypeMapping.put(extName, mimeType); } } 处理请求时，设置响应头： String extName = FileUtil.extName(file); String mimeType = WebXMLUtil.getMimeType(extName); response.setContentType(mimeType); // 根据请求文件类型，设置响应头 servlet映射在diytomcat的配置文件目录下新建context.xml，里面配置了servlet映射文件所在位置： &lt;Context&gt; &lt;!--web应用默认配置信息的存放路径--&gt; &lt;WatchedResource&gt;WEB-INF/web.xml&lt;/WatchedResource&gt; &lt;/Context&gt; 解析servlet映射文件： &lt;web-app&gt; &lt;servlet&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;cn.how2j.diytomcat.webappservlet.HelloServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/hello&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;/web-app&gt; private Map&lt;String, String&gt; url_servletClassName; // 地址对应 Servlet 的类名 private Map&lt;String, String&gt; url_servletName; // 地址对应 Servlet 的名称 private Map&lt;String, String&gt; servletName_className; // Servlet 的名称对应类名 private Map&lt;String, String&gt; className_servletName; // Servlet 类名对应名称 // ... private void parseServletMapping(Document d) { // url_ServletName Elements mappingurlElements = d.select(&quot;servlet-mapping url-pattern&quot;); for (Element mappingurlElement : mappingurlElements) { String urlPattern = mappingurlElement.text(); String servletName = mappingurlElement.parent().select(&quot;servlet-name&quot;).first().text(); url_servletName.put(urlPattern, servletName); } // ... } 服务端通过servlet类名实例化对象，然后调用其doGet方法： String servletClassName = context.getServletClassName(uri); if(null!=servletClassName){ Object servletObject = ReflectUtil.newInstance(servletClassName); ReflectUtil.invoke(servletObject, &quot;doGet&quot;, request, response); } Tomcat类加载器 Tomcat的顶层自定义加载器是公共类加载器。它负责加载%tomcat_home%/lib这个目录里的类和jar；WebappClassLoader，用于加载某个web应用，比如j2ee下的/WEB-INF/classes，/WEB-INF/lib目录里的类和jar；JspClassLoader，用于加载jsp转换成.java被编译之后的类。再还有 Catalina 和 Share 类加载器，分别加载%tomcat_home%/catalina/和%tomcat_home%/share目录下的jar。 public class CommonClassLoader extends URLClassLoader { public CommonClassLoader() { super(new URL[] {}); try { File workingFolder = new File(System.getProperty(&quot;user.dir&quot;)); File libFolder = new File(workingFolder, &quot;lib&quot;); File[] jarFiles = libFolder.listFiles(); assert jarFiles != null; for (File file : jarFiles) { if (file.getName().endsWith(&quot;jar&quot;)) { URL url = new URL(&quot;file:&quot; + file.getAbsolutePath()); this.addURL(url); // 加到当前的库里面去，当调用其loadClass方法时，就会从这些jar里面去找了 } } } catch (MalformedURLException e) { // TODO Auto-generated catch block e.printStackTrace(); } } } 自定义公共类加载器，为保证仅启动类使用应用程序类加载器，其余类通过CommonClassLoader加载，需要通过批处理文件运行： del /q bootstrap.jar jar cvf0 bootstrap.jar -C out/production/diytomcat cn/how2j/diytomcat/Bootstrap.class -C out/production/diytomcat cn/how2j/diytomcat/classloader/CommonClassLoader.class del /q lib/diytomcat.jar cd out cd production cd diytomcat jar cvf0 ../../../lib/diytomcat.jar * cd .. cd .. cd .. java -cp bootstrap.jar cn.how2j.diytomcat.Bootstrap pause 不同应用对应独立的类加载器WebappClassLoader： public class WebappClassLoader extends URLClassLoader { public WebappClassLoader(String docBase, ClassLoader commonClassLoader) { super(new URL[] {}, commonClassLoader); // ... File webinfFolder = new File(docBase, &quot;WEB-INF&quot;); File classesFolder = new File(webinfFolder, &quot;classes&quot;); File libFolder = new File(webinfFolder, &quot;lib&quot;); URL url; url = new URL(&quot;file:&quot; + classesFolder.getAbsolutePath() + &quot;/&quot;); // 末尾跟上&quot;/&quot;，URLClassLoader才会当成目录处理 this.addURL(url); List&lt;File&gt; jarFiles = FileUtil.loopFiles(libFolder); // ... } } 部署独立的web应用后可以看到，使用的是独立的web应用类加载器： // 每个web应用有自己独立的类加载器，不同应用间存在同名类也不影响 ClassLoader commonClassLoader = Thread.currentThread().getContextClassLoader(); this.webappClassLoader = new WebappClassLoader(docBase, commonClassLoader); 热加载 通过设置监听器ContextFileChangeWatcher监听web工作目录变化，来实现热加载功能： public class ContextFileChangeWatcher { private WatchMonitor monitor; // 真正作用的监听器 private boolean stop = false; // 标记是否已经暂停 public ContextFileChangeWatcher(Context context) { // 通过WatchUtil.createAll创建监听器； // context.getDocBase()代表监听的文件夹； // Integer.MAX_VALUE代表监听的深入，如果是0或者1，就表示只监听当前目录，而不监听子目录； // new Watcher 当有文件发生变化，那么就会访问 Watcher 对应的方法 this.monitor = WatchUtil.createAll(context.getDocBase(), Integer.MAX_VALUE, new Watcher() { private void dealWith(WatchEvent&lt;?&gt; event) { // 统一处理（重新加载context） synchronized (ContextFileChangeWatcher.class) { // 多线程下同步，防止context重载多次 String fileName = event.context().toString(); if (stop) // 表示已经重载过了，通知后续消息不需要再进行处理 return; // 只应对 jar class 和 xml 发生的变化，其他的不需要重启 if (fileName.endsWith(&quot;.jar&quot;) || fileName.endsWith(&quot;.class&quot;) || fileName.endsWith(&quot;.xml&quot;)) { stop = true; LogFactory.get().info(ContextFileChangeWatcher.this + &quot; 检测到了Web应用下的重要文件变化 {} &quot; , fileName); context.reload(); // 保存基本信息后，调用类加载器stop方法暂停，删掉映射中相应信息，之后利用保存的基本信息重新创建context及建立映射关系 } // ... } } }); // ... } } Servlet单例用Servlet缓存池实现Servlet单例模式，后续直接通过类名映射得到对应Servlet对象： public synchronized HttpServlet getServlet(Class&lt;?&gt; clazz) throws InstantiationException, IllegalAccessException, ServletException { HttpServlet servlet = servletPool.get(clazz); if (null == servlet) { synchronized (HttpServlet.class) { servlet = (HttpServlet) clazz.newInstance(); servletPool.put(clazz, servlet); } } return servlet; } Servlet生命周期实例化Servlet后，放入缓存池之前，初始化Servlet： servlet = (HttpServlet) clazz.newInstance(); ServletContext servletContext = this.getServletContext(); String className = clazz.getName(); String servletName = className_servletName.get(className); Map&lt;String, String&gt; initParameters = servlet_className_init_params.get(className); ServletConfig servletConfig = new StandardServletConfig(servletContext, servletName, initParameters); servlet.init(servletConfig); Servlet提供服务之后，销毁并回收Servlet： private void destroyServlets() { Collection&lt;HttpServlet&gt; servlets = servletPool.values(); for (HttpServlet servlet : servlets) { servlet.destroy(); } } Servlet自启动xml文件中解析需要自启动的Servlet类： public void parseLoadOnStartup(Document d) { Elements es = d.select(&quot;load-on-startup&quot;); for (Element e : es) { String loadOnStartupServletClassName = e.parent().select(&quot;servlet-class&quot;).text(); loadOnStartupServletClassNames.add(loadOnStartupServletClassName); } } 启动tomcat时加载需要自启动的Servlet类： public void handleLoadOnStartup() { for (String loadOnStartupServletClassName : loadOnStartupServletClassNames) { try { Class&lt;?&gt; clazz = webappClassLoader.loadClass(loadOnStartupServletClassName); getServlet(clazz); } catch (ClassNotFoundException | InstantiationException | IllegalAccessException | ServletException e) { e.printStackTrace(); } } } Request请求参数和头信息Request对象中处理请求参数： private void parseParameters() { // 获取参数，GET的参数放在uri里，POST参数放在请求最后的请求体里 if (&quot;GET&quot;.equals(this.getMethod())) { String url = StrUtil.subBetween(requestString, &quot; &quot;, &quot; &quot;); if (StrUtil.contains(url, &#39;?&#39;)) { queryString = StrUtil.subAfter(url, &#39;?&#39;, false); } } if (&quot;POST&quot;.equals(this.getMethod())) { queryString = StrUtil.subAfter(requestString, &quot;\\r\\n\\r\\n&quot;, false); } // ... } Request对象中处理头信息： public void parseHeaders() { StringReader stringReader = new StringReader(requestString); List&lt;String&gt; lines = new ArrayList&lt;&gt;(); IoUtil.readLines(stringReader, lines); for (int i = 1; i &lt; lines.size(); i++) { // i = 1 绕过请求头 String line = lines.get(i); if (0 == line.length()) // 绕过请求体 break; String[] segs = line.split(&quot;:&quot;); String headerName = segs[0].toLowerCase(); String headerValue = segs[1]; headerMap.put(headerName, headerValue); } } Cookie设置Response字段cookies，在返回响应时转换成cookies header，重写addCookie方法： public void addCookie(Cookie cookie) { cookies.add(cookie); } 重写getCookies方法，在Request中处理cookies： private void parseCookies() { List&lt;Cookie&gt; cookieList = new ArrayList&lt;&gt;(); String cookies = headerMap.get(&quot;cookie&quot;); if (null != cookies) { String[] pairs = StrUtil.split(cookies, &quot;;&quot;); for (String pair : pairs) { if (StrUtil.isBlank(pair)) continue; String[] segs = StrUtil.split(pair, &quot;=&quot;); String name = segs[0].trim(); String value = segs[1].trim(); Cookie cookie = new Cookie(name, value); cookieList.add(cookie); } } this.cookies = ArrayUtil.toArray(cookieList, Cookie.class); } session获取session的主逻辑： public static HttpSession getSession(String jsessionid, Request request, Response response) { if (null == jsessionid) { // 如果浏览器没有传递 jsessionid 过来，那么就创建一个新的session return newSession(request, response); } else { StandardSession currentSession = sessionMap.get(jsessionid); if (null == currentSession) { // 如果浏览器传递过来的 jsessionid 无效，那么也创建一个新的 sessionid return newSession(request, response); } else { // 否则就使用现成的session, 并且修改它的lastAccessedTime， 以及创建对应的 cookie currentSession.setLastAccessedTime(System.currentTimeMillis()); createCookieBySession(currentSession, request, response); return currentSession; } } } 通过开启一个线程轮询来达到session的时效性： private static void startSessionOutdateCheckThread() { new Thread(() -&gt; { while (true) { checkOutDateSession(); ThreadUtil.sleep(1000 * 30); // 每隔30秒调用一次 checkOutDateSession 方法 } }).start(); } gzip在server.xml上设置是否进行gzip压缩： &lt;Connector port=&quot;18080&quot; compression=&quot;on&quot; compressionMinSize=&quot;20&quot; noCompressionUserAgents=&quot;gozilla, traviata&quot; compressableMimeType=&quot;text/html,text/xml,text/javascript,application/javascript,text/css,text/plain,text/json&quot; /&gt; &lt;!--是否启动gzip压缩；最小进行压缩的字节数；不进行压缩的浏览器；需要进行压缩的mimeType--&gt; 针对需要进行压缩的请求头（判断是否满足压缩条件）调用ZipUtil.gzip()方法对响应体进行gzip压缩： public static final String response_head_200_gzip = &quot;HTTP/1.1 200 OK\\r\\nContent-Type: {}{}\\r\\n&quot; + &quot;Content-Encoding:gzip&quot; + &quot;\\r\\n\\r\\n&quot;; // 进行了压缩时的响应头 客户端跳转分为301永久跳转和302临时跳转，在Response中设置保存客户端跳转路径的字段，在服务端响应成功后，如果Response对象里这一字段不为空，则返回302响应头通知浏览器进行跳转： public static final String response_head_302 = &quot;HTTP/1.1 302 Found\\r\\nLocation: {}\\r\\n\\r\\n&quot;; if(null!=response.getRedirectPath()) response.setStatus(Constant.CODE_302); else response.setStatus(Constant.CODE_200); 服务端跳转实现RequestDispatcher接口，用于进行服务端跳转： public class ApplicationRequestDispatcher implements RequestDispatcher { private String uri; public ApplicationRequestDispatcher(String uri) { if (!uri.startsWith(&quot;/&quot;)) uri = &quot;/&quot; + uri; this.uri = uri; } @Override public void forward(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException { Request request = (Request) servletRequest; Response response = (Response) servletResponse; request.setUri(uri); // 修改 request 的 uri HttpProcessor processor = new HttpProcessor(); processor.execute(request.getSocket(), request, response); // 通过 HttpProcessor 的 execute 再执行一次 request.setForwarded(true); // 相当于在服务器内部再次访问了某个页面 } @Override public void include(ServletRequest arg0, ServletResponse arg1) throws ServletException, IOException { // TODO Auto-generated method stub } } 通过上述方式进行服务端跳转，需要在HttpProcessor.execute()方法加入条件判断： if (request.isForwarded()) { // 防止服务端进行多次跳转，导致程序使用已经关闭的socket从而抛出异常 return; } FilterFilter的初始化和配置与Servlet类似；自定义ApplicationFilterChain类实现FilterChain接口： public class ApplicationFilterChain implements FilterChain { private Filter[] filters; private Servlet servlet; int pos; public ApplicationFilterChain(List&lt;Filter&gt; filterList,Servlet servlet){ this.filters = ArrayUtil.toArray(filterList,Filter.class); this.servlet = servlet; } @Override public void doFilter(ServletRequest request, ServletResponse response) throws IOException, ServletException { if(pos &lt; filters.length) { Filter filter= filters[pos++]; filter.doFilter(request, response, this); } else { servlet.service(request, response); } } } 注册到Filter缓存池之后，请求到来时通过责任链模式进行处理： // 通过servlet类名实例化对象，然后调用其doGet方法 String servletClassName = context.getServletClassName(uri); HttpServlet workingServlet; // Servlet的service方法是在chain里面调用，所以用一个workingSerlvet分别指向它们 if (null != servletClassName) { workingServlet = InvokerServlet.getInstance(); } else if (uri.endsWith(&quot;.jsp&quot;)) { workingServlet = JspServlet.getInstance(); } else { workingServlet = DefaultServlet.getInstance(); // 处理静态资源 } // 通过Filter匹配模式筛选出需要过滤的Filter List&lt;Filter&gt; filters = request.getContext().getMatchedFilters(request.getRequestURI()); // 实例化自定义的FilterChain ApplicationFilterChain filterChain = new ApplicationFilterChain(filters, workingServlet); filterChain.doFilter(request, response); War部署首先将web应用打包成War包，置于diytomcat的webapps目录下，设置diytomcat启动时自动解压War文件，并识别web应用： public void loadWar(File warFile) { String fileName =warFile.getName(); String folderName = StrUtil.subBefore(fileName,&quot;.&quot;,true); //看看是否已经有对应的 Context了 Context context= getContext(&quot;/&quot;+folderName); if(null!=context) return; //先看是否已经有对应的文件夹 File folder = new File(Constant.webappsFolder,folderName); if(folder.exists()) return; //移动war文件，因为jar 命令只支持解压到当前目录下 File tempWarFile = FileUtil.file(Constant.webappsFolder, folderName, fileName); File contextFolder = tempWarFile.getParentFile(); contextFolder.mkdir(); FileUtil.copyFile(warFile, tempWarFile); //解压 String command = &quot;jar xvf &quot; + fileName; Process p =RuntimeUtil.exec(null, contextFolder, command); try { p.waitFor(); } catch (InterruptedException e) { e.printStackTrace(); } //解压之后删除临时war tempWarFile.delete(); //然后创建新的 Context loadContext(contextFolder); } 同样自定义监控类WarFileWatcher可实现动态War部署： public class WarFileWatcher { // 监控webapps目录，当发现新创建了war文件的时候，就调用loadWar方法 private WatchMonitor monitor; public WarFileWatcher(Host host) { this.monitor = WatchUtil.createAll(Constant.webappsFolder, 1, new Watcher() { private void dealWith(WatchEvent&lt;?&gt; event, Path currentPath) { synchronized (WarFileWatcher.class) { String fileName = event.context().toString(); if(fileName.toLowerCase().endsWith(&quot;.war&quot;) &amp;&amp; ENTRY_CREATE.equals(event.kind())) { File warFile = FileUtil.file(Constant.webappsFolder, fileName); host.loadWar(warFile); } } } // ... }); } // ... } 监听器配置监听器，diytomcat端解析xml文件初始化加载监听器（流程类似过滤器）： public class ContextListener implements ServletContextListener { @Override public void contextDestroyed(ServletContextEvent e) { System.out.println(&quot;监听到 web 应用 &quot;+ e.getSource() +&quot; 的销毁事件 &quot;); } @Override public void contextInitialized(ServletContextEvent e) { System.out.println(&quot;监听到 web 应用 &quot;+ e.getSource() +&quot; 的初始化事件 &quot;); } } 定义事件处理方法，实现在服务端处理请求流程中，监听Context生命周期中的初始化和销毁过程： private void fireEvent(String type) { ServletContextEvent event = new ServletContextEvent(servletContext); for (ServletContextListener servletContextListener : listeners) { if(&quot;init&quot;.equals(type)) servletContextListener.contextInitialized(event); if(&quot;destroy&quot;.equals(type)) servletContextListener.contextDestroyed(event); } } 测试测试完毕，项目已推至github，其实还是有些小bug，等之后学些netty和分布式的东西再回来优化","categories":[{"name":"生活","slug":"生活","permalink":"http://goodguyjameswin.github.io/categories/生活/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://goodguyjameswin.github.io/tags/学习笔记/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"http://goodguyjameswin.github.io/categories/生活/"}]},{"title":"回溯","slug":"回溯","date":"2022-05-28T10:43:14.000Z","updated":"2022-07-18T03:51:57.760Z","comments":false,"path":"2022/05/28/回溯/","link":"","permalink":"http://goodguyjameswin.github.io/2022/05/28/回溯/","excerpt":"","text":"","categories":[{"name":"生活","slug":"生活","permalink":"http://goodguyjameswin.github.io/categories/生活/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://goodguyjameswin.github.io/tags/学习笔记/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"http://goodguyjameswin.github.io/categories/生活/"}]},{"title":"springsecurity学习","slug":"springsecurity学习","date":"2022-05-25T10:24:07.000Z","updated":"2022-07-18T03:57:57.615Z","comments":false,"path":"2022/05/25/springsecurity学习/","link":"","permalink":"http://goodguyjameswin.github.io/2022/05/25/springsecurity学习/","excerpt":"","text":"内容部分转载自 公众号：江南一点雨，自学笔记，仅作学习交流用 入门新建SpringBoot项目，引入依赖： &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt; &lt;/dependency&gt; 启动项目后，访问任何接口，都会自动重定向到登录页面了。 登录页面和接口在SpringSecurity中，默认的登录页面和登录接口，都是/login，只不过一个是get请求（登录页面），另一个是post请求（登录接口）。 form表单的相关配置在FormLoginConfigurer中，该类继承自AbstractAuthenticationFilterConfigurer，后者的构造方法中配置了默认的loginPage为/login。 protected AbstractAuthenticationFilterConfigurer() { this.setLoginPage(&quot;/login&quot;); } FormLoginConfigurer的初始化方法init中也调用了父类的init方法： protected final void updateAuthenticationDefaults() { if (loginProcessingUrl == null) { loginProcessingUrl(loginPage); } //省略 } 因此当用户没有给loginProcessingUrl设置值的时候，就默认使用loginPage作为loginProcessingUrl 表单参数FormLoginConfigurer类的构造方法中，有配置用户名和密码的方法： public FormLoginConfigurer() { super(new UsernamePasswordAuthenticationFilter(), null); usernameParameter(&quot;username&quot;); passwordParameter(&quot;password&quot;); } 首先调用父类构造方法，传入UsernamePasswordAuthenticationFilter实例，它将被赋值给父类的authFilter属性。 usernameParameter方法如下： public FormLoginConfigurer&lt;H&gt; usernameParameter(String usernameParameter) { // 调用父类的getAuthenticationFilter方法，返回authFilter属性，实际上是构造时创建的UsernamePasswordAuthenticationFilter实例，然后调用其setUsernameParameter方法 getAuthenticationFilter().setUsernameParameter(usernameParameter); return this; } 在类UsernamePasswordAuthenticationFilter中可以拿到请求HttpServletRequest中取出来用户的登录名和密码 protected String obtainPassword(HttpServletRequest request) { return request.getParameter(passwordParameter); } protected String obtainUsername(HttpServletRequest request) { return request.getParameter(usernameParameter); } 因此它默认的表单参数名就是username和password。 配置用户名和密码和用户相关的自动化配置类在UserDetailsServiceAutoConfiguration里面，该类的getOrDeducePassword方法中，看到打印日志： if (user.isPasswordGenerated()) { logger.info(String.format(&quot;%n%nUsing generated security password: %s%n&quot;, user.getPassword())); } 而user.getPassword出现在SecurityProperties中： /** * Default user name. */ private String name = &quot;user&quot;; /** * Password for the default user name. */ private String password = UUID.randomUUID().toString(); private boolean passwordGenerated = true; 因此默认的用户密码每次重启项目都会变，同时也知道如果要定义自己的用户名和密码，就必然要去覆盖默认配置。 @ConfigurationProperties(prefix = &quot;spring.security&quot;) publicclass SecurityProperties { ... } properties中定义的用户名密码是通过set注入到属性中去的，并且此时控制台就不会打印默认的密码了： public void setPassword(String password) { if (!StringUtils.hasLength(password)) { return; } this.passwordGenerated = false; this.password = password; } 同时密码需要经过加密处理，一般采用散列函数，并且加密过程中还需要加盐（一般存在数据库里），SpringSecurity推荐使用BCryptPasswordEncoder（自带加盐），它是PasswordEncoder的接口实现类。 public interface PasswordEncoder { // 对明文密码进行加密，返回加密之后的密文 String encode(CharSequence rawPassword); // 校对密码，以用户传来的明文密码和数据库中保存的密文密码作为参数，根据返回值判断用户密码是否输入正确 boolean matches(CharSequence rawPassword, String encodedPassword); // 是否需要再次加密 default boolean upgradeEncoding(String encodedPassword) { returnfalse; } } 定义配置类，覆盖自动配置： @Configuration public class SecurityConfig extends WebSecurityConfigurerAdapter { @Bean PasswordEncoder passwordEncoder() { // NoOpPasswordEncoder表示不对密码进行加密 return NoOpPasswordEncoder.getInstance(); } @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { // inMemoryAuthentication开启在内存中定义用户，如果要配置多个用户，用and相连 auth.inMemoryAuthentication() // withUser 中是用户名，password 中则是用户密码，roles 中是用户角色 .withUser(&quot;javaboy.org&quot;) .password(&quot;123&quot;).roles(&quot;admin&quot;); } } 由于SpringSecurity支持多种数据源，例如内存、数据库、LDAP等，这些不同来源的数据被共同封装成了一个UserDetailService接口，任何实现了该接口的对象都可以作为认证数据源 因此还可以重写WebSecurityConfigurerAdapter中的userDetailsService来提供一个userDetailsService实例进而配置多个用户： @Bean protected UserDetailsService userDetailsService() { InMemoryUserDetailsManager manager = new InMemoryUserDetailsManager(); manager.createUser(User.withUsername(&quot;javaboy&quot;).password(&quot;123&quot;).roles(&quot;admin&quot;).build()); manager.createUser(User.withUsername(&quot;江南一点雨&quot;).password(&quot;123&quot;).roles(&quot;user&quot;).build()); return manager; } 或者通过JDBC的方式根据数据库存放的用户信息创建用户： @Autowired DataSource dataSource; @Override @Bean protected UserDetailsService userDetailsService() { JdbcUserDetailsManager manager = new JdbcUserDetailsManager(); manager.setDataSource(dataSource); if (!manager.userExists(&quot;javaboy&quot;)) { manager.createUser(User.withUsername(&quot;javaboy&quot;).password(&quot;123&quot;).roles(&quot;admin&quot;).build()); } if (!manager.userExists(&quot;江南一点雨&quot;)) { manager.createUser(User.withUsername(&quot;江南一点雨&quot;).password(&quot;123&quot;).roles(&quot;user&quot;).build()); } return manager; } createUser或者userExists方法其实都是调用写好的SQL去判断的： public class JdbcUserDetailsManager extends JdbcDaoImpl implements UserDetailsManager, GroupManager { public static final String DEF_USER_EXISTS_SQL = &quot;select username from users where username = ?&quot;; private String userExistsSql = DEF_USER_EXISTS_SQL; public boolean userExists(String username) { List&lt;String&gt; users = getJdbcTemplate().queryForList(userExistsSql, new String[] { username }, String.class); if (users.size() &gt; 1) { throw new IncorrectResultSizeDataAccessException( &quot;More than one user found with name &#39;&quot; + username + &quot;&#39;&quot;, 1); } return users.size() == 1; } } 登录和注销@Override public void configure(WebSecurity web) throws Exception { // 配置要忽略的URL地址，一般针对静态文件 web.ignoring().antMatchers(&quot;/js/**&quot;, &quot;/css/**&quot;,&quot;/images/**&quot;); } @Override protected void configure(HttpSecurity http) throws Exception { http.authorizeRequests() // 配置拦截规则 .antMatchers(&quot;/admin/**&quot;).hasRole(&quot;admin&quot;) .antMatchers(&quot;/user/**&quot;).hasRole(&quot;user&quot;) .anyRequest().authenticated() // 表示其他格式的请求路径，认证（登录）后即可访问 .and() .formLogin() .loginPage(&quot;/login.html&quot;) // 配置登录页面 .loginProcessingUrl(&quot;/doLogin&quot;) // 配置提交登录数据请求接口 .usernameParameter(&quot;name&quot;) // 自定义用户名表单参数 .passwordParameter(&quot;passwd&quot;) // 自定义密码表单参数 .successForwardUrl(&quot;/index&quot;) // 登录成功后，服务端跳转到 /index 页面 .defaultSuccessUrl(&quot;/index&quot;, false) // 默认第二个参数为false，当请求需要登录才能访问的页面时，会重定向到登录页，登录成功后就直接跳转到之前访问的页面，如果之前直接访问的登录页，登陆成功后就会跳转到 /index 页面；如果第二个参数为 true，则效果与 successForwardUrl一致 .failureForwardUrl(&quot;/index&quot;) // 登录失败后发生服务端跳转 .failureUrl(&quot;/index&quot;) // 登录失败后发生重定向 .permitAll() // 表示登录相关的页面/接口不要被拦截 .and() .csrf().disable(); // 关闭csrf } 注销登录的默认接口是/logout，也可以配置： .and() .logout() .logoutUrl(&quot;/logout&quot;) // 是一个 GET 请求 .logoutRequestMatcher(new AntPathRequestMatcher(&quot;/logout&quot;,&quot;POST&quot;)) // 不仅可以修改注销 URL，还可以修改请求方式，与 logoutUrl等效 .logoutSuccessUrl(&quot;/index&quot;) // 注销成功后要跳转的页面 .deleteCookies() // 清楚 cookie .clearAuthentication(true) // 清除认证消息 .invalidateHttpSession(true) // 使HttpSession失效，可以不用配置，默认就会清除 .permitAll() .and() 回调方法登录成功后回调，可以取消重定向，而通过JSON来与前端交互： // successHandler的方法参数是一个AuthenticationSuccessHandler对象，需要实现onAuthenticationSuccess方法，它有三个参数分别是HttpServletRequest、HttpServletResponse和Authentication，而第三个参数保存了我们刚刚登录的用户信息 .successHandler((req, resp, authentication) -&gt; { Object principal = authentication.getPrincipal(); resp.setContentType(&quot;application/json;charset=utf-8&quot;); PrintWriter out = resp.getWriter(); out.write(new ObjectMapper().writeValueAsString(principal)); out.flush(); out.close(); }) 登录失败后回调，因此可以根据不同的异常类型，通过JSON返回给前端以提供给用户一个更加明确的提示： // 方法的第三个参数是一个Exception，里面保存了登录失败的原因 .failureHandler((req, resp, e) -&gt; { resp.setContentType(&quot;application/json;charset=utf-8&quot;); PrintWriter out = resp.getWriter(); RespBean respBean = RespBean.error(e.getMessage()); if (e instanceof LockedException) { respBean.setMsg(&quot;账户被锁定，请联系管理员!&quot;); } elseif (e instanceof CredentialsExpiredException) { respBean.setMsg(&quot;密码过期，请联系管理员!&quot;); } elseif (e instanceof AccountExpiredException) { respBean.setMsg(&quot;账户过期，请联系管理员!&quot;); } elseif (e instanceof DisabledException) { respBean.setMsg(&quot;账户被禁用，请联系管理员!&quot;); } elseif (e instanceof BadCredentialsException) { respBean.setMsg(&quot;用户名或者密码输入错误，请重新输入!&quot;); } out.write(new ObjectMapper().writeValueAsString(respBean)); out.flush(); out.close(); }) 查找用户名失败对应的异常是UsernameNotFoundException，而密码匹配失败对应的异常是BadCredentialsException，但实际上总是抛出BadCredentialsException异常 public Authentication authenticate(Authentication authentication) throws AuthenticationException { try { user = retrieveUser(username, (UsernamePasswordAuthenticationToken) authentication); } catch (UsernameNotFoundException notFound) { logger.debug(&quot;User &#39;&quot; + username + &quot;&#39; not found&quot;); if (hideUserNotFoundExceptions) { thrownew BadCredentialsException(messages.getMessage( &quot;AbstractUserDetailsAuthenticationProvider.badCredentials&quot;, &quot;Bad credentials&quot;)); } else { throw notFound; } } } 从源码中可以看出，因为hideUserNotFoundExceptions的值总是为true，所以抛出的UsernameNotFoundException总是被捕获 JSON交互如果不想让未认证的用户重定向到登录页面，则需要重写AuthenticationEntryPoint中接口实现类LoginUrlAuthenticationEntryPoint的commence方法： /** * Performs the redirect (or forward) to the login form URL. */ public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) { String redirectUrl = null; if (useForward) { if (forceHttps &amp;&amp; &quot;http&quot;.equals(request.getScheme())) { redirectUrl = buildHttpsRedirectUrlForRequest(request); } if (redirectUrl == null) { String loginForm = determineUrlToUseForThisRequest(request, response, authException); if (logger.isDebugEnabled()) { logger.debug(&quot;Server side forward to: &quot; + loginForm); } RequestDispatcher dispatcher = request.getRequestDispatcher(loginForm); dispatcher.forward(request, response); return; } } else { redirectUrl = buildRedirectUrlToLoginPage(request, response, authException); } redirectStrategy.sendRedirect(request, response, redirectUrl); } 可以看到默认useForward的值为false，所以请求总是走到重定向，因此自定义配置如下： .csrf().disable().exceptionHandling() .authenticationEntryPoint((req, resp, authException) -&gt; { resp.setContentType(&quot;application/json;charset=utf-8&quot;); PrintWriter out = resp.getWriter(); out.write(&quot;尚未登录，请先登录&quot;); out.flush(); out.close(); } ); 也可以配置注销成功后只返回JSON： .and() .logout() .logoutUrl(&quot;/logout&quot;) .logoutSuccessHandler((req, resp, authentication) -&gt; { resp.setContentType(&quot;application/json;charset=utf-8&quot;); PrintWriter out = resp.getWriter(); out.write(&quot;注销成功&quot;); out.flush(); out.close(); }) .permitAll() .and() 自定义授权数据库模型配置数据库连接和数据源，为用户实体类建表，用户实体类需要实现UserDetails接口，并实现接口方法： public class User implements UserDetails { private Long id; private String username; private String password; private boolean accountNonExpired; private boolean accountNonLocked; private boolean credentialsNonExpired; private boolean enabled; @ManyToMany(fetch = FetchType.EAGER,cascade = CascadeType.PERSIST) private List&lt;Role&gt; roles; @Override public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() { List&lt;SimpleGrantedAuthority&gt; authorities = new ArrayList&lt;&gt;(); for (Role role : getRoles()) { authorities.add(new SimpleGrantedAuthority(role.getName())); } return authorities; } @Override public String getPassword() { return password; } @Override public String getUsername() { return username; } @Override public boolean isAccountNonExpired() { return accountNonExpired; } @Override public boolean isAccountNonLocked() { return accountNonLocked; } @Override public boolean isCredentialsNonExpired() { return credentialsNonExpired; } @Override public boolean isEnabled() { return enabled; } //省略其他 get/set 方法 } accountNonExpired、accountNonLocked、credentialsNonExpired、enabled这四个属性分别用来描述用户的状态，表示账户是否没有过期、账户是否没有被锁定、密码是否没有过期、以及账户是否可用。 roles属性表示用户的角色，User和Role是多对多关系。getAuthorities方法返回用户的角色信息 然后自定义UserService实现UserDetailsService接口，实现loadUserByUsername方法，参数就是用户登录时传入的用户名，根据用户名去查询用户信息（查出来之后，系统会自动进行密码比对）。 @Service public class HrService implements UserDetailsService { @Autowired HrMapper hrMapper; @Autowired HrRoleMapper hrRoleMapper; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException { Hr hr = hrMapper.loadUserByUsername(username); if (hr == null) { throw new UsernameNotFoundException(&quot;用户名不存在!&quot;); } hr.setRoles(hrMapper.getHrRolesById(hr.getId())); return hr; } // ... } 在SecurityConfig中配置用户： @Autowired UserService userService; @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { auth.userDetailsService(userService); } 配置登录验证码编写验证码生成类： /** * 生成验证码的工具类 */ public class VerifyCode { private int width = 100;// 生成验证码图片的宽度 private int height = 50;// 生成验证码图片的高度 private String[] fontNames = { &quot;宋体&quot;, &quot;楷体&quot;, &quot;隶书&quot;, &quot;微软雅黑&quot; }; private Color bgColor = new Color(255, 255, 255);// 定义验证码图片的背景颜色为白色 private Random random = new Random(); private String codes = &quot;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;; private String text;// 记录随机字符串 /** * 获取一个随意颜色 * * @return */ private Color randomColor() { int red = random.nextInt(150); int green = random.nextInt(150); int blue = random.nextInt(150); returnnew Color(red, green, blue); } /** * 获取一个随机字体 * * @return */ private Font randomFont() { String name = fontNames[random.nextInt(fontNames.length)]; int style = random.nextInt(4); int size = random.nextInt(5) + 24; returnnew Font(name, style, size); } /** * 获取一个随机字符 * * @return */ private char randomChar() { return codes.charAt(random.nextInt(codes.length())); } /** * 创建一个空白的BufferedImage对象 * * @return */ private BufferedImage createImage() { BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB); Graphics2D g2 = (Graphics2D) image.getGraphics(); g2.setColor(bgColor);// 设置验证码图片的背景颜色 g2.fillRect(0, 0, width, height); return image; } public BufferedImage getImage() { BufferedImage image = createImage(); Graphics2D g2 = (Graphics2D) image.getGraphics(); StringBuffer sb = new StringBuffer(); for (int i = 0; i &lt; 4; i++) { String s = randomChar() + &quot;&quot;; sb.append(s); g2.setColor(randomColor()); g2.setFont(randomFont()); float x = i * width * 1.0f / 4; g2.drawString(s, x, height - 15); } this.text = sb.toString(); drawLine(image); return image; } /** * 绘制干扰线 * * @param image */ private void drawLine(BufferedImage image) { Graphics2D g2 = (Graphics2D) image.getGraphics(); int num = 5; for (int i = 0; i &lt; num; i++) { int x1 = random.nextInt(width); int y1 = random.nextInt(height); int x2 = random.nextInt(width); int y2 = random.nextInt(height); g2.setColor(randomColor()); g2.setStroke(new BasicStroke(1.5f)); g2.drawLine(x1, y1, x2, y2); } } public String getText() { return text; } public static void output(BufferedImage image, OutputStream out) throws IOException { ImageIO.write(image, &quot;JPEG&quot;, out); } } 通过流将验证码写到前端页面&lt;img src=&quot;/vercode&quot; alt=&quot;&quot;&gt;： @RestController public class VerifyCodeController { @GetMapping(&quot;/vercode&quot;) public void code(HttpServletRequest req, HttpServletResponse resp) throws IOException { VerifyCode vc = new VerifyCode(); // 创建一个 VerifyCode 对象 BufferedImage image = vc.getImage(); String text = vc.getText(); HttpSession session = req.getSession(); session.setAttribute(&quot;index_code&quot;, text); // 将生成的验证码字符保存到 session 中 VerifyCode.output(image, resp.getOutputStream()); } } 用户登录的用户名/密码是在UsernamePasswordAuthenticationFilter类中处理的： public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException { String username = obtainUsername(request); String password = obtainPassword(request); //省略 } protected String obtainPassword(HttpServletRequest request) { return request.getParameter(passwordParameter); } protected String obtainUsername(HttpServletRequest request) { return request.getParameter(usernameParameter); } SpringSecurity默认通过key/value的形式来传递登录参数，因此可以自定义一个过滤器来代替UsernamePasswordAuthenticationFilter，然后获取JSON形式数据 publicclass LoginFilter extends UsernamePasswordAuthenticationFilter { @Override public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException { if (!request.getMethod().equals(&quot;POST&quot;)) { // 登录请求肯定是 POST throw new AuthenticationServiceException( &quot;Authentication method not supported: &quot; + request.getMethod()); } String verify_code = (String) request.getSession().getAttribute(&quot;verify_code&quot;); // 处理验证码 if (request.getContentType().equals(MediaType.APPLICATION_JSON_VALUE) || request.getContentType().equals(MediaType.APPLICATION_JSON_UTF8_VALUE)) { Map&lt;String, String&gt; loginData = new HashMap&lt;&gt;(); try { // 通过读取 request 中的 I/O 流，将 JSON 映射到一个 Map 上 loginData = new ObjectMapper().readValue(request.getInputStream(), Map.class); } catch (IOException e) { }finally { String code = loginData.get(&quot;code&quot;); checkCode(response, code, verify_code); } String username = loginData.get(getUsernameParameter()); String password = loginData.get(getPasswordParameter()); if (username == null) { username = &quot;&quot;; } if (password == null) { password = &quot;&quot;; } username = username.trim(); UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationToken( username, password); setDetails(request, authRequest); return this.getAuthenticationManager().authenticate(authRequest); } else { checkCode(response, request.getParameter(&quot;code&quot;), verify_code); // 既支持 JSON 形式传递参数，也支持 key/value 形式传递参数 return super.attemptAuthentication(request, response); } } public void checkCode(HttpServletResponse resp, String code, String verify_code) { if (code == null || verify_code == null || &quot;&quot;.equals(code) || !verify_code.toLowerCase().equals(code.toLowerCase())) { //验证码不正确 throw new AuthenticationServiceException(&quot;验证码不正确&quot;); } } } 提供一个LoginFilter的实例，原本在SecurityConfig#configure方法中关于form表单的配置就会失效，那些失效的属性，都可以在配置LoginFilter实例的时候配置。 @Bean LoginFilter loginFilter() throws Exception { LoginFilter loginFilter = new LoginFilter(); loginFilter.setAuthenticationSuccessHandler(new AuthenticationSuccessHandler() { @Override public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException { response.setContentType(&quot;application/json;charset=utf-8&quot;); PrintWriter out = response.getWriter(); Hr hr = (Hr) authentication.getPrincipal(); hr.setPassword(null); RespBean ok = RespBean.ok(&quot;登录成功!&quot;, hr); String s = new ObjectMapper().writeValueAsString(ok); out.write(s); out.flush(); out.close(); } }); loginFilter.setAuthenticationFailureHandler(new AuthenticationFailureHandler() { @Override public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception) throws IOException, ServletException { response.setContentType(&quot;application/json;charset=utf-8&quot;); PrintWriter out = response.getWriter(); RespBean respBean = RespBean.error(exception.getMessage()); if (exception instanceof LockedException) { respBean.setMsg(&quot;账户被锁定，请联系管理员!&quot;); } elseif (exception instanceof CredentialsExpiredException) { respBean.setMsg(&quot;密码过期，请联系管理员!&quot;); } elseif (exception instanceof AccountExpiredException) { respBean.setMsg(&quot;账户过期，请联系管理员!&quot;); } elseif (exception instanceof DisabledException) { respBean.setMsg(&quot;账户被禁用，请联系管理员!&quot;); } elseif (exception instanceof BadCredentialsException) { respBean.setMsg(&quot;用户名或者密码输入错误，请重新输入!&quot;); } out.write(new ObjectMapper().writeValueAsString(respBean)); out.flush(); out.close(); } }); loginFilter.setAuthenticationManager(authenticationManagerBean()); // 根据 WebSecurityConfigurerAdapter 中提供的配置 loginFilter.setFilterProcessesUrl(&quot;/doLogin&quot;); // 默认是 /login return loginFilter; } 最后调用addFilterAt方法完成替换操作： @Override protected void configure(HttpSecurity http) throws Exception { http.authorizeRequests() ... //省略 http.addFilterAt(loginFilter(), UsernamePasswordAuthenticationFilter.class); } 自动登录认证原理SpringSecurity中有个重要对象Authentication，可以在任何地方注入它以获得当前登录用户信息，它本身是一个接口，最常用的实现类就是UsernamePasswordAuthenticationToken，这个类及其父类的属性就保存了登录用户的基本信息。那么登录信息是如何存到两个对象里的？ SpringSecurity中，认证和授权的相关校验都是在一系列的过滤器链中完成的，而认证相关的就是UsernamePasswordAuthenticationFilter。 public class UsernamePasswordAuthenticationFilter extends AbstractAuthenticationProcessingFilter { public UsernamePasswordAuthenticationFilter() { super(new AntPathRequestMatcher(&quot;/login&quot;, &quot;POST&quot;)); } public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException { String username = obtainUsername(request); String password = obtainPassword(request); UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationToken( username, password); setDetails(request, authRequest); returnthis.getAuthenticationManager().authenticate(authRequest); } protected String obtainPassword(HttpServletRequest request) { return request.getParameter(passwordParameter); } protected String obtainUsername(HttpServletRequest request) { return request.getParameter(usernameParameter); } protected void setDetails(HttpServletRequest request, UsernamePasswordAuthenticationToken authRequest) { authRequest.setDetails(authenticationDetailsSource.buildDetails(request)); } } 首先通过obtainUsername和obtainPassword提取请求里的用户名和密码，因此默认的表单登录要通过key/value形式传递参数 接下来构造UsernamePasswordAuthenticationToken对象，传入的参数分别对应其中的principal属性和credentials属性 然后通过setDetails方法给其details属性赋值（属性在父类AbstractAuthenticationToken（实现了Authentication接口）中定义），details是一个对象，里面存放WebAuthenticationDetails实例，其中主要描述了请求的remoteAddress和sessionId 调用authenticate方法进行校验 其中校验操作首先要获取一个AuthenticationManager，拿到的是ProviderManager，因此进入其authenticate方法中： public Authentication authenticate(Authentication authentication) throws AuthenticationException { Class&lt;? extends Authentication&gt; toTest = authentication.getClass(); for (AuthenticationProvider provider : getProviders()) { if (!provider.supports(toTest)) { continue; } result = provider.authenticate(authentication); if (result != null) { copyDetails(authentication, result); break; } } if (result == null &amp;&amp; parent != null) { result = parentResult = parent.authenticate(authentication); } if (result != null) { if (eraseCredentialsAfterAuthentication &amp;&amp; (result instanceof CredentialsContainer)) { ((CredentialsContainer) result).eraseCredentials(); } if (parentResult == null) { eventPublisher.publishAuthenticationSuccess(result); } return result; } throw lastException; } 首先获取authentication的Class，判断当前provider是否支持该authentication 如果支持，则调用provider的authenticate方法开始做校验，校验完成后，会返回一个新的Authentication 这里的provider可能有多个，如果provider的authenticate方法没能正常返回一个Authentication，则调用provider的parent的authenticate方法继续校验 copyDetails方法则用来把旧Token的details属性拷贝到新的Token中来 接下来会调用eraseCredentials方法擦除凭证信息，也就是密码，这个擦除方法比较简单，就是将Token中的credentials属性置空 最后通过publishAuthenticationSuccess方法将登录成功的事件广播出去 需要注意的是，方法中的for循环里，第一个拿到的provider是一个AnonymousAuthenticationProvider，它不支持UsernamePasswordAuthenticationToken，因此会直接调用parent的authenticate方法进行校验。 而这个parent就是ProviderManager，因此会再次回到authenticate方法，provider也变成了DaoAuthenticationProvider，它是支持UsernamePasswordAuthenticationToken的，它继承自父类AbstractUserDetailsAuthenticationProvider，并且没有重写其authenticate方法，因此直接调用这个方法： public Authentication authenticate(Authentication authentication) throws AuthenticationException { String username = (authentication.getPrincipal() == null) ? &quot;NONE_PROVIDED&quot; : authentication.getName(); user = retrieveUser(username,(UsernamePasswordAuthenticationToken) authentication); preAuthenticationChecks.check(user); additionalAuthenticationChecks(user,(UsernamePasswordAuthenticationToken) authentication); postAuthenticationChecks.check(user); Object principalToReturn = user; if (forcePrincipalAsString) { principalToReturn = user.getUsername(); } return createSuccessAuthentication(principalToReturn, authentication, user); } 首先从·Authentication中提取登录用户名 通过拿到的username去调用retrieveUser方法获取当前用户对象，此时会调用loadUserByUsername方法，所以这里返回的user其实就是登录对象 接下来调用preAuthenticationChecks.check方法检验user中的各个账户状态属性是否正常，例如账户是否被禁用、账户是否被锁定、账户是否过期等等 additionalAuthenticationChecks方法则是做密码比对的 最后在postAuthenticationChecks.check方法中检查密码是否过期 接下来有一个forcePrincipalAsString属性，这个是是否强制将Authentication中的principal属性设置为字符串，默认为false 最后，通过createSuccessAuthentication方法构建一个新的UsernamePasswordAuthenticationToken 来到UsernamePasswordAuthenticationFilter的父类AbstractAuthenticationProcessingFilter中，如果需要自定义过滤器，都需要继承自这个类，而UsernamePasswordAuthenticationFilter的attemptAuthentication方法就是在这个父类的doFilter中被触发的： public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException { HttpServletRequest request = (HttpServletRequest) req; HttpServletResponse response = (HttpServletResponse) res; Authentication authResult; try { authResult = attemptAuthentication(request, response); if (authResult == null) { return; } sessionStrategy.onAuthentication(authResult, request, response); } catch (InternalAuthenticationServiceException failed) { unsuccessfulAuthentication(request, response, failed); return; } catch (AuthenticationException failed) { unsuccessfulAuthentication(request, response, failed); return; } if (continueChainBeforeSuccessfulAuthentication) { chain.doFilter(request, response); } successfulAuthentication(request, response, chain, authResult); } 当attemptAuthentication方法被调用时，如果登录成功，successAuthentication方法就会被调用： protected void successfulAuthentication(HttpServletRequest request, HttpServletResponse response, FilterChain chain, Authentication authResult) throws IOException, ServletException { SecurityContextHolder.getContext().setAuthentication(authResult); rememberMeServices.loginSuccess(request, response, authResult); // Fire event if (this.eventPublisher != null) { eventPublisher.publishEvent(new InteractiveAuthenticationSuccessEvent( authResult, this.getClass())); } successHandler.onAuthenticationSuccess(request, response, authResult); } 其中可以看出，登录的用户信息可以通过SecurityContextHolder.getContext()获得，如果想要修改，也可以在这里修改。并且从最后的successHandler.onAuthenticationSuccess可以看出，SecurityConfig中配置登录成功的回调方法就是在这里触发的。 需要注意的是，SecurityContextHolder中的数据，本质是保存在ThreadLocal中，它的限制了仅有保存该数据的线程才能访问。然而正常情况下，我们每次登录都能获取到登录用户信息。这是因为请求在到达UsernamePasswordAuthenticationFilter之前，会先经过另一个过滤器： public class SecurityContextPersistenceFilter extends GenericFilterBean { public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException { HttpServletRequest request = (HttpServletRequest) req; HttpServletResponse response = (HttpServletResponse) res; HttpRequestResponseHolder holder = new HttpRequestResponseHolder(request, response); SecurityContext contextBeforeChainExecution = repo.loadContext(holder); try { SecurityContextHolder.setContext(contextBeforeChainExecution); chain.doFilter(holder.getRequest(), holder.getResponse()); } finally { SecurityContext contextAfterChainExecution = SecurityContextHolder .getContext(); SecurityContextHolder.clearContext(); repo.saveContext(contextAfterChainExecution, holder.getRequest(), holder.getResponse()); } } } SecurityContextPersistenceFilter继承自 GenericFilterBean，而GenericFilterBean则是Filter的实现 在doFilter方法中，它首先会从repo中读取一个SecurityContext出来，这里的repo实际上就是HttpSessionSecurityContextRepository，读取SecurityContext的操作会进入到readSecurityContextFromSession方法中，进入读取的核心方法Object contextFromSession = httpSession.getAttribute(springSecurityContextKey);，而这里的springSecurityContextKey实际上就是SPRING_SECURITY_CONTEXT，读取出来的对象最终会被转为一个SecurityContext对象 SecurityContext是一个接口，它有一个唯一的实现类SecurityContextImpl，这个实现类其实就是用户信息在session中保存的value 在拿到SecurityContext之后，通过SecurityContextHolder.setContext方法将这个SecurityContext设置到ThreadLocal中去 在过滤器链走完，数据响应给前端之后，从SecurityContextHolder中获取到SecurityContext，然后把SecurityContextHolder清空，最后调用repo.saveContext方法将获取到的SecurityContext存入session中 因此可以发现，如果登录请求不走SecurityContextPersistenceFilter过滤器，意味着不会将登录信息存入session，进而导致后续请求无法获取到用户信息 记住我在SpringSecurity中配置即可： @Override protected void configure(HttpSecurity http) throws Exception { http.authorizeRequests() .anyRequest().authenticated() .and() .formLogin() .and() .rememberMe() // 开启自动登录 .key(&quot;javaboy&quot;) // 设置令牌密钥 .and() .csrf().disable(); } 此时可以发现浏览器cookie中多了个remember-me令牌，其生成过程如下，核心的处理方法在TokenBasedRememberMeServices中： @Override public void onLoginSuccess(HttpServletRequest request, HttpServletResponse response, Authentication successfulAuthentication) { String username = retrieveUserName(successfulAuthentication); String password = retrievePassword(successfulAuthentication); if (!StringUtils.hasLength(password)) { UserDetails user = getUserDetailsService().loadUserByUsername(username); password = user.getPassword(); } int tokenLifetime = calculateLoginLifetime(request, successfulAuthentication); long expiryTime = System.currentTimeMillis(); expiryTime += 1000L * (tokenLifetime &lt; 0 ? TWO_WEEKS_S : tokenLifetime); String signatureValue = makeTokenSignature(expiryTime, username, password); setCookie(new String[] { username, Long.toString(expiryTime), signatureValue }, tokenLifetime, request, response); } protected String makeTokenSignature(long tokenExpiryTime, String username, String password) { String data = username + &quot;:&quot; + tokenExpiryTime + &quot;:&quot; + password + &quot;:&quot; + getKey(); MessageDigest digest; digest = MessageDigest.getInstance(&quot;MD5&quot;); return new String(Hex.encode(digest.digest(data.getBytes()))); } 首先从登录成功的Authentication中提取出用户名/密码 由于登录成功之后，密码可能被擦除了，所以，如果一开始没有拿到密码，就再从UserDetailsService中重新加载用户并重新获取密码 再接下来去获取令牌的有效期，令牌有效期默认就是两周 再接下来调用makeTokenSignature方法去计算散列值，实际上就是根据username、令牌有效期以及password、key一起计算一个散列值。如果我们没有自己去设置这个key，默认是在RememberMeConfigurer#getKey方法中进行设置的，它的值是一个UUID字符串 最后，将用户名、令牌有效期以及计算得到的散列值放入Cookie中 需要注意的是，如果服务端重启，自动生成的key就会变化，导致之前的remember-me令牌失效，因此需要自己配置key。触发流程是：AbstractAuthenticationProcessingFilter#doFilter-&gt;AbstractAuthenticationProcessingFilter#successfulAuthentication-&gt;AbstractRememberMeServices#loginSuccess-&gt;TokenBasedRememberMeServices#onLoginSuccess 认证过程则可以从RememberMeAuthenticationFilter过滤器中看到： public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException { HttpServletRequest request = (HttpServletRequest) req; HttpServletResponse response = (HttpServletResponse) res; if (SecurityContextHolder.getContext().getAuthentication() == null) { Authentication rememberMeAuth = rememberMeServices.autoLogin(request, response); if (rememberMeAuth != null) { rememberMeAuth = authenticationManager.authenticate(rememberMeAuth); SecurityContextHolder.getContext().setAuthentication(rememberMeAuth); onSuccessfulAuthentication(request, response, rememberMeAuth); if (this.eventPublisher != null) { eventPublisher .publishEvent(new InteractiveAuthenticationSuccessEvent( SecurityContextHolder.getContext() .getAuthentication(), this.getClass())); } if (successHandler != null) { successHandler.onAuthenticationSuccess(request, response, rememberMeAuth); return; } } chain.doFilter(request, response); } else { chain.doFilter(request, response); } } 可以看到，如果从SecurityContextHolder中无法获取当前登录用户实例，那么就调用rememberMeServices.autoLogin进行登录： public final Authentication autoLogin(HttpServletRequest request, HttpServletResponse response) { String rememberMeCookie = extractRememberMeCookie(request); if (rememberMeCookie == null) { return null; } logger.debug(&quot;Remember-me cookie detected&quot;); if (rememberMeCookie.length() == 0) { logger.debug(&quot;Cookie was empty&quot;); cancelCookie(request, response); return null; } UserDetails user = null; try { String[] cookieTokens = decodeCookie(rememberMeCookie); user = processAutoLoginCookie(cookieTokens, request, response); userDetailsChecker.check(user); logger.debug(&quot;Remember-me cookie accepted&quot;); return createSuccessfulAuthentication(request, user); } catch (CookieTheftException cte) { throw cte; } cancelCookie(request, response); return null; } 这里就是提取cookie信息，并对cookie信息进行解码，然后调用processAutoLoginCookie方法做校验，核心流程就是首先获取用户名和过期时间，再根据用户名查询到用户密码，然后通过MD5散列函数计算出散列值，在将拿到的散列值和浏览器传递来的散列值进行对比，就能确认这个令牌是否有效，进而确认登录是否有效。 有时为了提高安全性，需要做持久化令牌和二次校验。在持久化令牌中，新增了两个经过MD5散列函数计算的校验参数，一个是series，另一个是token。其中，series只有当用户在使用用户名/密码登录时，才会生成或者更新，而token只要有新的会话，就会重新生成，这样就可以避免一个用户同时在多端登录。 持久化令牌的具体处理类是PersistentTokenBasedRememberMeServices，保存令牌的处理类则是PersistentRememberMeToken： public class PersistentRememberMeToken { private final String username; private final String series; private final String tokenValue; private final Date date; // 表示上一次使用自动登录的时间 // 省略 getter、setter方法 } 首先需要一张表来记录令牌信息，可以使用系统默认提供的JDBC来操作JdbcTokenRepositoryImpl： @Autowired DataSource dataSource; @Bean JdbcTokenRepositoryImpl jdbcTokenRepository() { JdbcTokenRepositoryImpl jdbcTokenRepository = new JdbcTokenRepositoryImpl(); jdbcTokenRepository.setDataSource(dataSource); return jdbcTokenRepository; } @Override protected void configure(HttpSecurity http) throws Exception { http.authorizeRequests() .anyRequest().authenticated() .and() .formLogin() .and() .rememberMe() .key(&quot;javaboy&quot;) .tokenRepository(jdbcTokenRepository()) .and() .csrf().disable(); } 通过提供一个JdbcTokenRepositoryImpl实例，给其配置DataSource数据源，最后通过tokenRepository将其纳入配置中即可。 这时生成/解析令牌的实现类是PersistentTokenBasedRememberMeServices，令牌生成过程对应的方法是： protected void onLoginSuccess(HttpServletRequest request, HttpServletResponse response, Authentication successfulAuthentication) { String username = successfulAuthentication.getName(); PersistentRememberMeToken persistentToken = new PersistentRememberMeToken( username, generateSeriesData(), generateTokenData(), new Date()); tokenRepository.createNewToken(persistentToken); addCookie(persistentToken, request, response); } protected String generateSeriesData() { byte[] newSeries = new byte[seriesLength]; random.nextBytes(newSeries); return new String(Base64.getEncoder().encode(newSeries)); } protected String generateTokenData() { byte[] newToken = new byte[tokenLength]; random.nextBytes(newToken); return new String(Base64.getEncoder().encode(newToken)); } private void addCookie(PersistentRememberMeToken token, HttpServletRequest request, HttpServletResponse response) { setCookie(new String[] { token.getSeries(), token.getTokenValue() }, getTokenValiditySeconds(), request, response); } 登录成功后，还是首先获取到用户名username 然后构造一个PersistentRememberMeToken，generateSeriesData和generateTokenData方法分别用来获取series和token，具体的生成过程实际上就是调用SecureRandom生成随机数再进行Base64编码，SecureRandom则采用的是类似于密码学的随机数生成规则，其输出结果较难预测，适合在登录这样的场景下使用 调用tokenRepository实例中的createNewToken方法，tokenRepository实际上就是我们一开始配置的JdbcTokenRepositoryImpl，所以这行代码实际上就是将PersistentRememberMeToken存入数据库中 令牌校验过程对应的方法是： protected UserDetails processAutoLoginCookie(String[] cookieTokens, HttpServletRequest request, HttpServletResponse response) { final String presentedSeries = cookieTokens[0]; final String presentedToken = cookieTokens[1]; PersistentRememberMeToken token = tokenRepository .getTokenForSeries(presentedSeries); if (!presentedToken.equals(token.getTokenValue())) { tokenRepository.removeUserTokens(token.getUsername()); throw new CookieTheftException( messages.getMessage( &quot;PersistentTokenBasedRememberMeServices.cookieStolen&quot;, &quot;Invalid remember-me token (Series/token) mismatch. Implies previous cookie theft attack.&quot;)); } if (token.getDate().getTime() + getTokenValiditySeconds() * 1000L &lt; System .currentTimeMillis()) { throw new RememberMeAuthenticationException(&quot;Remember-me login has expired&quot;); } PersistentRememberMeToken newToken = new PersistentRememberMeToken( token.getUsername(), token.getSeries(), generateTokenData(), new Date()); tokenRepository.updateToken(newToken.getSeries(), newToken.getTokenValue(), newToken.getDate()); addCookie(newToken, request, response); return getUserDetailsService().loadUserByUsername(token.getUsername()); } 首先从前端传来的cookie中解析出series和token 根据series从数据库中查询出一个PersistentRememberMeToken实例 如果查出来的token和前端传来的token不相同，说明账号可能被人盗用（别人用你的令牌登录之后，token会变）。此时根据用户名移除相关的token，相当于必须要重新输入用户名密码登录才能获取新的自动登录权限 校验token是否过期 构造新的PersistentRememberMeToken对象，并且更新数据库中的token，新的会话都会对应一个新的token 将新的令牌重新添加到cookie中返回 根据用户名查询用户信息，再走一遍登录流程 二次检验则可以通过配置接口访问来实现： @Override protected void configure(HttpSecurity http) throws Exception { http.authorizeRequests() .antMatchers(&quot;/rememberme&quot;).rememberMe() // 需要 rememberMe 才能访问 .antMatchers(&quot;/admin&quot;).fullyAuthenticated() // 不同于 authenticated，fullyAuthenticated 不包含自动登录的形式 .anyRequest().authenticated() .and() .formLogin() .and() .rememberMe() .key(&quot;javaboy&quot;) .tokenRepository(jdbcTokenRepository()) .and() .csrf().disable(); } 设置会话数想用新的登录踢掉旧的登录，只需要将最大会话数设置为1即可，或者设置禁止后面的登录操作： @Override protected void configure(HttpSecurity http) throws Exception { http.authorizeRequests() .anyRequest().authenticated() .and() .formLogin() .loginPage(&quot;/login.html&quot;) .permitAll() .and() .csrf().disable() .sessionManagement() .maximumSessions(1); // 配置最大会话数为 1 .maxSessionsPreventsLogin(true); // 禁止新的登录操作 } 还需要再提供一个Bean： @Bean HttpSessionEventPublisher httpSessionEventPublisher() { return new HttpSessionEventPublisher(); } 在SpringSecurity中，它是通过监听session的销毁事件，来及时清理session的记录。用户从不同的浏览器登录后，都会有对应的session，当用户注销登录之后，session就会失效，但是默认的失效是通过调用StandardSession#invalidate方法来实现的，这一个失效事件无法被Spring容器感知到，进而导致当用户注销登录之后，SpringSecurity没有及时清理会话信息表，以为用户还在线，进而导致用户无法重新登录进来。 因此提供一个实现了HttpSessionListener接口的类，在该Bean中，可以将session创建以及销毁的事件及时感知到，并且调用Spring中的事件机制将相关的创建和销毁事件发布出去，进而被SpringSecurity感知到： public void sessionCreated(HttpSessionEvent event) { HttpSessionCreatedEvent e = new HttpSessionCreatedEvent(event.getSession()); getContext(event.getSession().getServletContext()).publishEvent(e); } public void sessionDestroyed(HttpSessionEvent event) { HttpSessionDestroyedEvent e = new HttpSessionDestroyedEvent(event.getSession()); getContext(event.getSession().getServletContext()).publishEvent(e); } 事实上AbstractAuthenticationProcessingFilter#doFilter方法调用中，走完认证流程后，接下来就是调用sessionStrategy.onAuthentication方法，这个方法就是用来处理session并发问题的： public class ConcurrentSessionControlAuthenticationStrategy implements MessageSourceAware, SessionAuthenticationStrategy { public void onAuthentication(Authentication authentication, HttpServletRequest request, HttpServletResponse response) { final List&lt;SessionInformation&gt; sessions = sessionRegistry.getAllSessions( authentication.getPrincipal(), false); int sessionCount = sessions.size(); int allowedSessions = getMaximumSessionsForThisUser(authentication); if (sessionCount &lt; allowedSessions) { // They haven&#39;t got too many login sessions running at present return; } if (allowedSessions == -1) { // We permit unlimited logins return; } if (sessionCount == allowedSessions) { HttpSession session = request.getSession(false); if (session != null) { // Only permit it though if this request is associated with one of the // already registered sessions for (SessionInformation si : sessions) { if (si.getSessionId().equals(session.getId())) { return; } } } // If the session is null, a new one will be created by the parent class, // exceeding the allowed number } allowableSessionsExceeded(sessions, allowedSessions, sessionRegistry); } protected void allowableSessionsExceeded(List&lt;SessionInformation&gt; sessions, int allowableSessions, SessionRegistry registry) throws SessionAuthenticationException { if (exceptionIfMaximumExceeded || (sessions == null)) { throw new SessionAuthenticationException(messages.getMessage( &quot;ConcurrentSessionControlAuthenticationStrategy.exceededAllowed&quot;, new Object[] {allowableSessions}, &quot;Maximum sessions of {0} for this principal exceeded&quot;)); } // Determine least recently used sessions, and mark them for invalidation sessions.sort(Comparator.comparing(SessionInformation::getLastRequest)); int maximumSessionsExceededBy = sessions.size() - allowableSessions + 1; List&lt;SessionInformation&gt; sessionsToBeExpired = sessions.subList(0, maximumSessionsExceededBy); for (SessionInformation session: sessionsToBeExpired) { session.expireNow(); } } } 首先调用sessionRegistry.getAllSessions方法获取当前用户的所有session，该方法在调用时，传递两个参数，一个是当前用户的authentication，另一个参数false表示不包含已经过期的session（在用户登录成功后，会将用户的sessionid存起来，其中key是用户的主体（principal），value则是该主题对应的sessionid组成的一个集合） 接下来计算出当前用户已经有几个有效session了，同时获取允许的session并发数 如果当前session数（sessionCount）小于session并发数（allowedSessions），则不做任何处理；如果allowedSessions的值为-1，表示对session数量不做任何限制；如果当前session数（sessionCount）等于session并发数，且当前session不为null，并且已经存在于session中了，那么不做任何处理，否则说明将有一个新的session被创建出来，届时当前sessionCount数就会超过allowedSessions，进入策略判断方法allowableSessionsExceeded allowableSessionsExceeded方法中，首先会有exceptionIfMaximumExceeded属性，这就是我们在SecurityConfig中配置的maxSessionsPreventsLogin的值，默认为false，如果为true，就直接抛出异常，那么这次登录就失败了，如果为false，则对sessions按照请求时间进行排序，然后再使多余的session过期 SpringSecurity中通过SessionRegistryImpl类来实现对会话信息的统一管理： public class SessionRegistryImpl implements SessionRegistry, ApplicationListener&lt;SessionDestroyedEvent&gt; { /** &lt;principal:Object,SessionIdSet&gt; */ private final ConcurrentMap&lt;Object, Set&lt;String&gt;&gt; principals; /** &lt;sessionId:Object,SessionInformation&gt; */ private final Map&lt;String, SessionInformation&gt; sessionIds; public void registerNewSession(String sessionId, Object principal) { if (getSessionInformation(sessionId) != null) { removeSessionInformation(sessionId); } sessionIds.put(sessionId, new SessionInformation(principal, sessionId, new Date())); principals.compute(principal, (key, sessionsUsedByPrincipal) -&gt; { if (sessionsUsedByPrincipal == null) { sessionsUsedByPrincipal = new CopyOnWriteArraySet&lt;&gt;(); } sessionsUsedByPrincipal.add(sessionId); return sessionsUsedByPrincipal; }); } public void removeSessionInformation(String sessionId) { SessionInformation info = getSessionInformation(sessionId); if (info == null) { return; } sessionIds.remove(sessionId); principals.computeIfPresent(info.getPrincipal(), (key, sessionsUsedByPrincipal) -&gt; { sessionsUsedByPrincipal.remove(sessionId); if (sessionsUsedByPrincipal.isEmpty()) { sessionsUsedByPrincipal = null; } return sessionsUsedByPrincipal; }); } } 声明的principals是一个支持并发访问的map即可，它的value是一个set集合，保存了这个用户对应的sessionId；如果新的session需要添加，就在registerNewSession方法中添加，具体是调用principals.compute方法，如果用户注销登录，sessionId需要移除，相关操作类似。它的key是principal对象，因此要重写equals方法和hashCode方法。 这一点可以从SpringSecurity中定义的基于内存的用户中看出： public class User implements UserDetails, CredentialsContainer { private String password; private final String username; private final Set&lt;GrantedAuthority&gt; authorities; private final boolean accountNonExpired; private final boolean accountNonLocked; private final boolean credentialsNonExpired; private final boolean enabled; @Override public boolean equals(Object rhs) { if (rhs instanceof User) { return username.equals(((User) rhs).username); } return false; } @Override public int hashCode() { return username.hashCode(); } } 扩展认证信息Authentication中getDetails方法用来存储有关身份认证的其他信息，比如IP地址、sessionId和证书信息等。 在用户登录必经的过滤器UsernamePasswordAuthenticationFilter中，attemptAuthentication方法里有一个setDetails方法： protected void setDetails(HttpServletRequest request, UsernamePasswordAuthenticationToken authRequest) { authRequest.setDetails(authenticationDetailsSource.buildDetails(request)); } details的值是通过authenticationDetailsSource构建的： public class WebAuthenticationDetailsSource implements AuthenticationDetailsSource&lt;HttpServletRequest, WebAuthenticationDetails&gt; { public WebAuthenticationDetails buildDetails(HttpServletRequest context) { return new WebAuthenticationDetails(context); } } public class WebAuthenticationDetails implements Serializable { private final String remoteAddress; private final String sessionId; public WebAuthenticationDetails(HttpServletRequest request) { this.remoteAddress = request.getRemoteAddr(); HttpSession session = request.getSession(false); this.sessionId = (session != null) ? session.getId() : null; } //省略其他方法 } 实际上构建的是WebAuthenticationDetails，其中定义了用户登录地址和sessionId，而这个类可以自己定制，那么WebAuthenticationDetailsSource也需要重新定义： public class MyWebAuthenticationDetails extends WebAuthenticationDetails { public MyWebAuthenticationDetails(HttpServletRequest req) { super(req); // ... } // ... } @Component public class MyWebAuthenticationDetailsSource implements AuthenticationDetailsSource&lt;HttpServletRequest,MyWebAuthenticationDetails&gt; { @Override public MyWebAuthenticationDetails buildDetails(HttpServletRequest context) { return new MyWebAuthenticationDetails(context); } } 如果要扩展属性，只需要在WebAuthenticationDetails中定义更多属性，然后从HttpServletRequest中提取出来设置给对应的属性即可，登录成功后就可以随时随地获取这些属性了。最后需要在SecurityConfig中配置： @Autowired MyWebAuthenticationDetailsSource myWebAuthenticationDetailsSource; @Override protected void configure(HttpSecurity http) throws Exception { http.authorizeRequests() ... .and() .formLogin() .authenticationDetailsSource(myWebAuthenticationDetailsSource) ... } 防火墙SpringSecurity中提供了HttpFirewall，它可以自动处理一些非法请求。它有两个实现类：DefaultHttpFirewall和StrictHttpFirewall，前者的限制相比后者宽松，SpringSecurity中默认使用后者。 public class StrictHttpFirewall implements HttpFirewall { private Set&lt;String&gt; allowedHttpMethods = createDefaultAllowedHttpMethods(); private static Set&lt;String&gt; createDefaultAllowedHttpMethods() { Set&lt;String&gt; result = new HashSet&lt;&gt;(); result.add(HttpMethod.DELETE.name()); result.add(HttpMethod.GET.name()); result.add(HttpMethod.HEAD.name()); result.add(HttpMethod.OPTIONS.name()); result.add(HttpMethod.PATCH.name()); result.add(HttpMethod.POST.name()); result.add(HttpMethod.PUT.name()); return result; } private void rejectForbiddenHttpMethod(HttpServletRequest request) { if (this.allowedHttpMethods == ALLOW_ANY_HTTP_METHOD) { return; } if (!this.allowedHttpMethods.contains(request.getMethod())) { throw new RequestRejectedException(&quot;The request was rejected because the HTTP method \\&quot;&quot; + request.getMethod() + &quot;\\&quot; was not included within the whitelist &quot; + this.allowedHttpMethods); } } } HTTP请求方法必须是DELETE、GET、HEAD、OPTIONS、PATCH、POST 以及 PUT中的一个，请求才能发送成功，否则的话，就会抛出RequestRejectedException异常。如果向发送其他HTTP请求，比如TRACE，需要自己提供一个StrictHttpFirewall实例： @Bean HttpFirewall httpFirewall() { StrictHttpFirewall firewall = new StrictHttpFirewall(); firewall.setUnsafeAllowAnyHttpMethod(true); // 表示不做 HTTP 请求方法校验，表示任何请求方法都可以通过，也可以通过 setAllowedHttpMethods 方法重新定义可以通过的方法 return firewall; } 防御会话固定攻击HttpSession是一个服务端的概念，服务端生成的HttpSession都会有一个对应的sessionid，这个sessionid会通过cookie传递给前端，前端以后发送请求的时候，就带上这个sessionid参数，服务端看到这个sessionid就会把这个前端请求和服务端的某一个HttpSession对应起来，形成“会话”的感觉。 浏览器关闭并不会导致服务端的HttpSession失效，想让服务端的HttpSession失效，要么手动调用HttpSession#invalidate方法；要么等到session自动过期，要么重启服务端。事实上默认情况下，浏览器再次访问服务端的时候，服务端会给浏览器重新分配一个sessionId。 在服务端的响应头中有一个Set-Cookie字段，该字段指示浏览器更新sessionid，同时还有一个HttpOnly属性，这个表示通过JS脚本无法读取到Cookie信息，这样能有效的防止XSS攻击。 只要不关闭浏览器，并且服务端的HttpSession也没有过期，那么维系服务端和浏览器的sessionid是不会发生变化的，而会话固定攻击，则是利用这一机制，借助受害者用相同的会话ID获取认证和授权，然后利用该会话ID劫持受害者的会话以成功冒充受害者，造成会话固定攻击。 SpringSecurity中防御会话固定攻击主要体现在三个方面： 请求地址中有;，请求会被直接拒绝 响应的Set-Cookie字段中有HttpOnly属性，这种方式避免了通过XSS攻击来获取Cookie中的会话信息进而达成会话固定攻击 可以配置改变sessionId public class SecurityConfig extends WebSecurityConfigurerAdapter { @Override protected void configure(HttpSecurity http) throws Exception { http.authorizeRequests().anyRequest().authenticated() .and() .formLogin() .permitAll() .and() .sessionManagement() .sessionFixation().migrateSession() // 默认配置，表示登录成功之后，创建一个新的会话，将旧 session 中的信息复制到新的 session 中 // .none() // 继续使用旧 session // .changeSessionId() // session 不变，修改 sessionId，用到了 Servlet 容器提供的防御会话固定攻击 // .newSession() // 登录后创建一个新的 session } } session共享引入依赖： &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.session&lt;/groupId&gt; &lt;artifactId&gt;spring-session-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; 有时候需要在各个服务之间共享数据，此时可以用Redis将其保存到一个公共的地方，当所有Tomcat需要往Session中写数据时，都往Redis中写，当所有Tomcat需要读数据时，都从Redis中读。或者使用Spring Session来实现，Spring Session就是使用Spring中的代理过滤器，将所有的Session操作拦截下来，自动的将数据同步到Redis中，或者自动的从Redis中读取数据。 引入依赖： &lt;dependecies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.session&lt;/groupId&gt; &lt;artifactId&gt;spring-session-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 引入nginx模拟SpringBoot集群：进入nginx的安装目录的conf目录下（默认是在/usr/local/nginx/conf），编辑nginx.conf文件： upstream javaboy.org{ # upstream 表示配置上游服务器，javaboy.org 表示服务器集群的名字，upstream 里面配置的是一个个的单独服务 server 127.0.0.1:8080 weight=1; # weight 表示服务的权重，意味着将有多少比例的请求从 nginx 上转发到该服务上 server 127.0.0.1:8081 weight=2; } server { listen 80; server_name localhost; #charset utf-8; #access_log logs/host.access.log main; location / { proxy_pass http://javaboy.org; # 表示请求转发的地址，/ 表示拦截所有的请求，转发到刚刚配置好的服务器集群中 proxy_redirect default; # 表示设置发生重定向请求时，nginx 自动修正响应头数据（默认是 Tomcat 返回重定向，此时重定向的地址是 Tomcat 的地址） #root html; #index index.html index.html; } } 配置完成后，正常使用HttpSession即可，Session同步到Redis等已由框架自动完成。因为会话注册表的维护默认是由SessionRegistryImpl完成，而它是基于内存的维护，所以要修改其实现逻辑： @Configuration public class SecurityConfig extends WebSecurityConfigurerAdapter { @Autowired FindByIndexNameSessionRepository sessionRepository; @Override protected void configure(HttpSecurity http) throws Exception { http.authorizeRequests().anyRequest() ... .sessionManagement() .maximumSessions(1) .maxSessionsPreventsLogin(true) .sessionRegistry(sessionRegistry()); } @Bean SpringSessionBackedSessionRegistry sessionRegistry() { return new SpringSessionBackedSessionRegistry(sessionRepository); } } 这时关于session并发的配置就生效了，集群环境下，用户也只能在一台设备上登录。 防御csrf攻击SpringSecurity中，默认通过Model将相关_csrf参数带到前端来，前端发请求时，除了携带Cookie中的信息之外，还需要通过隐藏域携带这个参数，否则网站就会拒绝请求。 也可以通过将_csrf参数放在Cookie中返回前端，配置如下： @Configuration public class SecurityConfig extends WebSecurityConfigurerAdapter { @Override protected void configure(HttpSecurity http) throws Exception { http.authorizeRequests().anyRequest().authenticated() .and() .formLogin() .and() .csrf().csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse()); // 此方法会设置 Cookie 中的 HttpOnly 属性为 false 以允许前端通过 js 操作 Cookie，否则前端无法获取到 _csrf 参数 } } 此时可以看到浏览器中返回的Cookie中多了个XSRF-TOKEN参数，当然服务端也要配置给js文件放行。 SpringSecurity中提供了一个保存csrf参数的规范，就是CsrfToken： public interface CsrfToken extends Serializable { String getHeaderName(); String getParameterName(); // 获取 _csrf 参数的 key String getToken(); // 获取 _csrf 参数的 value } 默认情况下使用DefaultCsrfToken实现类，_csrf参数的生成和保存则是另外一个类HttpSessionCsrfTokenRepository ，它是CsrfTokenRepository接口的默认实现类。 public final class HttpSessionCsrfTokenRepository implements CsrfTokenRepository { private static final String DEFAULT_CSRF_PARAMETER_NAME = &quot;_csrf&quot;; private static final String DEFAULT_CSRF_HEADER_NAME = &quot;X-CSRF-TOKEN&quot;; private static final String DEFAULT_CSRF_TOKEN_ATTR_NAME = HttpSessionCsrfTokenRepository.class .getName().concat(&quot;.CSRF_TOKEN&quot;); private String parameterName = DEFAULT_CSRF_PARAMETER_NAME; private String headerName = DEFAULT_CSRF_HEADER_NAME; private String sessionAttributeName = DEFAULT_CSRF_TOKEN_ATTR_NAME; public void saveToken(CsrfToken token, HttpServletRequest request, HttpServletResponse response) { if (token == null) { HttpSession session = request.getSession(false); if (session != null) { session.removeAttribute(this.sessionAttributeName); } } else { HttpSession session = request.getSession(); session.setAttribute(this.sessionAttributeName, token); } } public CsrfToken loadToken(HttpServletRequest request) { HttpSession session = request.getSession(false); if (session == null) { return null; } return (CsrfToken) session.getAttribute(this.sessionAttributeName); } public CsrfToken generateToken(HttpServletRequest request) { return new DefaultCsrfToken(this.headerName, this.parameterName, createNewToken()); } private String createNewToken() { return UUID.randomUUID().toString(); } } saveToken方法将CsrfToken保存在HttpSession中，将来再从HttpSession中取出和前端传来的参数做比较 loadToken方法就是从HttpSession中读取CsrfToken出来 generateToken是生成CsrfToken的过程，可以看到，生成的默认载体就是DefaultCsrfToken，而CsrfToken的值则通过createNewToken方法生成，是一个UUID字符串 在构造DefaultCsrfToken时还有两个参数headerName和parameterName，这两个参数是前端保存参数的key 如果将_csrf参数设置保存在Cookie中，则需要用到另一个实现类CsrfTokenRepository： public final class CookieCsrfTokenRepository implements CsrfTokenRepository { static final String DEFAULT_CSRF_COOKIE_NAME = &quot;XSRF-TOKEN&quot;; static final String DEFAULT_CSRF_PARAMETER_NAME = &quot;_csrf&quot;; static final String DEFAULT_CSRF_HEADER_NAME = &quot;X-XSRF-TOKEN&quot;; private String parameterName = DEFAULT_CSRF_PARAMETER_NAME; private String headerName = DEFAULT_CSRF_HEADER_NAME; private String cookieName = DEFAULT_CSRF_COOKIE_NAME; private boolean cookieHttpOnly = true; private String cookiePath; private String cookieDomain; public CookieCsrfTokenRepository() { } @Override public CsrfToken generateToken(HttpServletRequest request) { return new DefaultCsrfToken(this.headerName, this.parameterName, createNewToken()); } @Override public void saveToken(CsrfToken token, HttpServletRequest request, HttpServletResponse response) { String tokenValue = token == null ? &quot;&quot; : token.getToken(); Cookie cookie = new Cookie(this.cookieName, tokenValue); cookie.setSecure(request.isSecure()); if (this.cookiePath != null &amp;&amp; !this.cookiePath.isEmpty()) { cookie.setPath(this.cookiePath); } else { cookie.setPath(this.getRequestContext(request)); } if (token == null) { cookie.setMaxAge(0); } else { cookie.setMaxAge(-1); } cookie.setHttpOnly(cookieHttpOnly); if (this.cookieDomain != null &amp;&amp; !this.cookieDomain.isEmpty()) { cookie.setDomain(this.cookieDomain); } response.addCookie(cookie); } @Override public CsrfToken loadToken(HttpServletRequest request) { Cookie cookie = WebUtils.getCookie(request, this.cookieName); if (cookie == null) { return null; } String token = cookie.getValue(); if (!StringUtils.hasLength(token)) { return null; } return new DefaultCsrfToken(this.headerName, this.parameterName, token); } public static CookieCsrfTokenRepository withHttpOnlyFalse() { CookieCsrfTokenRepository result = new CookieCsrfTokenRepository(); result.setCookieHttpOnly(false); return result; } private String createNewToken() { return UUID.randomUUID().toString(); } } 与默认实现不同，这里是将CsrfToken保存到Cookie中。然后校验参数则通过CsrfFilter过滤器来实现： protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException { request.setAttribute(HttpServletResponse.class.getName(), response); CsrfToken csrfToken = this.tokenRepository.loadToken(request); final boolean missingToken = csrfToken == null; if (missingToken) { csrfToken = this.tokenRepository.generateToken(request); this.tokenRepository.saveToken(csrfToken, request, response); } request.setAttribute(CsrfToken.class.getName(), csrfToken); request.setAttribute(csrfToken.getParameterName(), csrfToken); if (!this.requireCsrfProtectionMatcher.matches(request)) { filterChain.doFilter(request, response); return; } String actualToken = request.getHeader(csrfToken.getHeaderName()); if (actualToken == null) { actualToken = request.getParameter(csrfToken.getParameterName()); } if (!csrfToken.getToken().equals(actualToken)) { if (this.logger.isDebugEnabled()) { this.logger.debug(&quot;Invalid CSRF token found for &quot; + UrlUtils.buildFullRequestUrl(request)); } if (missingToken) { this.accessDeniedHandler.handle(request, response, new MissingCsrfTokenException(actualToken)); } else { this.accessDeniedHandler.handle(request, response, new InvalidCsrfTokenException(csrfToken, actualToken)); } return; } filterChain.doFilter(request, response); } 首先调用tokenRepository.loadToken，这个就是之前配置的CsrfTokenRepository实例 如果调用tokenRepository.loadToken方法没有加载到CsrfToken，那说明这个请求可能是第一次发起，则调用tokenRepository.generateToken方法生成CsrfToken，并调用tokenRepository.saveToken方法保存CsrfToken 调用request.setAttribute方法存了一些值进去，这就是默认情况下，我们通过jsp或者thymeleaf标签渲染_csrf的数据来源 requireCsrfProtectionMatcher.matches方法则使用用来判断哪些请求方法需要做校验，默认情况下，”GET”, “HEAD”, “TRACE”, “OPTIONS”方法是不需要校验的 接下来获取请求中传递来的CSRF参数，先从请求头中获取，获取不到再从请求参数中获取 获取到请求传来的csrf参数之后，再和一开始加载到的csrfToken做比较，如果不同的话，就抛出异常 常见的GET请求实际上是不需要CSRF攻击校验的，但是下面代码总会执行： if (missingToken) { csrfToken = this.tokenRepository.generateToken(request); this.tokenRepository.saveToken(csrfToken, request, response); } 因此可以使用LazyCsrfTokenRepository，使得只有开发者调用getToken想要去获取csrfToken时，才去对csrfToken做保存操作： public final class LazyCsrfTokenRepository implements CsrfTokenRepository { @Override public CsrfToken generateToken(HttpServletRequest request) { return wrap(request, this.delegate.generateToken(request)); } @Override public void saveToken(CsrfToken token, HttpServletRequest request, HttpServletResponse response) { if (token == null) { this.delegate.saveToken(token, request, response); } } @Override public CsrfToken loadToken(HttpServletRequest request) { return this.delegate.loadToken(request); } private CsrfToken wrap(HttpServletRequest request, CsrfToken token) { HttpServletResponse response = getResponse(request); return new SaveOnAccessCsrfToken(this.delegate, request, response, token); } private static final class SaveOnAccessCsrfToken implements CsrfToken { private transient CsrfTokenRepository tokenRepository; private transient HttpServletRequest request; private transient HttpServletResponse response; private final CsrfToken delegate; SaveOnAccessCsrfToken(CsrfTokenRepository tokenRepository, HttpServletRequest request, HttpServletResponse response, CsrfToken delegate) { this.tokenRepository = tokenRepository; this.request = request; this.response = response; this.delegate = delegate; } @Override public String getToken() { saveTokenIfNecessary(); return this.delegate.getToken(); } private void saveTokenIfNecessary() { if (this.tokenRepository == null) { return; } synchronized (this) { if (this.tokenRepository != null) { this.tokenRepository.saveToken(this.delegate, this.request, this.response); this.tokenRepository = null; this.request = null; this.response = null; } } } } } 如果对csrf不做任何配置，默认其实就是LazyCsrfTokenRepository+HttpSessionCsrfTokenRepository组合，也可以自己配置： @Override protected void configure(HttpSecurity http) throws Exception { http.authorizeRequests().anyRequest().authenticated() .and() .formLogin() .loginPage(&quot;/login.html&quot;) .successHandler((req,resp,authentication)-&gt;{ resp.getWriter().write(&quot;success&quot;); }) .permitAll() .and() .csrf().csrfTokenRepository(new LazyCsrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse())); } 跨域配置当前端请求与后端同源时（仅端口不同），由于同源策略的限制，请求无法发送成功。通过在方法上配置注解@CrossOrigin(value=&quot;http://xxx:xxx&quot;)，表示其接受某一个域的请求。 也可以通过全局配置： @Configuration publicclass WebMvcConfig implements WebMvcConfigurer { @Override public void addCorsMappings(CorsRegistry registry) { registry.addMapping(&quot;/**&quot;) .allowedOrigins(&quot;http://localhost:8081&quot;) .allowedMethods(&quot;*&quot;) .allowedHeaders(&quot;*&quot;); } } 或者在SpringSecurity中做全局配置： @Configuration public class SecurityConfig extends WebSecurityConfigurerAdapter { @Override protected void configure(HttpSecurity http) throws Exception { http .authorizeRequests() .anyRequest().authenticated() .and() .formLogin() .permitAll() .and() .httpBasic() .and() .cors() // 开启对CORS的支持 .configurationSource(corsConfigurationSource()) .and() .csrf() .disable(); } // 通过 CorsConfigurationSource 实例对跨域信息作出详细配置，例如允许的请求来源、允许的请求方法、允许通过的请求头、探测请求的有效期、需要处理的路径等等 @Bean CorsConfigurationSource corsConfigurationSource() { UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(); CorsConfiguration configuration = new CorsConfiguration(); configuration.setAllowCredentials(true); configuration.setAllowedOrigins(Arrays.asList(&quot;*&quot;)); configuration.setAllowedMethods(Arrays.asList(&quot;*&quot;)); configuration.setAllowedHeaders(Arrays.asList(&quot;*&quot;)); configuration.setMaxAge(Duration.ofHours(1)); source.registerCorsConfiguration(&quot;/**&quot;,configuration); return source; } } 动态权限配置权限管理本身是由FilterSecurityInterceptor控制的，系统默认已经自动创建好了，如果想修改它的属性，则可以利用withObjectPostProcessor方法： @Configuration public class SecurityConfig extends WebSecurityConfigurerAdapter { @Override protected void configure(HttpSecurity http) throws Exception { http.authorizeRequests() .withObjectPostProcessor(new ObjectPostProcessor&lt;FilterSecurityInterceptor&gt;() { @Override public &lt;O extends FilterSecurityInterceptor&gt; O postProcess(O object) { object.setAccessDecisionManager(customUrlDecisionManager); object.setSecurityMetadataSource(customFilterInvocationSecurityMetadataSource); return object; } }) .and() // ... } } ObjectPostProcessor接口就一个postProcess，最主要的实现类AutowireBeanFactoryObjectPostProcessor就实现了这个方法（里面就是具体的注册逻辑），因此最主要作用就是手动注册实例到Spring容器中（并且让实例走一遍Bean的生命周期） 因为FilterSecurityInterceptor在创建成功后会重走一遍postProcess方法，因此这里通过重写postProcess方法就能实现属性修改。 自定义异常处理ExceptionTranslationFilter是SpringSecurity中专门负责处理异常的过滤器，默认情况下，这个过滤器已经被自动加载到过滤器链中。 public class ExceptionTranslationFilter extends GenericFilterBean { public ExceptionTranslationFilter(AuthenticationEntryPoint authenticationEntryPoint, RequestCache requestCache) { this.authenticationEntryPoint = authenticationEntryPoint; this.requestCache = requestCache; } public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException { HttpServletRequest request = (HttpServletRequest) req; HttpServletResponse response = (HttpServletResponse) res; try { chain.doFilter(request, response); } catch (IOException ex) { throw ex; } catch (Exception ex) { Throwable[] causeChain = throwableAnalyzer.determineCauseChain(ex); RuntimeException ase = (AuthenticationException) throwableAnalyzer .getFirstThrowableOfType(AuthenticationException.class, causeChain); if (ase == null) { ase = (AccessDeniedException) throwableAnalyzer.getFirstThrowableOfType( AccessDeniedException.class, causeChain); } if (ase != null) { if (response.isCommitted()) { throw new ServletException(&quot;Unable to handle the Spring Security Exception because the response is already committed.&quot;, ex); } handleSpringSecurityException(request, response, chain, ase); } else { if (ex instanceof ServletException) { throw (ServletException) ex; } else if (ex instanceof RuntimeException) { throw (RuntimeException) ex; } throw new RuntimeException(ex); } } } private void handleSpringSecurityException(HttpServletRequest request, HttpServletResponse response, FilterChain chain, RuntimeException exception) throws IOException, ServletException { if (exception instanceof AuthenticationException) { sendStartAuthentication(request, response, chain, (AuthenticationException) exception); } else if (exception instanceof AccessDeniedException) { Authentication authentication = SecurityContextHolder.getContext().getAuthentication(); if (authenticationTrustResolver.isAnonymous(authentication) || authenticationTrustResolver.isRememberMe(authentication)) { sendStartAuthentication( request, response, chain, new InsufficientAuthenticationException( messages.getMessage( &quot;ExceptionTranslationFilter.insufficientAuthentication&quot;, &quot;Full authentication is required to access this resource&quot;))); } else { accessDeniedHandler.handle(request, response, (AccessDeniedException) exception); } } } protected void sendStartAuthentication(HttpServletRequest request, HttpServletResponse response, FilterChain chain, AuthenticationException reason) throws ServletException, IOException { SecurityContextHolder.getContext().setAuthentication(null); requestCache.saveRequest(request, response); logger.debug(&quot;Calling Authentication entry point.&quot;); authenticationEntryPoint.commence(request, response, reason); } } 这里的doFilter方法中过滤器链继续向下执行，ExceptionTranslationFilter处于SpringSecurity过滤器链的倒数第二个，最后一个是FilterSecurityInterceptor，它专门处理授权问题，如果发现用户未登录、未授权等，进而抛出异常，抛出的异常最终会被ExceptionTranslationFilter#doFilter方法捕获 捕获异常之后，通过调用throwableAnalyzer.getFirstThrowableOfType方法判断是认证异常还是授权异常，判断出类型之后，进入到handleSpringSecurityException方法进行处理，如果不是SpringSecurity中的异常类型，则走ServletException异常类型的处理逻辑 进入handleSpringSecurityException 方法之后，还是根据异常类型判断，如果是认证相关的异常，就走sendStartAuthentication方法，最终被authenticationEntryPoint.commence方法处理；如果是授权相关的异常，就走accessDeniedHandler.handle方法进行处理 AccessDeniedHandler的默认实现类则是AccessDeniedHandlerImpl，因此授权异常默认是在AccessDeniedHandlerImpl#handle方法中处理的 // 服务器跳转返回 403 public void handle(HttpServletRequest request, HttpServletResponse response, AccessDeniedException accessDeniedException) throws IOException, ServletException { if (!response.isCommitted()) { if (errorPage != null) { request.setAttribute(WebAttributes.ACCESS_DENIED_403, accessDeniedException); response.setStatus(HttpStatus.FORBIDDEN.value()); RequestDispatcher dispatcher = request.getRequestDispatcher(errorPage); dispatcher.forward(request, response); } else { response.sendError(HttpStatus.FORBIDDEN.value(), HttpStatus.FORBIDDEN.getReasonPhrase()); } } } 自定义异常处理逻辑需要在exceptionHandling上进行配置，首先自定义认证异常处理类和授权异常处理类： @Component public class MyAuthenticationEntryPoint implements AuthenticationEntryPoint { @Override public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException, ServletException { response.getWriter().write(&quot;login failed:&quot; + authException.getMessage()); } } @Component public class MyAccessDeniedHandler implements AccessDeniedHandler { @Override public void handle(HttpServletRequest request, HttpServletResponse response, AccessDeniedException accessDeniedException) throws IOException, ServletException { response.setStatus(403); response.getWriter().write(&quot;Forbidden:&quot; + accessDeniedException.getMessage()); } } 然后在SecurityConfig中进行配置： @Configuration public class SecurityConfig extends WebSecurityConfigurerAdapter { @Override protected void configure(HttpSecurity http) throws Exception { http.authorizeRequests() // ... .and() .exceptionHandling() .authenticationEntryPoint(myAuthenticationEntryPoint) .accessDeniedHandler(myAccessDeniedHandler) .and() // ... } }","categories":[{"name":"生活","slug":"生活","permalink":"http://goodguyjameswin.github.io/categories/生活/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://goodguyjameswin.github.io/tags/学习笔记/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"http://goodguyjameswin.github.io/categories/生活/"}]},{"title":"二叉树","slug":"二叉树","date":"2022-05-21T10:43:08.000Z","updated":"2022-07-18T03:57:44.385Z","comments":false,"path":"2022/05/21/二叉树/","link":"","permalink":"http://goodguyjameswin.github.io/2022/05/21/二叉树/","excerpt":"","text":"","categories":[{"name":"生活","slug":"生活","permalink":"http://goodguyjameswin.github.io/categories/生活/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://goodguyjameswin.github.io/tags/学习笔记/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"http://goodguyjameswin.github.io/categories/生活/"}]},{"title":"springboot学习","slug":"springboot学习","date":"2022-05-19T08:26:45.000Z","updated":"2022-07-18T03:51:02.487Z","comments":false,"path":"2022/05/19/springboot学习/","link":"","permalink":"http://goodguyjameswin.github.io/2022/05/19/springboot学习/","excerpt":"","text":"内容部分转载自 公众号：狂神说，自学笔记，仅作学习交流用 构建工程入门使用IDEA创建项目，选择spring initializer，默认是到官网的快速构建工具实现，初始化组件一般选择Web即可 在主程序的同级目录下，新建一个controller包 @RestController public class HelloController { @RequestMapping(&quot;/hello&quot;) public String hello() { return &quot;Hello World&quot;; } } 从主程序启动项目，访问本机的Tomcat端口号即可 运行原理发现一个springboot项目主要是依赖于一个父项目 &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; 父项目还有一个父依赖，里面存有复数依赖包的各版号 &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt; &lt;/parent&gt; @SpringBootApplication注解SpringBoot的主配置类，SpringBoot通过运行这个类的main方法来启动SpringBoot应用 @SpringBootConfiguration @EnableAutoConfiguration @ComponentScan( excludeFilters = {@Filter( type = FilterType.CUSTOM, classes = {TypeExcludeFilter.class} ), @Filter( type = FilterType.CUSTOM, classes = {AutoConfigurationExcludeFilter.class} )} ) public @interface SpringBootApplication { // ...... } @SpringBootConfiguration注解SpringBoot的某个配置类 @EnableAutoConfiguration开启自动配置功能 @AutoConfigurationPackage @Import({AutoConfigurationImportSelector.class}) public @interface EnableAutoConfiguration { // ...... } @AutoConfigurationPackage自动配置包 @Import({Registrar.class}) public @interface AutoConfigurationPackage { // ...... } @Import是Spring底层注解，给容器导入一个组件，Registrar.class作用，将主启动类所在包及包下面所有子包的所有组件扫描到Spring容器 @Import({AutoConfigurationImportSelector.class})自动配置导入选择器 // 获得候选的配置 protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) { // getSpringFactoriesLoaderFactoryClass()方法返回启动自动导入配置文件的注解类：EnableAutoConfiguration List&lt;String&gt; configurations = new ArrayList(SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader())); ImportCandidates.load(AutoConfiguration.class, this.getBeanClassLoader()).forEach(configurations::add); Assert.notEmpty(configurations, &quot;No auto configuration classes found in META-INF/spring.factories nor in META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports. If you are using a custom packaging, make sure that file is correct.&quot;); return configurations; } 找到SpringFactoriesLoader的静态方法loadFactoryNames中调用的loadSpringFactories静态方法，获得自动配置的根源文件spring.factories private static Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(ClassLoader classLoader) { // 获取classLoader，这里得到的就是EnableAutoConfiguration标注的类本身 Map&lt;String, List&lt;String&gt;&gt; result = (Map)cache.get(classLoader); if (result != null) { return result; } else { HashMap result = new HashMap(); try { // 获取资源文件 Enumeration urls = classLoader.getResources(&quot;META-INF/spring.factories&quot;); // 将读取到的资源遍历，封装成为一个Properties // ...... } catch (IOException var14) { throw new IllegalArgumentException(&quot;Unable to load factories from location [META-INF/spring.factories]&quot;, var14); } } } 自动配置真正实现是从classpath中搜寻所有的META-INF/spring.factories配置文件 ，并将其中对应的org.springframework.boot.autoconfigure包下的配置项，通过反射实例化为对应标注了@Configuration的JavaConfig形式的IOC容器配置类（xxxAutoConfiguration），然后将这些都汇总成为一个实例并加载到IOC容器中 SpringApplication.run方法一部分是SpringApplication的实例化 public SpringApplication(ResourceLoader resourceLoader, Class... primarySources) { // ...... this.webApplicationType = WebApplicationType.deduceFromClasspath(); this.setInitializers(this.getSpringFactoriesInstances()); this.setListeners(this.getSpringFactoriesInstances(ApplicationListener.class)); this.mainApplicationClass = this.deduceMainApplicationClass(); } 推断应用的类型是普通的项目还是Web项目 查找并加载所有可用初始化器 ， 设置到initializers属性中 找出所有的应用程序监听器，设置到listeners属性中 推断并设置main方法的定义类，找到运行的主类 另一部分是run方法的执行 配置文件@ConfigurationProperties(prefix=&quot;pojo&quot;)作用是将配置文件中配置的每一个属性的值，映射到这个组件中；告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定，默认从全局配置文件中获取值prefix=&quot;pojo&quot;：将配置文件中的pojo下面的所有属性一一对应 @PropertySource(value=&quot;classpath:pojo.properties&quot;)加载指定的配置文件 @Validated用于校验数据 @Component //注册bean @ConfigurationProperties(prefix = &quot;person&quot;) @Validated //数据校验 public class Person { @Email(message=&quot;邮箱格式错误&quot;) //name必须是邮箱格式 private String name; } 通过spring.profiles.active={profile}指定使用不同的环境，环境使用不同的端口号，或者通过yaml文件来配置，默认使用properties配置文件 server: port: 8081 #选择要激活那个环境块 spring: profiles: active: prod --- server: port: 8083 spring: profiles: dev #配置环境的名称 --- server: port: 8084 spring: profiles: prod #配置环境的名称 springboot项目的配置文件扫描优先级从高到低 项目路径下的config文件夹配置文件 项目路径下配置文件 资源路径下的config文件夹配置文件 资源路径下配置文件 可在项目打包好后，使用命令行参数启动项目的时候指定配置文件的位置，此优先级最高 java -jar spring-boot-config.jar --spring.config.location=F:/application.properties 自动装配原理xxxAutoConfiguration自动配置类，用于给容器添加组件，必须在一定条件下才能生效，在主配置文件中启用debug=true让控制台打印自动配置报告 // 表示这是一个配置类 @AutoConfiguration // 启动指定类的ConfigurationProperties功能，xxxProperties类中封装着能在主配置文件中配置的属性 @EnableConfigurationProperties({ServerProperties.class}) // Spring底层@Conditional注解，根据条件判断配置类是否生效 @ConditionalOnWebApplication( type = Type.SERVLET ) // 判断当前项目有没有指定类 @ConditionalOnClass({CharacterEncodingFilter.class}) // 判断配置文件中是否存在某个配置，一般默认是存在的 @ConditionalOnProperty( prefix = &quot;server.servlet.encoding&quot;, value = {&quot;enabled&quot;}, matchIfMissing = true ) public class HttpEncodingAutoConfiguration { // 映射为SpringBoot的主配置文件 private final Encoding properties; public HttpEncodingAutoConfiguration(ServerProperties properties) { this.properties = properties.getServlet().getEncoding(); } // 给容器添加一个组件，值可以从主配置文件中获取 @Bean // 判断容器中是否存在指定组件 @ConditionalOnMissingBean public CharacterEncodingFilter characterEncodingFilter() { CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter(); filter.setEncoding(this.properties.getCharset().name()); filter.setForceRequestEncoding(this.properties.shouldForce(org.springframework.boot.web.servlet.server.Encoding.Type.REQUEST)); filter.setForceResponseEncoding(this.properties.shouldForce(org.springframework.boot.web.servlet.server.Encoding.Type.RESPONSE)); return filter; } // ...... } 连接数据库SpringBoot默认自动配置的数据源为class com.zaxxer.hikari.HikariDataSource，可直接注入使用，数据源的自动配置类DataSourceAutoConfiguration @Import({Hikari.class, Tomcat.class, Dbcp2.class, OracleUcp.class, Generic.class, DataSourceJmxConfiguration.class}) protected static class PooledDataSourceConfiguration { protected PooledDataSourceConfiguration() { } } SpringBoot也默认自动配置了JdbcTemplate放在容器中用于直接注入使用，其自动配置类JdbcTemplateConfiguration 通过主配置文件spring.datasource.type可指定其他数据源 spring: datasource: username: root password: 123456 #?serverTimezone=UTC解决时区的报错 url: jdbc:mysql://localhost:3306/springboot?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8 driver-class-name: com.mysql.cj.jdbc.Driver type: com.alibaba.druid.pool.DruidDataSource #Spring Boot 默认是不注入这些属性值的，需要自己绑定 #druid 数据源专有配置 initialSize: 5 minIdle: 5 maxActive: 20 maxWait: 60000 timeBetweenEvictionRunsMillis: 60000 minEvictableIdleTimeMillis: 300000 validationQuery: SELECT 1 FROM DUAL testWhileIdle: true testOnBorrow: false testOnReturn: false poolPreparedStatements: true #配置监控统计拦截的filters，stat:监控统计、log4j：日志记录、wall：防御sql注入 filters: stat,wall,log4j maxPoolPreparedStatementPerConnectionSize: 20 useGlobalDataSourceStat: true connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500 需要为DruidDataSource绑定全局配置文件中的参数，再添加到容器中 import com.alibaba.druid.pool.DruidDataSource; import javax.sql.DataSource; @Configuration public class DruidConfig { /* 将自定义的Druid数据源添加到容器中，不再让SpringBoot自动创建 绑定全局配置文件中的druid数据源属性到com.alibaba.druid.pool.DruidDataSource从而让它们生效 */ @ConfigurationProperties(prefix = &quot;spring.datasource&quot;) @Bean public DataSource druidDataSource() { return new DruidDataSource(); } } Druid数据源具有监控的功能，并提供了一个web界面方便用户查看 //配置 Druid 监控管理后台的Servlet； //内置 Servlet 容器时没有web.xml文件，所以使用 Spring Boot 的注册 Servlet 方式 @Bean public ServletRegistrationBean statViewServlet() { ServletRegistrationBean bean = new ServletRegistrationBean(new StatViewServlet(), &quot;/druid/*&quot;); // 这些参数可以在 com.alibaba.druid.support.http.StatViewServlet // 的父类 com.alibaba.druid.support.http.ResourceServlet 中找到 Map&lt;String, String&gt; initParams = new HashMap&lt;&gt;(); initParams.put(&quot;loginUsername&quot;, &quot;admin&quot;); //后台管理界面的登录账号 initParams.put(&quot;loginPassword&quot;, &quot;123456&quot;); //后台管理界面的登录密码 //后台允许谁可以访问 //initParams.put(&quot;allow&quot;, &quot;localhost&quot;)：表示只有本机可以访问 //initParams.put(&quot;allow&quot;, &quot;&quot;)：为空或者为null时，表示允许所有访问 initParams.put(&quot;allow&quot;, &quot;&quot;); //deny：Druid 后台拒绝谁访问 //initParams.put(&quot;kuangshen&quot;, &quot;192.168.1.20&quot;);表示禁止此ip访问 //设置初始化参数 bean.setInitParameters(initParams); return bean; } 配置 Druid web 监控 filter 过滤器 //配置 Druid 监控 之 web 监控的 filter //WebStatFilter：用于配置Web和Druid数据源之间的管理关联监控统计 @Bean public FilterRegistrationBean webStatFilter() { FilterRegistrationBean bean = new FilterRegistrationBean(); bean.setFilter(new WebStatFilter()); //exclusions：设置哪些请求进行过滤排除掉，从而不进行统计 Map&lt;String, String&gt; initParams = new HashMap&lt;&gt;(); initParams.put(&quot;exclusions&quot;, &quot;*.js,*.css,/druid/*,/jdbc/*&quot;); bean.setInitParameters(initParams); //&quot;/*&quot; 表示过滤所有请求 bean.setUrlPatterns(Arrays.asList(&quot;/*&quot;)); return bean; } 整合Mybatis导入依赖 &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.1&lt;/version&gt; &lt;/dependency&gt; 创建mapper目录以及对应的Mapper接口，如果不使用@Mapper注解，也可以在直接在主程序入口添加Mapper扫描@Mapper(basePackages=&quot;com.xxx.mapper.DepartmentMapper&quot;)。 //@Mapper : 表示本类是一个 MyBatis 的 Mapper @Mapper @Repository public interface DepartmentMapper { // 获取所有部门信息 List&lt;Department&gt; getDepartments(); // 通过id获得部门 Department getDepartment(Integer id); } 对应的Mapper映射文件 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; &lt;mapper namespace=&quot;com.xxx.mapper.DepartmentMapper&quot;&gt; &lt;select id=&quot;getDepartments&quot; resultType=&quot;Department&quot;&gt; select * from department; &lt;/select&gt; &lt;select id=&quot;getDepartment&quot; resultType=&quot;Department&quot; parameterType=&quot;int&quot;&gt; select * from department where id = #{id}; &lt;/select&gt; &lt;/mapper&gt; 如果与Mapper接口放在同一个包下则可以自动扫描到，但是需要配置静态资源过滤。 &lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt; 否则需要在主配置文件中配置扫描地址mybatis.mapper-locations=classpath:mapper/*.xml，但此时不需要配置文件过滤。 编写DepartmentController进行测试 @RestController public class DepartmentController { @Autowired DepartmentMapper departmentMapper; // 查询全部部门 @GetMapping(&quot;/getDepartments&quot;) public List&lt;Department&gt; getDepartments(){ return departmentMapper.getDepartments(); } // 查询全部部门 @GetMapping(&quot;/getDepartment/{id}&quot;) public Department getDepartment(@PathVariable(&quot;id&quot;) Integer id){ return departmentMapper.getDepartment(id); } } 静态资源映射在WebMvcAutoConfiguration下，WebMvcAutoConfigurationAdapter中的addResourceHandler方法可添加资源处理 @Import({WebMvcAutoConfiguration.EnableWebMvcConfiguration.class}) @EnableConfigurationProperties({WebMvcProperties.class, WebProperties.class}) public static class WebMvcAutoConfigurationAdapter implements WebMvcConfigurer, ServletContextAware { // ...... public void addResourceHandlers(ResourceHandlerRegistry registry) { if (!this.resourceProperties.isAddMappings()) { logger.debug(&quot;Default resource handling disabled&quot;); } else { this.addResourceHandler(registry, &quot;/webjars/**&quot;, &quot;classpath:/META-INF/resources/webjars/&quot;); this.addResourceHandler(registry, this.mvcProperties.getStaticPathPattern(), (registration) -&gt; { registration.addResourceLocations(this.resourceProperties.getStaticLocations()); if (this.servletContext != null) { ServletContextResource resource = new ServletContextResource(this.servletContext, &quot;/&quot;); registration.addResourceLocations(new Resource[]{resource}); } }); } } } Webjars本质就是以jar包的方式引入我们的静态资源，导入jQuery的对应依赖即可使用，另一种静态资源映射规则是访问当前项目任意资源/**，在WebMvcProperties.class中定义，在resourceProperties.class中可以找到对应的与访问静态资源有关的参数设置 public static class Resources { private static final String[] CLASSPATH_RESOURCE_LOCATIONS = new String[]{&quot;classpath:/META-INF/resources/&quot;, &quot;classpath:/resources/&quot;, &quot;classpath:/static/&quot;, &quot;classpath:/public/&quot;}; private String[] staticLocations; // ...... public Resources() { this.staticLocations = CLASSPATH_RESOURCE_LOCATIONS; // ...... } } 也可以在SpringBoot的主配置文件中配置，比如spring.resources.static-locations=classpath:/xx/,classpath:/xx/ 设置主页在WebMvcAutoConfiguration下，EnableConfiguration类中定义了起始页面的相关参数设置。还可以在静态资源目录下设置网站图标，不过要先关闭SpringBoot默认图标spring.mvc.favicon.enabled=false private Resource getWelcomePage() { String[] var1 = this.resourceProperties.getStaticLocations(); // 映射规则为&#39;/**&#39; int var2 = var1.length; for(int var3 = 0; var3 &lt; var2; ++var3) { String location = var1[var3]; Resource indexHtml = this.getIndexHtml(location); if (indexHtml != null) { return indexHtml; } } ServletContext servletContext = this.getServletContext(); if (servletContext != null) { return this.getIndexHtml((Resource)(new ServletContextResource(servletContext, &quot;/&quot;))); } else { return null; } } private Resource getIndexHtml(String location) { return this.getIndexHtml(this.resourceLoader.getResource(location)); } private Resource getIndexHtml(Resource location) { try { Resource resource = location.createRelative(&quot;index.html&quot;); if (resource.exists() &amp;&amp; resource.getURL() != null) { return resource; } } catch (Exception var3) { } return null; } MVC自动配置原理Spring MVC Auto-configuration // Spring Boot为Spring MVC提供了自动配置，它可以很好地与大多数应用程序一起工作。 Spring Boot provides auto-configuration for Spring MVC that works well with most applications. // 自动配置在Spring默认设置的基础上添加了以下功能： The auto-configuration adds the following features on top of Spring’s defaults: // 包含视图解析器 Inclusion of ContentNegotiatingViewResolver and BeanNameViewResolver beans. // 支持静态资源文件夹的路径，以及webjars Support for serving static resources, including support for WebJars // 自动注册了Converter： // 转换器，这就是我们网页提交数据到后台自动封装成为对象的东西，比如把&quot;1&quot;字符串自动转换为int类型 // Formatter：【格式化器，比如页面给我们了一个2019-8-10，它会给我们自动格式化为Date对象】 Automatic registration of Converter, GenericConverter, and Formatter beans. // HttpMessageConverters // SpringMVC用来转换Http请求和响应的，比如我们要把一个User对象转换为JSON字符串，可以去看官网文档解释； Support for HttpMessageConverters (covered later in this document). // 定义错误代码生成规则的 Automatic registration of MessageCodesResolver (covered later in this document). // 首页定制 Static index.html support. // 初始化数据绑定器：帮我们把请求数据绑定到JavaBean中！ Automatic use of a ConfigurableWebBindingInitializer bean (covered later in this document). /* 如果您希望保留Spring Boot MVC功能，并且希望添加其他MVC配置（拦截器、格式化程序、视图控制器和其他功能），则可以添加自己 的@configuration类，类型为webmvcconfiguer，但不添加@EnableWebMvc。如果希望提供 RequestMappingHandlerMapping、RequestMappingHandlerAdapter或ExceptionHandlerExceptionResolver的自定义 实例，则可以声明WebMVCregistrationAdapter实例来提供此类组件。 */ If you want to keep Spring Boot MVC features and you want to add additional MVC configuration (interceptors, formatters, view controllers, and other features), you can add your own @Configuration class of type WebMvcConfigurer but without @EnableWebMvc. If you wish to provide custom instances of RequestMappingHandlerMapping, RequestMappingHandlerAdapter, or ExceptionHandlerExceptionResolver, you can declare a WebMvcRegistrationsAdapter instance to provide such components. // 如果您想完全控制Spring MVC，可以添加自己的@Configuration，并用@EnableWebMvc进行注释。 If you want to take complete control of Spring MVC, you can add your own @Configuration annotated with @EnableWebMvc. 在WebMvcAutoConfiguration下，找到内容协商视图解析器ContentNegotiatingViewResolver，在viewResolver方法中，进到这个类里面可以看到有关解析视图的代码，说明其作用就是组合视图解析器。因此可以自己添加一个视图解析器，这个类就会将它与SpringBoot中自动配置的视图解析器组合 @Nullable // 参数可为null public View resolveViewName(String viewName, Locale locale) throws Exception { RequestAttributes attrs = RequestContextHolder.getRequestAttributes(); Assert.state(attrs instanceof ServletRequestAttributes, &quot;No current ServletRequestAttributes&quot;); List&lt;MediaType&gt; requestedMediaTypes = this.getMediaTypes(((ServletRequestAttributes)attrs).getRequest()); if (requestedMediaTypes != null) { // 获取候选的视图对象 List&lt;View&gt; candidateViews = this.getCandidateViews(viewName, locale, requestedMediaTypes); // 选择一个最适合的视图对象，然后把这个对象返回 View bestView = this.getBestView(candidateViews, requestedMediaTypes, attrs); if (bestView != null) { return bestView; } } } // ...... private List&lt;View&gt; getCandidateViews(String viewName, Locale locale, List&lt;MediaType&gt; requestedMediaTypes) throws Exception { List&lt;View&gt; candidateViews = new ArrayList(); if (this.viewResolvers != null) { Assert.state(this.contentNegotiationManager != null, &quot;No ContentNegotiationManager set&quot;); Iterator var5 = this.viewResolvers.iterator(); // 把所有的视图解析器，while循环，挨个解析 while(var5.hasNext()) { ViewResolver viewResolver = (ViewResolver)var5.next(); View view = viewResolver.resolveViewName(viewName, locale); if (view != null) { candidateViews.add(view); } // ...... } } } protected void initServletContext(ServletContext servletContext) { // 这里它是从beanFactory工具中获取容器中的所有视图解析器 // ViewResolver.class 把所有的视图解析器来组合的 Collection&lt;ViewResolver&gt; matchingBeans = BeanFactoryUtils.beansOfTypeIncludingAncestors(this.obtainApplicationContext(), ViewResolver.class).values(); ViewResolver viewResolver; if (this.viewResolvers == null) { this.viewResolvers = new ArrayList(matchingBeans.size()); Iterator var3 = matchingBeans.iterator(); while(var3.hasNext()) { viewResolver = (ViewResolver)var3.next(); if (this != viewResolver) { this.viewResolvers.add(viewResolver); } } // ...... } } SpringBoot自动配置很多组件时，先看容器中有没有用户自己配置的@bean，如果没有就用自动配置的，且有些组件可以存在多个 //应为类型要求为WebMvcConfigurer，所以我们实现其接口 //可以使用自定义类扩展MVC的功能 @Configuration public class MyMvcConfig implements WebMvcConfigurer { @Override public void addViewControllers(ViewControllerRegistry registry) { // 浏览器发送/test ， 就会跳转到test页面； registry.addViewController(&quot;/test&quot;).setViewName(&quot;test&quot;); } } 我们也可以扩展配置。比如设置虚拟目录映射，用于解决文件回显显示的问题 @Configuration public class MyMvcConfig implements WebMvcConfigurer { // 文件保存在真实目录/upload/下， // 访问的时候使用虚路径/upload，比如文件名为1.png，就直接/upload/1.png就ok了。 @Override public void addResourceHandlers(ResourceHandlerRegistry registry) { registry.addResourceHandler(&quot;/upload/**&quot;) .addResourceLocations(&quot;file:&quot;+System.getProperty(&quot;user.dir&quot;)+&quot;/upload/&quot;); } } 在WebMvcAutoConfiguration中，WebMvcAutoConfigurationAdapter上有注解@Import(EnableWebMvcConfiguration.class，对应类继承了DelegatingWebMvcConfiguration父类 public class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport { private final WebMvcConfigurerComposite configurers = new WebMvcConfigurerComposite(); // 从容器中获取所有的webmvcConfigurer @Autowired(required = false) public void setConfigurers(List&lt;WebMvcConfigurer&gt; configurers) { if (!CollectionUtils.isEmpty(configurers)) { this.configurers.addWebMvcConfigurers(configurers); } } protected void addViewControllers(ViewControllerRegistry registry) { this.configurers.addViewControllers(registry); } // ...... } 其中设置viewController中调用了addViewControllers方法，可以看出不止SpringBoot的自动配置类，我们自己编写的扩展配置类也会被调用 public void addViewControllers(ViewControllerRegistry registry) { Iterator var2 = this.delegates.iterator(); while(var2.hasNext()) { // 将所有的WebMvcConfigurer相关配置进行组合调用，包括我们自定义的配置和SpringBoot的自动配置 WebMvcConfigurer delegate = (WebMvcConfigurer)var2.next(); delegate.addViewControllers(registry); } } 而@EnableWebMvc注解类导入了继承父类WebMvcConfigurationSupport的DelegatingWebMvcConfiguration类，而WebMvcConfigurationSupport组件只包含SpringMVC最基本的功能 @Import({DelegatingWebMvcConfiguration.class}) public @interface EnableWebMvc { // ...... } public class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport { // ...... } @Configuration(proxyBeanMethods = false) @ConditionalOnWebApplication(type = Type.SERVLET) @ConditionalOnClass({ Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class }) // 这个注解的意思就是：容器中没有这个组件的时候，这个自动配置类才生效 @ConditionalOnMissingBean(WebMvcConfigurationSupport.class) public class WebMvcAutoConfiguration { // ...... } 使得WebMvcAutoConfiguration自动配置类失效，从而全面接管SpringMVC的配置，因此这是不推荐的 集成Swagger导入依赖 &lt;dependency&gt; &lt;groupId&gt;com.mangofactory&lt;/groupId&gt; &lt;artifactId&gt;swagger-springmvc&lt;/artifactId&gt; &lt;version&gt;1.0.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.10.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.10.5&lt;/version&gt; &lt;/dependency&gt; 编写配置类SwaggerConfig @Configuration // 配置类 @EnableSwagger2 // 开启Swagger2的自动配置 public class SwaggerConfig { @Bean // 配置docket以配置Swagger具体参数 public Docket docket() { // 设置要显示swagger的环境 Profiles of = Profiles.of(&quot;dev&quot;, &quot;test&quot;); // 判断当前是否处于该环境 // 通过 enable() 接收此参数判断是否要显示 boolean b = environment.acceptsProfiles(of); return new Docket(DocumentationType.SWAGGER_2).apiInfo(apiInfo()); // 实例关联上 apiInfo() .enable(b) // 配置是否启用Swagger，如果是false，在浏览器将无法访问 .select() // 通过.select()方法，去配置扫描接口，RequestHandlerSelectors配置如何扫描接口 .apis(RequestHandlerSelectors.basePackage(&quot;com.kuang.swagger.controller&quot;)) .paths(PathSeletors.ant(&quot;/author/**&quot;)) // 配置如何通过path过滤，这里只扫描请求以 /author 开头的接口 .groupName(&quot;hello&quot;) // 配置分组，配置多个分组只需要配置多个docket即可 .build(); } //配置文档信息 private ApiInfo apiInfo() { Contact contact = new Contact(&quot;联系人名字&quot;, &quot;http://xxx.xxx.com/联系人访问链接&quot;, &quot;联系人邮箱&quot;); return new ApiInfo( &quot;Swagger学习&quot;, // 标题 &quot;学习演示如何配置Swagger&quot;, // 描述 &quot;v1.0&quot;, // 版本 &quot;http://terms.service.url/组织链接&quot;, // 组织链接 contact, // 联系人信息 &quot;Apach 2.0 许可&quot;, // 许可 &quot;许可链接&quot;, // 许可连接 new ArrayList&lt;&gt;()// 扩展 ); } } 除了通过包路径配置扫描接口外，还通过配置其他方式扫描接口 any() // 扫描所有，项目中的所有接口都会被扫描到 none() // 不扫描接口 // 通过方法上的注解扫描，如withMethodAnnotation(GetMapping.class)只扫描get请求 withMethodAnnotation(final Class&lt;? extends Annotation&gt; annotation) // 通过类上的注解扫描，如.withClassAnnotation(Controller.class)只扫描有controller注解的类中的接口 withClassAnnotation(final Class&lt;? extends Annotation&gt; annotation) basePackage(final String basePackage) // 根据包路径扫描接口 配置接口扫描过滤 any() // 任何请求都扫描 none() // 任何请求都不扫描 regex(final String pathRegex) // 通过正则表达式控制 ant(final String antPattern) // 通过ant()控制 请求接口的返回值（包括泛型），都会映射到实体类上，@ApiModel和@ApiModelProperty只是为实体类添加注释 .center { width: auto; display: table; margin-left: auto; margin-right: auto; } Swagger注解 简单说明 @Api(tags=”xxx模块说明”) 作用在模块类上 @ApiOperation(“xxx接口说明”) 作用在接口方法上 @ApiModel(“xxxPOJO说明”) 作用在模型类上：如VO、BO @ApiModelProperty(value = “xxx属性说明”,hidden = true) 作用在类方法和属性上，hidden设置为true可以隐藏该属性 @ApiParam(“xxx参数说明”) 作用在参数、方法和字段上，类似@ApiModelProperty 异步任务为了便于后台使用多线程的方式进行异步处理，可以用@Async注解一个异步方法，此时SpringBoot就会自己开一个线程池进行调用，需要在主程序入口上添加一个注解@EnableAsync，开启异步注解功能 定时任务SpringBoot提供了异步执行任务调度的方式，提供了接口TaskExecutor和TaskScheduler，以及注解Scheduled，需要在主程序入口上添加注解@EnableScheduling，开启定时任务功能 @Service public class ScheduledService { //秒 分 时 日 月 周几 //0 * * * * MON-FRI //注意cron表达式的用法； @Scheduled(cron = &quot;0 * * * * 0-7&quot;) // 定义方法的定时执行 public void hello(){ System.out.println(&quot;hello.....&quot;); } } cron 表达式 字段 允许值 允许的特殊字符 秒 0-59 ,-*/ 分 0-59 ,-*/ 小时 0-23 ,-*/ 日期 1-31 ,-*?/L W C 月份 1-12 ,-*/ 星期 0-7或SUN-SAT 0,7是SUN ,-*?/L C W 特殊字符 代表含义 , 枚举 - 区间 * 任意 / 步长 ? 日/星期冲突匹配 L 最后 W 工作日 C 和calendar联系后计算过的值 # 星期，4#2，第2个星期三 邮件任务导入依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt; &lt;/dependency&gt; 查看自动配置类MailSenderAutoConfiguration，开启了自动配置@EnableConfigurationProperties({MailProperties.class})，对应SpringBoot主配置文件中可配置参数 @ConfigurationProperties( prefix = &quot;spring.mail&quot; ) public class MailProperties { private static final Charset DEFAULT_CHARSET; private String host; private Integer port; private String username; private String password; private String protocol = &quot;smtp&quot;; private Charset defaultEncoding; private Map&lt;String, String&gt; properties; private String jndiName; // ...... } 自动配置类中没有注册bean，发现导入类MailSenderJndiConfiguration，其中注册了类JavaMailSenderImpl，其中定义了邮件发送的方法 @Bean JavaMailSenderImpl mailSender(Session session) { JavaMailSenderImpl sender = new JavaMailSenderImpl(); sender.setDefaultEncoding(this.properties.getDefaultEncoding().name()); sender.setSession(session); return sender; } 邮件收发测试 @Autowired JavaMailSenderImpl mailSender; @Test public void contextLoads2() throws MessagingException { // SimpleMailMessage message = new SimpleMailMessage(); // 发送简单邮件 MimeMessage mimeMessage = mailSender.createMimeMessage(); // 复杂邮件 MimeMessageHelper helper = new MimeMessageHelper(mimeMessage, true); helper.setSubject(&quot;主题&quot;); helper.setText(&quot;正文&quot;,true); // 可以插入html样式 //发送附件 helper.addAttachment(&quot;1.jpg&quot;,new File(&quot;&quot;)); helper.addAttachment(&quot;2.jpg&quot;,new File(&quot;&quot;)); helper.setTo(&quot;xxx@qq.com&quot;); helper.setFrom(&quot;xxx@qq.com&quot;); mailSender.send(mimeMessage); } 整合Redis导入依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt; &lt;/dependency&gt; 找到SpringBoot中有关Redis的自动配置RedisAutoConfiguration @AutoConfiguration @ConditionalOnClass({RedisOperations.class}) @EnableConfigurationProperties({RedisProperties.class}) @Import({LettuceConnectionConfiguration.class, JedisConnectionConfiguration.class}) public class RedisAutoConfiguration { public RedisAutoConfiguration() { } @Bean @ConditionalOnMissingBean( name = {&quot;redisTemplate&quot;} ) // 说明可以编写自己的 redisTemplate 来覆盖自动配置的 @ConditionalOnSingleCandidate(RedisConnectionFactory.class) public RedisTemplate&lt;Object, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) { RedisTemplate&lt;Object, Object&gt; template = new RedisTemplate(); template.setConnectionFactory(redisConnectionFactory); return template; } @Bean @ConditionalOnMissingBean @ConditionalOnSingleCandidate(RedisConnectionFactory.class) public StringRedisTemplate stringRedisTemplate(RedisConnectionFactory redisConnectionFactory) { return new StringRedisTemplate(redisConnectionFactory); } } 在RedisProperties.class里发现能在SpringBoot主配置文件中配置的redis相关参数 @ConfigurationProperties( prefix = &quot;spring.redis&quot; ) public class RedisProperties { private int database = 0; private String url; private String host = &quot;localhost&quot;; private String username; private String password; private int port = 6379; private boolean ssl; private Duration timeout; private Duration connectTimeout; private String clientName; private RedisProperties.ClientType clientType; private RedisProperties.Sentinel sentinel; private RedisProperties.Cluster cluster; // ...... } 实体类作为数据传递时需要进行序列化，比如实现serializable接口，或者自定义配置类，修改自动配置中的序列化方法 @Configuration public class RedisConfig { @Bean @SuppresWarnings(&quot;all&quot;) // 定制一个 RedisTemplate public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) { // 一般直接使用 &lt;String, Object&gt; RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;(); template.setConnectionFactory(redisConnectionFactory); //Json序列化配置 Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class); ObjectMapper om = new ObjectMapper(); om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); jackson2JsonRedisSerializer.setObjectMapper(om); StringRedisSerializer stringRedisSerializer = StringRedisSerializer(); // key采用String的序列化方式 template.setKeySerializer(stringRedisSerializer); // hash的key也采用String的序列化方式 template.setHashKeySerializer(stringRedisSerializer); // value序列化方式采用jackson template.setValueSerializer(jackson2JsonRedisSerializer); // hash的value序列化方式采用jackson template.setHashValueSerializer(jackson2JsonRedisSerializer); template.afterPropertiesSet(); return template; } } Redis的基本操作都通过注入的redisTemplate的API进行实现，一般进一步封装成工具类RedisUtil以便开发。 还可以使用Redis来作为Cache的实现，首先在主程序入口加入注解@EnableCaching，发现SpringBoot自动配置了一个RedisCacheManager，它间接实现了Spring中的Cache接口： @Configuration @ConditionalOnClass(RedisConnectionFactory.class) @AutoConfigureAfter(RedisAutoConfiguration.class) @ConditionalOnBean(RedisConnectionFactory.class) @ConditionalOnMissingBean(CacheManager.class) @Conditional(CacheCondition.class) class RedisCacheConfiguration { @Bean public RedisCacheManager cacheManager(RedisConnectionFactory redisConnectionFactory, ResourceLoader resourceLoader) { RedisCacheManagerBuilder builder = RedisCacheManager .builder(redisConnectionFactory) .cacheDefaults(determineConfiguration(resourceLoader.getClassLoader())); List&lt;String&gt; cacheNames = this.cacheProperties.getCacheNames(); if (!cacheNames.isEmpty()) { builder.initialCacheNames(new LinkedHashSet&lt;&gt;(cacheNames)); } returnthis.customizerInvoker.customize(builder.build()); } } @CacheConfig注解在类上使用，用来描述该类中所有方法使用的缓存名称。 @Service @CacheConfig(cacheNames = &quot;c1&quot;) publicclass UserService { } @Cacheable注解一般用在查询方法上，表示将一个方法的返回值缓存起来。默认情况下，缓存的key就是方法的参数，缓存的value就是方法的返回值。 @Cacheable(key = &quot;#id&quot;) // 也可以通过 key 属性来指定键，如果对缓存的键有复杂要求，可以自定义 keyGenerator public User getUserById(Integer id,String username) { System.out.println(&quot;getUserById&quot;); return getUserFromDBById(id); } 也可以使用Spring Cache中提供的root对象： 属性 描述 实例 methodName 当前方法名 #root.methodName method 当前方法 #root.method.name target 当前被调用的对象 #root.target targetClass 当前被调用的对象的class #root.targetClass args 当前方法参数数组 #root.args[0] caches 当前被调用的方法使用的Cache #root.caches[0].name @CachePut注解一般用在更新方法上，当数据库中的数据更新后，缓存中的数据也要跟着更新，使用该注解，可以将方法的返回值自动更新到已经存在的key上。 @CachePut(key = &quot;#user.id&quot;) public User updateUserById(User user) { return user; } @CacheEvict注解一般用在删除方法上，当数据库中的数据删除后，相关的缓存数据也要自动清除，该注解在使用的时候也可以配置按照某种条件删除（condition 属性）或者或者配置清除所有缓存（allEntries 属性）。 @CacheEvict() public void deleteUserById(Integer id) { //在这里执行删除操作，删除是去数据库中删除 } 整合rabbitmq芋道SpringBoot消息队列rabbitmq入门 整合Websocket导入依赖： &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt; &lt;/dependency&gt; 编写配置类WebSocketConfig： @Configuration @EnableWebSocketMessageBroker // 表示使用STOMP协议（webSocket的子协议）来传输基于消息代理的消息 // 此时可以在@Controller类中使用@MessageMapping，类似于@RequestMapping public class WebSocketConfig implements WebSocketMessageBrokerConfigurer { @Override public void registerStompEndpoints(StompEndpointRegistry registry) { /* 注册Stomp的端点 addEndpoint：添加STOMP协议的端点。这个HTTP URL是供WebSocket或SockJS客户端访问的地址 withSockJS：指定端点使用SockJS协议 */ registry.addEndpoint(&quot;/simple&quot;) .setAllowedOrigins(&quot;http://localhost:8080&quot;) // 添加允许跨域访问 .withSockJS(); // sockjs是websocket协议的实现，增加了对浏览器不支持websocket的时候的兼容支持 // SockJS的支持的传输的协议有3类: WebSocket, HTTP Streaming, and HTTP Long Polling // 默认使用websocket，如果浏览器不支持websocket，则使用后两类 } @Override public void configureMessageBroker(MessageBrokerRegistry registry) { /* 配置消息代理 启动简单Broker，消息的发送的地址符合配置的前缀来的消息才发送到这个broker */ registry.enableSimpleBroker(&quot;/topic&quot;); } } 编写controller： @Controller public class WsController { @Autowired SimpMessagingTemplate simpMessagingTemplate; @MessageMapping(&quot;/ws/chat&quot;) // 指定要接收消息的地址，类似@RequestMapping。除了注解到方法上，也可以注解到类上 @SendTo(&quot;/topic/say&quot;) // 注解表示当服务器有消息需要推送的时候，会对订阅了@SendTo中路径的浏览器发送消息 public ResponseMessage say(RequestMessage message) { System.out.pringln(message.getName()); return new ResponseMessage(&quot;welcome&quot; + message.getName() + &quot; !&quot;); } /** * 定时推送消息 */ @Scheduled(fixedRate=1000) public void callback() { // 发现消息 DateFormat df = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); messageingTemplate.convertAndSend(&quot;/topic/callback&quot;, &quot;定时推送消息时间：&quot; + df.format(new Date())); } } 前端调用方式类似如下： var stompClient = null; function connect() { var socket = new SockJS(&#39;http://localhost:8081/simple&#39;); // 连接到/simple节点 stompClient = Stomp.over(socket); stompClient.connect({}, function (frame) { setConnected(true); console.log(&#39;Connected:&#39; + frame); // 会接收到服务器的say方法的返回 stompClient.subscribe(&#39;/topic/say&#39;, function (response) { showResponse(JSON.parse(response.body).responseMessage); }); // 再订阅一下定时任务 stompClient.subscribe(&#39;/topic/callback&#39;, function (response) { showCallback(response.body); }); }); } function disconnect() { if (stompClient != null) { stompClient.disconnect(); } console.log(&#39;Disconnected&#39;); } function sendName() { var name = $(&#39;#name&#39;).val(); console.log(&#39;name:&#39; + name); stompClient.send(&quot;/welcome&quot;, {}, JSON.stringify({&#39;name&#39;: name})); // 想/welcome的url发送消息 } function showResponse(message) { $(&quot;#response&quot;).html(message); } function showCallback(message) { $(&quot;#callback&quot;).html(message); }","categories":[{"name":"生活","slug":"生活","permalink":"http://goodguyjameswin.github.io/categories/生活/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://goodguyjameswin.github.io/tags/学习笔记/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"http://goodguyjameswin.github.io/categories/生活/"}]},{"title":"优先队列","slug":"优先队列","date":"2022-05-15T10:43:39.000Z","updated":"2022-07-18T03:45:09.278Z","comments":false,"path":"2022/05/15/优先队列/","link":"","permalink":"http://goodguyjameswin.github.io/2022/05/15/优先队列/","excerpt":"","text":"堆优先队列是抽象数据类型，而堆是具体的、高效的实现，显然用数组可以实现优先队列，但是无法突破时间复杂度O(N)的限制，可以通过将数组表示成树形结构来实现堆，其优点是不用维护左右子结点、父结点的引用关系。 完全二叉树，指的是在二叉树的基础上，从上至下、从左至右没有空结点。堆是完全二叉树，又分为最大堆和最小堆，前者表示任一结点的数值都大于等于它的两个孩子结点的数值，后者则表示任一结点的数值都小于等于它的两个孩子结点（如存在）的数值，因此它是一个局部有序的结构。","categories":[{"name":"生活","slug":"生活","permalink":"http://goodguyjameswin.github.io/categories/生活/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://goodguyjameswin.github.io/tags/学习笔记/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"http://goodguyjameswin.github.io/categories/生活/"}]},{"title":"springmvc学习","slug":"springmvc学习","date":"2022-05-12T03:35:02.000Z","updated":"2022-07-18T03:57:27.812Z","comments":false,"path":"2022/05/12/springmvc学习/","link":"","permalink":"http://goodguyjameswin.github.io/2022/05/12/springmvc学习/","excerpt":"","text":"构建工程xml配置方式开发新建Maven父工程，导入SpringMVC依赖： &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.3.20&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;4.0.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet.jsp-api&lt;/artifactId&gt; &lt;version&gt;2.3.3&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp.jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; 新建一个Module，添加web的支持： 确保附加库可被打包进web工程： 配置Tomcat： 配置web.xml，注册DispatcherServlet： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;!-- 配置DispatcherServlet --&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;!-- 关联 Spring 的配置文件 --&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;!-- 启动级别：随着服务器启动而启动 --&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!-- / 匹配所有的请求（不包括.jsp），/* 配置所有的请求（包括.jsp） --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!-- 配置 Spring MVC 的乱码过滤 --&gt; &lt;filter&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;/web-app&gt; resources目录下新建Spring的配置文件applicationContext.xml： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!-- 添加处理映射器 --&gt; &lt;bean class=&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;/&gt; &lt;!-- DispatchServlet 调用 HandlerMapping，HandlerMapping 根据请求 url 查找 Handler --&gt; &lt;!-- 添加处理器适配器 --&gt; &lt;bean class=&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;/&gt; &lt;!-- HandlerAdapter 按照特定的规则去执行 Handler，Handler 让具体的 Controller 执行，Controller 将具体的执行信息返回给 HandlerAdapter，HandlerAdapter 将模型视图（ModelAndView）传递给 DispatcherServlet --&gt; &lt;!--添加视图解析器--&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt; &lt;/bean&gt; &lt;!-- DispatcherServlet 调用视图解析器（ViewResolver）来解析 HandlerAdapter 传递的逻辑视图名，DispatcherServlet 调用具体的视图，最终呈现给用户 --&gt; &lt;!-- Handler --&gt; &lt;bean id=&quot;/hello&quot; class=&quot;controller.HelloController&quot;/&gt; &lt;!-- HandlerExecution 表示具体的 Handler，其根据 url 查找 Controller，然后将解析后的信息传递给 DispatcherServlet --&gt; &lt;/beans&gt; 新建Controller层： // 导入 SpringMVC 下的 Controller 接口 public class HelloController implements Controller { public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception{ ModelAndView mv = new ModelAndView(); mv.addObject(&quot;msg&quot;, &quot;HelloSpringMVC!&quot;); mv.setViewName(&quot;hello&quot;); // /WEB-INF/jsp/hello.jsp return mv; } } 注解方式开发修改applicationContext.xml文件： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!--1. 注解驱动--&gt; &lt;mvc:annotation-driven/&gt; &lt;!-- 在 spring 中一般采用 @RequestMapping 注解来完成映射关系，要想使 @RequestMapping 注解生效，必须向上下文中注册 DefaultAnnotationHandlerMapping 和一个 AnnotationMethodHandlerAdapter 实例，这两个实例分别在类级别和方法级别处理，而 annotation-driven 配置帮助我们自动完成上述两个实例的注入 --&gt; &lt;!--2. 静态资源过滤--&gt; &lt;mvc:default-servlet-handler/&gt; &lt;!--3. 扫描包：controller--&gt; &lt;context:component-scan base-package=&quot;controller&quot;/&gt; &lt;!--4. 视图解析器--&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt; &lt;/bean&gt; &lt;/beans&gt; 修改Controller层： @Controller public class HelloController { @RequestMapping(&quot;/hello&quot;) // 也可在类上注解，表示映射方法与映射类的路径拼接关系 public String hello(@RequestParam(&quot;username&quot;) String name, Model model) { // 接受前端用户传递的参数，判断参数的名字，假设名字一致，可以直接使用，假设传递的是一个对象，则匹配对象中的字段名，名字不一致则匹配不到，此时使用 @RequestParam 指定要接收传递的参数名 model.addAttribute(&quot;msg&quot;, &quot;Hello, SpringMVCAnnotation!&quot;); // 封装数据 return &quot;hello&quot;; // 会被视图解析器处理 // 不配置视图解析器的情况下 // return &quot;/WEB-INF/jsp/hello.jsp&quot; // 使用全限定路径表示转发 // return &quot;forward:/WEB-INF/jsp/hello.jsp&quot; // 转发（地址栏不变） // return &quot;redirect:/hello.jsp&quot; // 重定向（地址栏变化） } } // RestFul 风格 @Controller public class RestFulController { // 映射访问路径 @RequestMapping(value = &quot;/add/{a}/{b}&quot;, method = &quot;RequestMethod.POST&quot;) // @PostMapping(&quot;/add/{a}/{b}&quot;) // 方法级别的注解处理地址栏的指定请求方式 public String add(@PathVariable int a, @PathVariable String b, Model model) { // @PathVariable 注解让方法参数的值对应绑定到一个 URL 模板变量 int result = a + b; // Spring MVC 会自动实例化一个 Model 对象用于向视图中传值 model.addAtrribute(&quot;msg&quot;, &quot;结果：&quot; + result); return &quot;hello&quot;; } } json导入jackson依赖： &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.13.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;2.0.4&lt;/version&gt; &lt;/dependency&gt; 修改Controller层： @Controller // @RestController // 表示这个类下的所有方法都不会被视图解析器解析，而是直接返回 public class UserController { // 解决json数据乱码问题（不常用） @RequestMapping(value = &quot;/j1&quot;, produces = &quot;application/json;charset=utf-8&quot;) @ResponseBody // 这个方法被视图解析器解析，而是直接返回一个字符串，与 @RestController 效果相同 public String json() throws JsonProcessingException { // jackson ObjectMapper mapper = new ObjectMapper(); User user = new User(&quot;小明&quot;, 3, &quot;男&quot;); String str = mapper.writeValueAsString(user); // 方法将对象转换为json格式字符串 return str; // fastjson // str = JSON.toJSONString(user); // java 对象转 JSON 字符串 // User user_json = JSON.parseObject(str, User.class); // JSON 字符串转 java 对象 } } 为了解决json乱码问题，在applicationContext.xml文件中添加： &lt;mvc:annotation-driven&gt; &lt;mvc:message-converters register-defaults=&quot;true&quot;&gt; &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt; &lt;constructor-arg value=&quot;UTF-8&quot;/&gt; &lt;/bean&gt; &lt;bean class=&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;&gt; &lt;property name=&quot;objectMapper&quot;&gt; &lt;bean class=&quot;org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean&quot;&gt; &lt;property name=&quot;failOnEmptyBeans&quot; value=&quot;false&quot;/&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt; &lt;/mvc:annotation-driven&gt; 拦截器继承HandlerInterceptor接口： public class MyInterceptor implements HandlerInterceptor { // 请求处理的方法之前执行 // 如果返回 true，放行（如果有，执行下一个拦截器） // 如果返回 false，则拦截 public boolean preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) { System.out.pringln(&quot;-------处理前-------&quot;); return true; } public boolean postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) { System.out.pringln(&quot;-------处理后-------&quot;); } } 在applicationContext.xml文件中添加： &lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;!-- 包括这个请求下面的所有的请求 --&gt; &lt;mvc:mapping path=&quot;/**&quot;/&gt; &lt;bean class=&quot;interceptor.MyInterceptor&quot;/&gt; &lt;/mvc:interceptro&gt; &lt;/mvc:interceptors&gt; 文件上传导入依赖： &lt;!-- 文件上传 --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt; &lt;/dependency&gt; 在applicationContext.xml文件中添加： &lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt; &lt;!-- 请求的编码方式，必须和 jsp 的 pageEncoding 属性一致，以便正确读取表单内容，默认为 ISO-8859-1 --&gt; &lt;property name=&quot;defaultEncoding&quot; value=&quot;utf-8&quot;/&gt; &lt;/bean&gt; 修改Controller层: @RestController public class FileController { // @RequestParam(&quot;file&quot;) 将 name=file 控件得到的文件封装成 CommonsMultipartFile对象 @RequestMapping(&quot;/upload&quot;) public String fileUpload(@RequestParam(&quot;file&quot;) CommonsMultipartFile file, HttpServletRequest request) throws IOException { // 上传路径保存设置 String path = request.getServletContext().getRealPath(&quot;/upload&quot;); File realPath = new File(path); if (!realPath.exists()) { realPath.mkdir(); } // 上传文件地址 System.out.println(&quot;上传文件保存地址:&quot; + realPath); // 通过 CommonsMultipartFile 的方法直接写文件 file.transferTo(new File(realPath + &quot;/&quot; + file.getOriginalFilename())); return &quot;ok&quot;; } }","categories":[{"name":"生活","slug":"生活","permalink":"http://goodguyjameswin.github.io/categories/生活/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://goodguyjameswin.github.io/tags/学习笔记/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"http://goodguyjameswin.github.io/categories/生活/"}]},{"title":"yolov5-dota-obb","slug":"yolov5-dota-obb","date":"2022-05-10T02:19:20.000Z","updated":"2022-07-18T03:40:11.758Z","comments":false,"path":"2022/05/10/yolov5-dota-obb/","link":"","permalink":"http://goodguyjameswin.github.io/2022/05/10/yolov5-dota-obb/","excerpt":"","text":"简介最近出于项目需要，针对旋转目标检测的任务，做一个深度学习方案。浏览过程中看到一个国内大佬，针对yolov5做了修改，引入了长边表示法对旋转矩形检测框的定义，感觉效果还不错，标签的格式也比较好懂，准备上手尝试 好家伙，还是离不开DOTA_devkit的编译，今年四月份左右想入这个坑，就被windows上各种第三方库的编译给劝退了，然后发现旋转目标检测，基本都离不开对这个工具包的编译，因为旋转目标检测网络目前基本都是用DOTA数据集作benchmark，这个工具包可以很好的处理DOTA数据集 后来发现其实编译这个工具包，目的是调用其中有关多边形（旋转矩形框）做NMS（非极大值抑制）的方法，好说，我记得python有个shapely的库，也可以做多边形的IOU（重叠面积占比）运算。 挖坑踩坑这个工程，训练的时候跟原本的yolov5生态环境是一样的，方法调用不需要其他第三方库的支持，比如经典的mosaic数据增强，但是有几个坑 比如原作者的长边表示法是针对opencv4.2以前的版本中minAreaRect这一函数所返回的旋转矩形框所定义的角度做的优化，在高版本的opencv（比如opencv4.5以上）就不支持了。还有就是高版本的pytorch需要针对错误“torch.nn.modules.module.ModuleAttributeError: ‘Hardswish’ object has no attribute ‘inplace’”，找到pytorch的源码部分并做修改 def __init__(self, inplace : bool = False) -&gt; None: super(Hardwish, self).__init__() self.inplace = inplace def forward(self, input : Tensor) -&gt; Tensor: # 源码如下： # return F.hardwish(input, self.inplace) # 修改如下： return F.hardwish(input) 然后重点就是预测的时候，因为需要对经过网络前向推理后的结果（旋转矩形检测框）做NMS，这里需要调用DOTA_devkit工具包里编译好的iou_poly及poly_nms方法，用shapely库重写这一块 from shapely.geometry import Polygon, MultiPoint def iou_rotated_rect(line1, line2): a = np.array(line1).reshape(4, 2) poly1 = Polygon(a).convex_hull b = np.array(line2).reshape(4, 2) poly2 = Polygon(b).convex_hull union_poly = np.concatenate((a, b)) if not poly1.intersects(poly2): # if there is no intersection between two polygons iou = 0 else: inter_area = poly1.intersection(poly2).area # intersection area print(inter_area) union_area = MultiPoint(union_poly).convex_hull.area print(union_area) if union_area == 0: iou = 0 iou = float(inter_area) / union_area return iou def nms_rotated_rect(dets, scores, thresh): obbs = dets[:, 0:-1] x1 = np.min(obbs[:, 0::2], axis=1) y1 = np.min(obbs[:, 1::2], axis=1) x2 = np.max(obbs[:, 0::2], axis=1) y2 = np.max(obbs[:, 1::2], axis=1) areas = (x2 - x1 + 1) * (y2 - y1 + 1) polys = [] for i in range(len(dets)): tm_polygon = [dets[i][0], dets[i][1], dets[i][2], dets[i][3], dets[i][4], dets[i][5], dets[i][6], dets[i][7]] polys.append(tm_polygon) order = scores.argsort()[::-1] keep = [] while order.size &gt; 0: i = order[0] keep.append(i) xx1 = np.maximum(x1[i], x1[order[1:]]) yy1 = np.maximum(y1[i], y1[order[1:]]) xx2 = np.minimum(x2[i], x2[order[1:]]) yy2 = np.minimum(y2[i], y2[order[1:]]) w = np.maximum(0.0, xx2 - xx1) h = np.maximum(0.0, yy2 - yy1) hbb_inter = w * h hbb_ovr = hbb_inter / (areas[i] + areas[order[1:]] - hbb_inter) h_inds = np.where(hbb_ovr &gt; 0)[0] tmp_order = order[h_inds + 1] for j in range(tmp_order.size): iou = iou_rotated_rect(polys[i], polys[tmp_order[j]]) hbb_ovr[h_inds[j]] = iou inds = np.where(hbb_ovr &lt;= thresh)[0] order = order[inds + 1] return keep 然后去掉原工程下detect.py中数据后处理部分对DOTA_devkit工具包的依赖 def rotate_non_max_suppression(...): ... # 源码如下： # i = np.array(py_cpu_nms_poly_fast(np.array(rects), np.array(scores.cpu()), iou_thres)) # 修改如下： i = np.array(nms_rotated_rect(np.array(rects), np.array(scores.cpu()), iou_thres)) ... 修改完毕，用“纯净版”的YOLOv5_DOTA_OBB跑一下demo，发现模型可以正常预测，性能好像也没有损失 然后开始制作自己的数据集，训练并测试，这里我用的是以前用过的标注工具labelimg2 不过输出的格式是voc格式，所以我修改了下源码，让它能生成DOTA数据集格式的标签，在原工程的libs/labelFile.py里添加如下代码，会在当前目录下生成一个labels文件夹，里面存放对应标注图片的DOTA格式标签 label_dir = os.path.join(imgFolderPath, &quot;labels&quot;) if not os.path.exists(label_dir): os.makedirs(label_dir) label_file = os.path.join(label_dir, os.path.splitext(imgFileName)[0] + &#39;.txt&#39;) with open(label_file, &#39;w&#39;) as l: for shape in shapes: points = shape[&#39;points&#39;] label = shape[&#39;label&#39;] l.write(&#39; &#39;.join([str(points[0][0]), str(points[0][1]), str(points[1][0]), str(points[1][1]), str(points[2][0]), str(points[2][1]), str(points[3][0]), str(points[3][1]), label]) + &#39;\\n&#39;) 这里调用我自己修改的脚本，参考原项目，可以设置一下每张图片（标注好的）的增强次数，以及各类数据增强方法的参数 接着根据原作者提供的工具，将带DOTA格式标签的数据转换为“长边表示法”格式的标签数据，对应的格式转换代码如下 def dota2LongSideFormat(imgpath, txtpath, dstpath, extractclassname): if os.path.exists(dstpath): shutil.rmtree(dstpath) # delete output folder os.makedirs(dstpath) # make new output folder filelist = GetFileFromThisRootDir(txtpath) # fileist=[&#39;/.../P0005.txt&#39;, ..., /.../P000?.txt] for fullname in filelist: # fullname=&#39;/.../P000?.txt&#39; objects = parse_dota_poly(fullname) name = os.path.splitext(os.path.basename(fullname))[0] # name=&#39;P000?&#39; img_fullname = os.path.join(imgpath, name + &#39;.jpg&#39;) # img_fullname=&#39;/.../P000?.png&#39; img = Image.open(img_fullname) img_w, img_h = img.size # print img_w,img_h with open(os.path.join(dstpath, name + &#39;.txt&#39;), &#39;w&#39;) as f_out: num_gt = 0 for i, obj in enumerate(objects): num_gt = num_gt + 1 # 为当前有效gt计数 poly = obj[&#39;poly&#39;] # poly=[(x1,y1),(x2,y2),(x3,y3),(x4,y4)] poly = np.float32(np.array(poly)) # 四点坐标归一化 poly[:, 0] = poly[:, 0] / img_w poly[:, 1] = poly[:, 1] / img_h rect = cv2.minAreaRect(poly) # 得到最小外接矩形的（中心(x,y), (宽,高), 旋转角度） c_x = rect[0][0] c_y = rect[0][1] w = rect[1][0] h = rect[1][1] theta = rect[-1] # Range for angle is [-90，0) trans_data = cvminAreaRect2longsideformat(c_x, c_y, w, h, theta) if not trans_data: if theta != 90: # Θ=90说明wh中有为0的元素，即gt信息不完整，无需提示异常，直接删除 print(&#39;opencv表示法转长边表示法出现异常,已将第%d个box排除,问题出现在该图片中:%s&#39; % (i, img_fullname)) num_gt = num_gt - 1 continue else: # range:[-180，0) c_x, c_y, longside, shortside, theta_longside = trans_data bbox = np.array((c_x, c_y, longside, shortside)) if (sum(bbox &lt;= 0) + sum(bbox[:2] &gt;= 1)) &gt;= 1: # 0&lt;xy&lt;1, 0&lt;side&lt;=1 print(&#39;bbox[:2]中有&gt;= 1的元素,bbox中有&lt;= 0的元素,已将第%d个box排除,问题出现在该图片中:%s&#39; % (i, img_fullname)) print(&#39;出问题的longside形式数据:[%.16f, %.16f, %.16f, %.16f, %.1f]&#39; % ( c_x, c_y, longside, shortside, theta_longside)) num_gt = num_gt - 1 continue if (obj[&#39;name&#39;] in extractclassname): id = extractclassname.index(obj[&#39;name&#39;]) # id=类名的索引 比如&#39;plane&#39;对应id=0 else: print(&#39;预定类别中没有类别:%s;已将该box排除,问题出现在该图片中:%s&#39; % (obj[&#39;name&#39;], fullname)) num_gt = num_gt - 1 continue theta_label = int(theta_longside + 180.5) # range int[0,180] 四舍五入 if theta_label == 180: # range int[0,179] theta_label = 179 # outline=&#39;id x y longside shortside Θ&#39; # final check if id &gt; 15 or id &lt; 0: print(&#39;id problems,问题出现在该图片中:%s&#39; % (i, img_fullname)) print(&#39;出问题的longside形式数据:[%.16f, %.16f, %.16f, %.16f, %.1f]&#39; % ( c_x, c_y, longside, shortside, theta_longside)) if theta_label &lt; 0 or theta_label &gt; 179: print(&#39;id problems,问题出现在该图片中:%s&#39; % (i, img_fullname)) print(&#39;出问题的longside形式数据:[%.16f, %.16f, %.16f, %.16f, %.1f]&#39; % ( c_x, c_y, longside, shortside, theta_longside)) outline = str(id) + &#39; &#39; + &#39; &#39;.join(list(map(str, bbox))) + &#39; &#39; + str(theta_label) f_out.write(outline + &#39;\\n&#39;) # 写入txt文件中并加上换行符号 \\n if num_gt == 0: os.remove(os.path.join(dstpath, name + &#39;.txt&#39;)) # os.remove(img_fullname) os.remove(fullname) print(&#39;%s 图片对应的txt不存在有效目标,已删除对应图片与txt&#39; % img_fullname) print(&#39;已完成文件夹内DOTA数据形式到长边表示法的转换&#39;) def cvminAreaRect2longsideformat(x_c, y_c, width, height, theta): if theta == 0: theta = -90 buffer_width = width width = height height = buffer_width if theta &gt; 0: if theta != 90: # Θ=90说明wh中有为0的元素，即gt信息不完整，无需提示异常，直接删除 print(&#39;θ计算出现异常，当前数据为：%.16f, %.16f, %.16f, %.16f, %.1f;超出opencv表示法的范围：[-90,0)&#39; % ( x_c, y_c, width, height, theta)) return False if theta &lt; -90: print( &#39;θ计算出现异常，当前数据为：%.16f, %.16f, %.16f, %.16f, %.1f;超出opencv表示法的范围：[-90,0)&#39; % (x_c, y_c, width, height, theta)) return False if width != max(width, height): # 若width不是最长边 longside = height shortside = width theta_longside = theta - 90 else: # 若width是最长边(包括正方形的情况) longside = width shortside = height theta_longside = theta if longside &lt; shortside: print(&#39;旋转框转换表示形式后出现问题：最长边小于短边;[%.16f, %.16f, %.16f, %.16f, %.1f]&#39; % ( x_c, y_c, longside, shortside, theta_longside)) return False if (theta_longside &lt; -180 or theta_longside &gt;= 0): print(&#39;旋转框转换表示形式时出现问题:θ超出长边表示法的范围：[-180,0);[%.16f, %.16f, %.16f, %.16f, %.1f]&#39; % ( x_c, y_c, longside, shortside, theta_longside)) return False return x_c, y_c, longside, shortside, theta_longside 有了数据集，接下来就是训练调参了，一开始训练采用的原作者的默认配置，后来loss就是降不下来，测试效果也就肉眼可见的差，翻了翻评论区，结合自己的一点点对超参数的理解，修改hyp_scratch.yaml文件中各部分loss的权重，以及根据评论区原作者建议，调低了mosaic数据增强的启用概率，然后象征性地打开了mixup数据增强 由于原作者使用“长边表示法”表示旋转矩形框的算法具有局限性，标签在高版本opencv上无法成功从DOTA格式转换为longsideformat格式，宽高不等的图片无法作为数据正常送入网络进行训练，这是由于作者是先对图像宽高进行归一化之后再转换标签格式，然后在longsideformat格式下进行图片像素坐标的去归一化（会导致标签由旋转矩形框变成类平行四边形框），有一个好的解决方案是对图片归一化时，宽高都针对两者中的较大值作为归一化的分母做归一化，这样转换标签格式后，图片像素坐标去归一化的分母还是一样的，不会产生标签偏移，最好的解决办法是修改标签转换部分代码以及整个深度学习工程的像素坐标归一化与去归一化过程，但是这样修改起来工作量较大，且可行性得不到验证，因此目前仍建议采用宽高相等的图片作为训练数据 如果数据增强的时候，开启了多种增强方式（如旋转，平移，裁剪），建议训练的时候，将角度、box和置信度的loss权重调高，若不是做多分类，分类部分的loss权重可以调低，生成的训练数据集比较复杂的情况下，mosaic和mixup数据增强方式的启用概率可以适当调低，并且为了保证网络收敛，建议调高epochs，并且采用Adam优化算法 忙活了半天，终于训练出来一个还不错的效果了 640*640的图片，gpu单张预测时间在0.1s左右","categories":[{"name":"技术","slug":"技术","permalink":"http://goodguyjameswin.github.io/categories/技术/"}],"tags":[{"name":"开源项目","slug":"开源项目","permalink":"http://goodguyjameswin.github.io/tags/开源项目/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://goodguyjameswin.github.io/categories/技术/"}]},{"title":"rotated_data_maker","slug":"rotated-data-maker","date":"2022-05-08T13:30:45.000Z","updated":"2022-07-18T03:57:17.841Z","comments":false,"path":"2022/05/08/rotated-data-maker/","link":"","permalink":"http://goodguyjameswin.github.io/2022/05/08/rotated-data-maker/","excerpt":"","text":"简介一个用于数据增广的脚本，实验室的深度学习方案，针对性的真实数据永远都只有几张图，可是网络模型的性能本身就是建立在数据集的多样性上面，合成数据只能在一定程度上缓解数据量不足的问题，而且过度依赖合成数据容易导致模型过拟合，且无法从根本上提高模型的鲁棒性 用于生成可以训练多角度目标检测的网络的合成训练数据， 需要背景图和模板图 然后合成的图片大概长这个样子，也没打算再去做进一步的美化了 合成图片的过程中，将位置信息也记录下来，格式是DOTA数据集的标签样式 因为确实没什么实用性，写了一两天感觉也只是为了完成任务，细节的话，有兴趣可以看看这个贴图脚本","categories":[{"name":"技术","slug":"技术","permalink":"http://goodguyjameswin.github.io/categories/技术/"}],"tags":[{"name":"开源项目","slug":"开源项目","permalink":"http://goodguyjameswin.github.io/tags/开源项目/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://goodguyjameswin.github.io/categories/技术/"}]},{"title":"mybatis学习","slug":"mybatis学习","date":"2022-05-07T01:50:37.000Z","updated":"2022-07-18T03:42:28.720Z","comments":false,"path":"2022/05/07/mybatis学习/","link":"","permalink":"http://goodguyjameswin.github.io/2022/05/07/mybatis学习/","excerpt":"","text":"构建工程Mybatis中文文档 入门新建Maven父工程，导入依赖： &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.9&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.29&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Maven中静态资源过滤 --&gt; &lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt; 从xml文件中构建SqlSessionFactory： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt; &lt;configuration&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;${driver}&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;${url}&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;${username}&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;${password}&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=&quot;org/mybatis/example/BlogMapper.xml&quot;/&gt; &lt;/mappers&gt; &lt;/configuration&gt; 新建工具类： public class MabatisUtils() { private String resource; public MybatisUtils(String resouce) { this.resource = resource; } public static SqlSessionFactory getSqlSessionFactory() { InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); return sqlSessionFactory; } } 从xml文件中构建映射器（Mappers）： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; &lt;mapper namespace=&quot;org.mybatis.example.BlogMapper&quot;&gt; &lt;select id=&quot;selectBlog&quot; resultType=&quot;Blog&quot;&gt; select * from Blog where id = #{id} &lt;/select&gt; &lt;/mapper&gt; 或者使用注解： package org.mybatis.example; public interface BlogMapper { @Select(&quot;SELECT * FROM blog WHERE id = #{id}&quot;) Blog selectBlog(int id); } 新建测试类： import MybatisUtils; public class Test() { public static void main(String[] args) { SqlSessionFactory sqlSessionFactory = MybatisUtils.getSqlSessionFactory(); try (SqlSession session = sqlSessionFactory.openSession()) { BlogMapper mapper = session.getMapper(BlogMapper.class); Blog blog = mapper.selectBlog(101); } } } 结果映射&lt;resultMap id=&quot;userResultMap&quot; type=&quot;User&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;user_id&quot; /&gt; &lt;result property=&quot;username&quot; column=&quot;user_name&quot;/&gt; &lt;result property=&quot;password&quot; column=&quot;hashed_password&quot;/&gt; &lt;/resultMap&gt; &lt;select id=&quot;selectUsers&quot; resultMap=&quot;userResultMap&quot;&gt; select user_id, user_name, hashed_password from some_table where id = #{id} &lt;/select&gt; 关联（多对一） &lt;resultMap id=&quot;blogResult&quot; type=&quot;Blog&quot;&gt; &lt;association property=&quot;author&quot; column=&quot;author_id&quot; javaType=&quot;Author&quot; select=&quot;selectAuthor&quot;/&gt; &lt;/resultMap&gt; &lt;select id=&quot;selectBlog&quot; resultMap=&quot;blogResult&quot;&gt; SELECT * FROM BLOG WHERE ID = #{id} &lt;/select&gt; &lt;select id=&quot;selectAuthor&quot; resultType=&quot;Author&quot;&gt; SELECT * FROM AUTHOR WHERE ID = #{id} &lt;/select&gt; 集合（一对多） &lt;resultMap id=&quot;blogResult&quot; type=&quot;Blog&quot;&gt; &lt;collection property=&quot;posts&quot; javaType=&quot;ArrayList&quot; column=&quot;id&quot; ofType=&quot;Post&quot; select=&quot;selectPostsForBlog&quot;/&gt; &lt;/resultMap&gt; &lt;select id=&quot;selectBlog&quot; resultMap=&quot;blogResult&quot;&gt; SELECT * FROM BLOG WHERE ID = #{id} &lt;/select&gt; &lt;select id=&quot;selectPostsForBlog&quot; resultType=&quot;Post&quot;&gt; SELECT * FROM POST WHERE BLOG_ID = #{id} &lt;/select&gt; 动态SQL根据条件包含 where 子句的一部分，使用 if 标签： &lt;select id=&quot;findActiveBlogLike&quot; resultType=&quot;Blog&quot;&gt; SELECT * FROM BLOG WHERE state = ‘ACTIVE’ &lt;if test=&quot;title != null&quot;&gt; AND title like #{title} &lt;/if&gt; &lt;if test=&quot;author != null and author.name != null&quot;&gt; AND author_name like #{author.name} &lt;/if&gt; &lt;/select&gt; 从多个条件中选择一个，使用 choose、when、otherwise 标签： &lt;select id=&quot;findActiveBlogLike&quot; resultType=&quot;Blog&quot;&gt; SELECT * FROM BLOG WHERE state = ‘ACTIVE’ &lt;choose&gt; &lt;when test=&quot;title != null&quot;&gt; AND title like #{title} &lt;/when&gt; &lt;when test=&quot;author != null and author.name != null&quot;&gt; AND author_name like #{author.name} &lt;/when&gt; &lt;otherwise&gt; AND featured = 1 &lt;/otherwise&gt; &lt;/choose&gt; &lt;/select&gt; trim 用于定制元素的功能： &lt;select id=&quot;findActiveBlogLike&quot; resultType=&quot;Blog&quot;&gt; SELECT * FROM BLOG &lt;where&gt; &lt;if test=&quot;state != null&quot;&gt; state = #{state} &lt;/if&gt; &lt;if test=&quot;title != null&quot;&gt; AND title like #{title} &lt;/if&gt; &lt;if test=&quot;author != null and author.name != null&quot;&gt; AND author_name like #{author.name} &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; &lt;update id=&quot;updateAuthorIfNecessary&quot;&gt; update Author &lt;set&gt; &lt;if test=&quot;username != null&quot;&gt;username=#{username},&lt;/if&gt; &lt;if test=&quot;password != null&quot;&gt;password=#{password},&lt;/if&gt; &lt;if test=&quot;email != null&quot;&gt;email=#{email},&lt;/if&gt; &lt;if test=&quot;bio != null&quot;&gt;bio=#{bio}&lt;/if&gt; &lt;/set&gt; where id=#{id} &lt;/update&gt; &lt;trim prefix=&quot;WHERE&quot; prefixOverrides=&quot;AND |OR &quot;&gt; ... &lt;/trim&gt; &lt;trim prefix=&quot;SET&quot; suffixOverrides=&quot;,&quot;&gt; ... &lt;/trim&gt; 对集合进行遍历： &lt;select id=&quot;selectPostIn&quot; resultType=&quot;domain.blog.Post&quot;&gt; SELECT * FROM POST P &lt;where&gt; &lt;foreach item=&quot;item&quot; index=&quot;index&quot; collection=&quot;list&quot; open=&quot;ID in (&quot; separator=&quot;,&quot; close=&quot;)&quot; nullable=&quot;true&quot;&gt; #{item} &lt;/foreach&gt; &lt;/where&gt; &lt;/select&gt;","categories":[{"name":"生活","slug":"生活","permalink":"http://goodguyjameswin.github.io/categories/生活/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://goodguyjameswin.github.io/tags/学习笔记/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"http://goodguyjameswin.github.io/categories/生活/"}]},{"title":"yolact","slug":"yolact","date":"2022-05-05T03:34:57.000Z","updated":"2022-07-18T03:40:38.551Z","comments":false,"path":"2022/05/05/yolact/","link":"","permalink":"http://goodguyjameswin.github.io/2022/05/05/yolact/","excerpt":"","text":"简介奉老师之命，调试一个实例分割的网络，用来做缺陷检测，至于为什么用实例分割网络做缺陷检测，我也不清楚，反正他老人家的意思是要能够在c++那头部署，好让人家写界面封装。话不多说，开始做数据！ 踩坑挖坑盯上了一个可以用ncnn部署的实例分割网络yolact，先考虑能否使用opencv的dnn库进行网络的部署，参考项目，使用official版yolact工程里自带的训练.pth权重，先转换成.onnx格式。这里有一个坑，貌似低版本的opencv，会报错，安装高版本（如opencv4.5）可以解决权重转换报错。其次就是，训练时使用的pytorch，一定要和.pth权重文件转.onnx格式时使用的pytorch版本对应 然后在c++端进行推理，发现可以成功，300*300的demo图片cpu推理时间在700ms左右，坚定了调试yolact工程的决心 然后去踩yolact网络训练测试的坑，发现同样是opencv版本低带来的坑，读训练图片的时候会报错，升级一下opencv版本就好了 用labelme工具标注图片分割数据，产生的json格式标签，同样的用脚本扩充一下数据集，验证一下标签转换是否正确 然后把标注并且增广后的数据及json格式标签，转换为COCO格式数据集 def main(): parser = argparse.ArgumentParser( formatter_class=argparse.ArgumentDefaultsHelpFormatter ) parser.add_argument(&quot;input_dir&quot;, help=&quot;input annotated directory&quot;) parser.add_argument(&quot;output_dir&quot;, help=&quot;output dataset directory&quot;) parser.add_argument(&quot;--labels&quot;, help=&quot;labels file&quot;, required=True) parser.add_argument( &quot;--noviz&quot;, help=&quot;no visualization&quot;, action=&quot;store_true&quot; ) args = parser.parse_args() if osp.exists(args.output_dir): print(&quot;Output directory already exists:&quot;, args.output_dir) sys.exit(1) os.makedirs(args.output_dir) os.makedirs(osp.join(args.output_dir, os.path.basename(args.input_dir) + &quot;_JPEGImages&quot;)) if not args.noviz: os.makedirs(osp.join(args.output_dir, &quot;Visualization&quot;)) print(&quot;Creating dataset:&quot;, args.output_dir) now = datetime.datetime.now() data = dict( info=dict( description=None, url=None, version=None, year=now.year, contributor=None, date_created=now.strftime(&quot;%Y-%m-%d %H:%M:%S.%f&quot;), ), licenses=[dict(url=None, id=0, name=None,)], images=[ # license, url, file_name, height, width, date_captured, id ], type=&quot;instances&quot;, annotations=[ # segmentation, area, iscrowd, image_id, bbox, category_id, id ], categories=[ # supercategory, id, name ], ) class_name_to_id = {} for i, line in enumerate(open(args.labels).readlines()): class_id = i - 1 # starts with -1 class_name = line.strip() if class_id == -1: assert class_name == &quot;__ignore__&quot; continue class_name_to_id[class_name] = class_id data[&quot;categories&quot;].append( dict(supercategory=None, id=class_id, name=class_name,) ) out_ann_file = osp.join(args.output_dir, os.path.basename(args.input_dir) + &quot;.json&quot;) label_files = glob.glob(osp.join(args.input_dir, &quot;*.json&quot;)) for image_id, filename in enumerate(label_files): print(&quot;Generating dataset from:&quot;, filename) label_file = labelme.LabelFile(filename=filename) base = osp.splitext(osp.basename(filename))[0] out_img_file = osp.join(args.output_dir, os.path.basename(args.input_dir) + &quot;_JPEGImages&quot;, base + &quot;.jpg&quot;) img = labelme.utils.img_data_to_arr(label_file.imageData) imgviz.io.imsave(out_img_file, img) data[&quot;images&quot;].append( dict( license=0, url=None, file_name=osp.relpath(out_img_file, osp.dirname(out_ann_file)), height=img.shape[0], width=img.shape[1], date_captured=None, id=image_id, ) ) masks = {} # for area segmentations = collections.defaultdict(list) # for segmentation for shape in label_file.shapes: points = shape[&quot;points&quot;] label = shape[&quot;label&quot;] group_id = shape.get(&quot;group_id&quot;) shape_type = shape.get(&quot;shape_type&quot;, &quot;polygon&quot;) mask = labelme.utils.shape_to_mask( img.shape[:2], points, shape_type ) if group_id is None: group_id = uuid.uuid1() instance = (label, group_id) if instance in masks: masks[instance] = masks[instance] | mask else: masks[instance] = mask if shape_type == &quot;rectangle&quot;: (x1, y1), (x2, y2) = points x1, x2 = sorted([x1, x2]) y1, y2 = sorted([y1, y2]) points = [x1, y1, x2, y1, x2, y2, x1, y2] else: points = np.asarray(points).flatten().tolist() segmentations[instance].append(points) segmentations = dict(segmentations) for instance, mask in masks.items(): cls_name, group_id = instance if cls_name not in class_name_to_id: continue cls_id = class_name_to_id[cls_name] mask = np.asfortranarray(mask.astype(np.uint8)) mask = pycocotools.mask.encode(mask) area = float(pycocotools.mask.area(mask)) bbox = pycocotools.mask.toBbox(mask).flatten().tolist() data[&quot;annotations&quot;].append( dict( id=len(data[&quot;annotations&quot;]), image_id=image_id, category_id=cls_id, segmentation=segmentations[instance], area=area, bbox=bbox, iscrowd=0, ) ) if not args.noviz: labels, captions, masks = zip( *[ (class_name_to_id[cnm], cnm, msk) for (cnm, gid), msk in masks.items() if cnm in class_name_to_id ] ) viz = imgviz.instances2rgb( image=img, labels=labels, masks=masks, captions=captions, font_size=15, line_width=2, ) out_viz_file = osp.join( args.output_dir, &quot;Visualization&quot;, base + &quot;.jpg&quot; ) imgviz.io.imsave(out_viz_file, viz) with open(out_ann_file, &quot;w&quot;) as f: json.dump(data, f) 简单配置训练信息，开始训练！ 训练完毕，先在python这边测试一下效果，马马虎虎 然后关键是，能否在c++端部署并成功预测，这里又有一个坑，如果是训练自己的数据集，得到的.pth权重文件在转换.onnx文件时，需要保证网络结构部分读取张量的尺寸能对齐（一般来说是图片尺寸通道数或者训练测试类别数的不一致会导致报错） 训练的模型也比较简单，看了下中间过程的mask图，这边生成的分割图还是不够准确，对模型的训练效果要求还是比较高，貌似效果和python那边预测的有点差距，初步估计是网络前向推理后的数据后处理部分还是有区别吧，留个坑，以后有时间再填~","categories":[{"name":"技术","slug":"技术","permalink":"http://goodguyjameswin.github.io/categories/技术/"}],"tags":[{"name":"开源项目","slug":"开源项目","permalink":"http://goodguyjameswin.github.io/tags/开源项目/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://goodguyjameswin.github.io/categories/技术/"}]},{"title":"spring学习","slug":"spring学习","date":"2022-05-02T06:53:05.000Z","updated":"2022-07-18T03:42:15.132Z","comments":false,"path":"2022/05/02/spring学习/","link":"","permalink":"http://goodguyjameswin.github.io/2022/05/02/spring学习/","excerpt":"","text":"IOCxml配置方式开发创建maven父工程，删去冗余目录，导入依赖： &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.3.20&lt;/version&gt; &lt;/dependency&gt; 创建maven子工程，在src目录下新建实体类，resources目录下新建applicationContext.xml文件，注册实体类： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:c=&quot;http://www.springframework.org/schema/c&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!-- 无参构造 --&gt; &lt;!-- 默认为单例模式（singleton），而原型模式（prototype）指每次从容器中get的时候，都会产生一个新对象 --&gt; &lt;bean id=&quot;exampleBean&quot; class=&quot;examples.ExampleBean&quot; name=&quot;example1, example2,...&quot; scope=&quot;singleton, prototype&quot; autowire=&quot;byName, byType&quot;&gt; &lt;!-- 普通值注入 --&gt; &lt;property name=&quot;prop1&quot; value=&quot;1&quot;/&gt; &lt;!-- Bean注入 --&gt; &lt;property name=&quot;prop2&quot; ref=&quot;exampleBean2&quot;/&gt; &lt;!-- instead of using a reference to a target bean, simply define the target bean inline --&gt; &lt;property name=&quot;target&quot;&gt; &lt;bean class=&quot;com.example.Person&quot;&gt; &lt;!-- this is the inner bean --&gt; &lt;property name=&quot;name&quot; value=&quot;Fiona Apple&quot;/&gt; &lt;property name=&quot;age&quot; value=&quot;25&quot;/&gt; &lt;/bean&gt; &lt;/property&gt; &lt;!-- additional collaborators and configuration for this bean go here --&gt; &lt;/bean&gt; &lt;bean id=&quot;exampleBean2&quot; class=&quot;examples.ExampleBean2&quot;/&gt; &lt;!-- p命名空间注入，p指properties --&gt; &lt;bean name=&quot;john-modern&quot; class=&quot;com.example.Person&quot; p:name=&quot;John Doe&quot; p:spouse-ref=&quot;jane&quot;/&gt; &lt;!-- more bean definitions go here --&gt; &lt;!-- c命名空间注入，c指constructor-args --&gt; &lt;bean id=&quot;beanOne&quot; class=&quot;x.y.ThingOne&quot; c:thingTwo-ref=&quot;beanTwo&quot; c:thingThree-ref=&quot;beanThree&quot; c:email=&quot;something@somewhere.com&quot;/&gt; &lt;!-- 取别名 --&gt; &lt;alias name=&quot;exampleBean&quot; alias=&quot;aliasBean&quot;/&gt; &lt;!-- 导入多个配置文件 --&gt; &lt;import resource=&quot;beans1.xml&quot;/&gt; &lt;import resource=&quot;beans2.xml&quot;/&gt; &lt;/beans&gt; 对象交由 Spring 来创建，管理和装配，在配置文件加载的时候，容器中管理的对象就已经初始化了： // create and configure beans ApplicationContext context = new ClassPathXmlApplicationContext(&quot;services.xml&quot;, &quot;daos.xml&quot;); // retrieve configured instance PetStoreService service = context.getBean(&quot;petStore&quot;, PetStoreService.class); // use configured instance List&lt;String&gt; userList = service.getUsernameList(); 有参构造注入： &lt;!-- 有参构造 --&gt; &lt;!-- 参数名 --&gt; &lt;bean id=&quot;exampleBean&quot; class=&quot;examples.ExampleBean&quot;&gt; &lt;constructor-arg name=&quot;years&quot; value=&quot;7500000&quot;/&gt; &lt;constructor-arg name=&quot;ultimateAnswer&quot; value=&quot;42&quot;/&gt; &lt;/bean&gt; &lt;!-- 类型 --&gt; &lt;bean id=&quot;exampleBean&quot; class=&quot;examples.ExampleBean&quot;&gt; &lt;constructor-arg type=&quot;int&quot; value=&quot;7500000&quot;/&gt; &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;42&quot;/&gt; &lt;/bean&gt; &lt;!-- 下标索引 --&gt; &lt;bean id=&quot;exampleBean&quot; class=&quot;examples.ExampleBean&quot;&gt; &lt;constructor-arg index=&quot;0&quot; value=&quot;7500000&quot;/&gt; &lt;constructor-arg index=&quot;1&quot; value=&quot;42&quot;/&gt; &lt;/bean&gt; setter注入： &lt;bean id=&quot;moreComplexObject&quot; class=&quot;example.ComplexObject&quot;&gt; &lt;!-- results in a setAdminEmails(java.util.Properties) call --&gt; &lt;property name=&quot;adminEmails&quot;&gt; &lt;props&gt; &lt;prop key=&quot;administrator&quot;&gt;administrator@example.org&lt;/prop&gt; &lt;prop key=&quot;support&quot;&gt;support@example.org&lt;/prop&gt; &lt;prop key=&quot;development&quot;&gt;development@example.org&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;!-- results in a setSomeList(java.util.List) call --&gt; &lt;property name=&quot;someList&quot;&gt; &lt;list&gt; &lt;value&gt;a list element followed by a reference&lt;/value&gt; &lt;ref bean=&quot;myDataSource&quot; /&gt; &lt;/list&gt; &lt;/property&gt; &lt;!-- results in a setSomeMap(java.util.Map) call --&gt; &lt;property name=&quot;someMap&quot;&gt; &lt;map&gt; &lt;entry key=&quot;an entry&quot; value=&quot;just some string&quot;/&gt; &lt;entry key=&quot;a ref&quot; value-ref=&quot;myDataSource&quot;/&gt; &lt;/map&gt; &lt;/property&gt; &lt;!-- results in a setSomeSet(java.util.Set) call --&gt; &lt;property name=&quot;someSet&quot;&gt; &lt;set&gt; &lt;value&gt;just some string&lt;/value&gt; &lt;ref bean=&quot;myDataSource&quot; /&gt; &lt;/set&gt; &lt;/property&gt; &lt;property name=&quot;email&quot;&gt; &lt;null/&gt; &lt;/property&gt; &lt;/bean&gt; 注解方式开发修改applicationContext.xml配置文件： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!-- 开启注解驱动支持 --&gt; &lt;context:annotation-config/&gt; &lt;!-- 指定要扫描的包（全限定名），这个包下的注解就会生效 --&gt; &lt;context:component:scan base-package=&quot;...&quot;&gt; &lt;/beans&gt; @Autowired默认通过byType方式实现自动装配，参数required置为false与@Nullable效果相同，@Qualifier指定装配的bean，也可使用javax下的@Resource注解实现前两者的组合： public class MovieRecommender { private final CustomerPreferenceDao customerPreferenceDao; @Autowired(required = false) @Qualifier(&quot;...&quot;) private MovieCatalog movieCatalog; @Autowired public MovieRecommender(@Qualifier(&quot;...&quot;) CustomerPreferenceDao customerPreferenceDao) { this.customerPreferenceDao = customerPreferenceDao; } @Resource(name=&quot;...&quot;) public void setMovieCatalogs(Map&lt;String, MovieCatalog&gt; movieCatalogs) { this.movieCatalogs = movieCatalogs; } // ... } @Component（与@Repository、@Service和@Controller功能相同，后三者在springmvc中使用）将实体类注册到Spring中，@value注入简单参数： @Component @Scope(&quot;prototype&quot;) public class User{ public String name; @Value(&quot;...&quot;) public void setName(String name) { this.name = name; } } 通过JavaConfig方式实现（完全去掉applicationContext.xml配置文件），@Import导入其他配置类： // 配置类 @Configuration @ComponentScan(basePackages=&quot;...&quot;) @Import(...) public class AppConfig { // 等价于 &lt;bean id=&quot;myService&quot; class=&quot;com.acme.services.MyServiceImpl&quot;/&gt; @Bean public MyService myService() { return new MyServiceImpl(); } } // 测试类 public static void main(String[] args) { ApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class); MyService myService = ctx.getBean(MyService.class); myService.doStuff(); } AOP动态代理使用jdk反射库里的Proxy类和InvocationHandler类实现： public class ProxyInvocationHandler implements InvocationHandler { // 被代理的接口 private Object target; public void setTarget(Object target) { this.target = target}; // 生成得到代理类 public Object getProxy() { return Proxy.newProxyInstance(this.getClass().getClassLoader(), target.getClass().getInterfaces(), this); } // 处理代理实例，并返回结果： public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { log(method.getName()); Object result = method.invoke(target, args); return result; } public void log(String msg) { System.out.println(&quot;执行了&quot; + msg + &quot;方法&quot;); } } 原生 Spring API 接口和自定义类导入依赖： &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.8&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; 切入点（PoingCut）是通知执行的“地点”的定义；通知（Advice）指切面必须要完成的工作，它是类中的一个方法： public interface MethodBeforeAdvice extends BeforeAdvice { void before(Method m, Object[] args, Object target) throws Throwable; } public class CountingBeforeAdvice implements MethodBeforeAdvice { private int count; public void before(Method m, Object[] args, Object target) throws Throwable { ++count; } public int getCount() { return count; } } 切面（Aspect）指横切关注点被模块化的特殊对象，它是一个类： public class ConcurrentOperationExecutor implements Ordered { private static final int DEFAULT_MAX_RETRIES = 2; private int maxRetries = DEFAULT_MAX_RETRIES; private int order = 1; public void setMaxRetries(int maxRetries) { this.maxRetries = maxRetries; } public int getOrder() { return this.order; } public void setOrder(int order) { this.order = order; } public Object doConcurrentOperation(ProceedingJoinPoint pjp) throws Throwable { int numAttempts = 0; PessimisticLockingFailureException lockFailureException; do { numAttempts++; try { return pjp.proceed(); } catch(PessimisticLockingFailureException ex) { lockFailureException = ex; } } while(numAttempts &lt;= this.maxRetries); throw lockFailureException; } } 注解实现AOP： import org.aspectj.lang.annotation.Aspect; import org.aspectj.lang.annotation.Before; @Aspect public class BeforeExample { @Before(&quot;com.xyz.myapp.CommonPointcuts.dataAccessOperation()&quot;) public void doAccessCheck() { // ... } @Around(&quot;com.xyz.myapp.CommonPointcuts.businessService()&quot;) public Object doBasicProfiling(ProceedingJoinPoint pjp) throws Throwable { // start stopwatch Object retVal = pjp.proceed(); // stop stopwatch return retVal; } } resoureces下新建配置文件applicationContext.xml： &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;!-- 方式一：使用原生 Spring API 接口 --&gt; &lt;!-- this is the object that will be proxied by Spring&#39;s AOP infrastructure --&gt; &lt;bean id=&quot;personService&quot; class=&quot;x.y.service.DefaultPersonService&quot;/&gt; &lt;!-- this is the actual advice itself --&gt; &lt;bean id=&quot;beforeAdvice&quot; class=&quot;x.y.CountingBeforeAdvice&quot;/&gt; &lt;aop:config&gt; &lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* x.y.service.DefaultPersonService.*(..))&quot;/&gt; &lt;!-- 增加执行环绕 --&gt; &lt;aop:advisor advice-ref=&quot;beforeAdvice&quot; pointcut-ref=&quot;pointcut&quot;&gt; &lt;/aop:config&gt; &lt;!-- 方式二：自定义类（切面） --&gt; &lt;aop:config&gt; &lt;aop:aspect id=&quot;concurrentOperationRetry&quot; ref=&quot;concurrentOperationExecutor&quot;&gt; &lt;aop:pointcut id=&quot;idempotentOperation&quot; expression=&quot;execution(* com.xyz.myapp.service.*.*(..))&quot;/&gt; &lt;aop:around pointcut-ref=&quot;idempotentOperation&quot; method=&quot;doConcurrentOperation&quot;/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; &lt;bean id=&quot;concurrentOperationExecutor&quot; class=&quot;com.xyz.myapp.service.impl.ConcurrentOperationExecutor&quot;&gt; &lt;property name=&quot;maxRetries&quot; value=&quot;3&quot;/&gt; &lt;property name=&quot;order&quot; value=&quot;100&quot;/&gt; &lt;/bean&gt; &lt;!-- 方式三：注解 --&gt; &lt;bean id=&quot;BeforeExample&quot; class=&quot;x.y.BeforeExample&quot;/&gt; &lt;!-- 开启注解支持 JDK（默认 proxy-target-class=&quot;false&quot;，cglib（proxy-target-class=&quot;true&quot;））--&gt; &lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot;/&gt; &lt;/beans&gt; 整合MybatisMybatis-Spring中文文档 导入依赖： &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.3.20&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.7&lt;/version&gt; &lt;/dependency&gt; 新建applicationContext.xml配置文件： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx https://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt; &lt;!-- 使用Spring-JDBC提供的数据源 --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;!-- 绑定Mybatis配置文件 --&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt; &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath*:sample/config/mappers/**/*.xml&quot; /&gt; &lt;/bean&gt; &lt;!-- 方式一：SqlSessionTemplate --&gt; &lt;!-- SqlSessionTemplate 对应 SqlSession --&gt; &lt;bean id=&quot;sqlSession&quot; class=&quot;org.mybatis.spring.SqlSessionTemplate&quot;&gt; &lt;!-- 只能使用构造器注入sqlSessionFactory，因为它没有set方法 --&gt; &lt;constructor-arg index=&quot;0&quot; ref=&quot;sqlSessionFactory&quot; /&gt; &lt;/bean&gt; &lt;!-- 注入到DAO bean中 --&gt; &lt;bean id=&quot;userDao&quot; class=&quot;org.mybatis.spring.sample.dao.UserDaoImpl&quot;&gt; &lt;property name=&quot;sqlSession&quot; ref=&quot;sqlSession&quot; /&gt; &lt;/bean&gt; &lt;!-- 方式二：SqlSessionDaoSupport --&gt; &lt;bean id=&quot;userDao&quot; class=&quot;org.mybatis.spring.sample.dao.UserDaoImpl&quot;&gt; &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot; /&gt; &lt;/bean&gt; &lt;!-- 方式三：配置 Dao 接口扫描包，动态实现 Dao 接口注入到 Spring 容器中 --&gt; &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;!-- 注入 sqlSessionFactory --&gt; &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;/&gt; &lt;!-- 要扫描的 Dao 包 --&gt; &lt;property name=&quot;basePackage&quot; value=&quot;org.mybatis.spring.sample.dao&quot;/&gt; &lt;/bean&gt; &lt;!-- 配置声明式事务 --&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;constructor-arg ref=&quot;dataSource&quot; /&gt; &lt;/bean&gt; &lt;!-- 配置事务通知 --&gt; &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt; &lt;!-- 给哪些方法配置事务，配置事务的传播特性 --&gt; &lt;tx:attributes&gt; &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!-- 配置事务织入 --&gt; &lt;aop:config&gt; &lt;aop:pointcut id=&quot;txPointCut&quot; expression=&quot;execution(* x.y.service.DefaultPersonService.*(..))&quot;/&gt; &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;txPointCut&quot;&gt; &lt;/aop:config&gt; &lt;/beans&gt; 新建Dao层实现类： // 方式一 public class UserDaoImpl implements UserDao { private SqlSession sqlSession; public void setSqlSession(SqlSession sqlSession) { this.sqlSession = sqlSession; } public User getUser(String userId) { return sqlSession.selectOne(&quot;org.mybatis.spring.sample.mapper.UserMapper.getUser&quot;, userId); } } // 方式二 public class UserDaoImpl extends SqlSessionDaoSupport implements UserDao { public User getUser(String userId) { return getSqlSession().selectOne(&quot;org.mybatis.spring.sample.mapper.UserMapper.getUser&quot;, userId); } } 新建测试类： public class MyTest { @Test public void test() throws IOException { ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); UserMapper userMapper = context.getBean(&quot;userDao&quot;, UserDao.class); System.out.println(userMapper.selectUser(0)); } }","categories":[{"name":"生活","slug":"生活","permalink":"http://goodguyjameswin.github.io/categories/生活/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://goodguyjameswin.github.io/tags/学习笔记/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"http://goodguyjameswin.github.io/categories/生活/"}]},{"title":"栈与队列","slug":"栈与队列","date":"2022-04-30T10:43:49.000Z","updated":"2022-07-18T03:44:24.551Z","comments":false,"path":"2022/04/30/栈与队列/","link":"","permalink":"http://goodguyjameswin.github.io/2022/04/30/栈与队列/","excerpt":"","text":"动态数组底层仍是数组实现，添加和删除元素的时候，为了维护其他元素的相对顺序，需要将一系列元素进行平行复制，当数组元素满了的时候，需要动态扩容，就是申请一块更大的内存空间，然后把原来的数组元素依次赋值到新的内存空间，才能继续添加元素。也可以做动态缩容，不过为了避免造成数组由于添加删除元素的缘故反复扩容缩容，引起复杂度震荡，可以当数组的真正存放数据的区域减少到数组长度的1/4的时候，才缩减数组的容量，缩减到原来的1/2。 /** * 动态数组，参考了 java.util.ArrayList 类的实现 * * @param &lt;E&gt; */ public class ArrayList&lt;E&gt; { private E[] data; private int size; /** * 构造函数，传入数组的初始化容量 capacity 构造动态数组 * * @param capacity */ public ArrayList(int capacity) { data = (E[]) new Object[capacity]; size = 0; } /** * 无参数的构造函数，默认数组的容量 capacity = 10 */ public ArrayList() { this(10); } /** * 获取数组真正的容量 * * @return */ public int getCapacity() { return data.length; } /** * 获取数组中的元素个数 * * @return */ public int size() { return size; } /** * 返回数组是否为空 * * @return */ public boolean isEmpty() { return size == 0; } /** * 在下标 index 位置插入一个新元素 e * * @param index * @param e */ public void add(int index, E e) { if (index &lt; 0 || index &gt; size) { throw new IndexOutOfBoundsException(String.format(&quot;Index %s out of bounds for length %s&quot;, index, size)); } if (size == data.length) { newCapacity(2 * data.length); } // 插入元素的时候，从后向前逐个向后赋值，留出空位 for (int i = size - 1; i &gt;= index; i--) { data[i + 1] = data[i]; } data[index] = e; size++; } /** * 向所有元素后添加一个新元素 * * @param e */ public void add(E e) { add(size, e); } /** * 获取下标 index 位置的元素 * * @param index * @return */ public E get(int index) { if (index &lt; 0 || index &gt;= size) { throw new IndexOutOfBoundsException(String.format(&quot;Index %s out of bounds for length %s&quot;, index, size)); } return data[index]; } /** * 修改下标 index 位置的元素为 e * * @param index * @param e */ public void set(int index, E e) { if (index &lt; 0 || index &gt;= size) { throw new IllegalArgumentException(&quot;Set failed. Index is illegal.&quot;); } data[index] = e; } /** * 查找数组中是否有元素 e * * @param e * @return */ public boolean contains(E e) { for (int i = 0; i &lt; size; i++) { if (data[i].equals(e)) { return true; } } return false; } /** * 查找数组中元素 e 所在的下标，如果不存在元素e，则返回-1 * * @param e * @return */ public int indexOf(E e) { for (int i = 0; i &lt; size; i++) { if (data[i].equals(e)) { return i; } } return -1; } /** * 注意：该方法下有缩容机制 * * @param index 被删除的元素的下标 * @return 删除的元素 */ public E remove(int index) { if (index &lt; 0 || index &gt;= size) { throw new IllegalArgumentException(&quot;Remove failed. Index is illegal.&quot;); } E ret = data[index]; for (int i = index + 1; i &lt; size; i++) { data[i - 1] = data[i]; } size--; data[size] = null; // 防止复杂度震荡机制，当真正存放的元素的个数成为数组长度的 1 / 4 时，才缩容为原来的 1 / 2 if (size == data.length / 4 &amp;&amp; data.length != 1) { newCapacity(data.length / 2); } return ret; } /** * 从数组中删除元素e * * @param e */ public void removeElement(E e) { int index = indexOf(e); if (index != -1) { remove(index); } } @Override public String toString() { StringBuilder res = new StringBuilder(); res.append(String.format(&quot;数组的长度: size = %d , 容量 = %d\\n&quot;, size, data.length)); res.append(&#39;[&#39;); for (int i = 0; i &lt; size; i++) { res.append(data[i]); if (i != size - 1) { res.append(&quot;, &quot;); } } res.append(&#39;]&#39;); return res.toString(); } /** * 将数组空间的容量变成 capacity大小 * * @param capacity */ private void newCapacity(int capacity) { E[] newData = (E[]) new Object[capacity]; if (size &gt;= 0) { System.arraycopy(data, 0, newData, 0, size); } // 原来的数组 data 内存等待垃圾回收机制 data = newData; } } 栈后进先出的数据结构，可以用java.util.ArrayDeque实现，因为它底层是数组实现的，所以建议添加和删除元素都在ArrayDeque的末尾进行；或者使用java.util.LinkedList实现，链表则可以通过虚拟的头结点很方便地在链表的头部和尾部删除元素。 力扣316：给你一个字符串s，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证返回结果的字典序最小（要求不能打乱其他字符的相对位置）。 输入：s = “cbacdcbc” 输出：”acdb” 查看解析 public class Solution { public String removeDuplicateLetters(String s) { int len = s.length(); if (len &lt; 2) { return s; } char[] charArray = s.toCharArray(); // 记录每个字符出现的最后一个位置 int[] lastIndex = new int[26]; for (int i = 0; i &lt; len; i++) { lastIndex[charArray[i] - &#39;a&#39;] = i; } Deque&lt;Character&gt; stack = new ArrayDeque&lt;&gt;(len); stack.addLast(&#39;a&#39;); // 在栈里放一个永远不会被弹出的元素（哨兵），可以省去栈非空的判断， // 栈中有的字符记录在这里 boolean[] visited = new boolean[26]; for (int i = 0; i &lt; len; i++) { char currentChar = charArray[i]; // 如果栈中已经存在，就跳过 if (visited[currentChar - &#39;a&#39;]) { continue; } // 在 ① 栈非空，② 当前元素字典序 &lt; 栈顶元素，并且 ③ 栈顶元素在以后还会出现，弹出栈顶元素 while (currentChar &lt; stack.peekLast() &amp;&amp; lastIndex[stack.peekLast() - &#39;a&#39;] &gt; i) { char top = stack.removeLast(); visited[top - &#39;a&#39;] = false; } stack.addLast(currentChar); visited[currentChar - &#39;a&#39;] = true; } StringBuilder stringBuilder = new StringBuilder(); // 注意：弹出 size - 1 个元素，无需把哨兵元素弹出 int size = stack.size(); for (int i = 0; i &lt; size - 1; i++) { stringBuilder.insert(0, stack.removeLast()); } return stringBuilder.toString(); } } 单调栈单调栈就是普通的栈，只是在解决一些特定问题的过程中，栈中的元素在数值上恰好保持单调性。 经典问题，力扣42：接雨水 单调栈解法如下： public class Solution { public int trap(int[] height) { int len = height.length; if (len &lt; 3) { // 特判 return 0; } int area = 0; Deque&lt;Integer&gt; stack = new ArrayDeque&lt;&gt;(len); for (int i = 0; i &lt; len; i++) { while (!stack.isEmpty() &amp;&amp; height[stack.peekLast()] &lt; height[i]) { // 作为底部支撑的那个柱形的下标 Integer bottomIndex = stack.removeLast(); // 出栈以后，如果栈为空，说明不能形成凹槽，此时跳过即可 if (stack.isEmpty()) { break; } int width = i - stack.peekLast() - 1; // 根据木桶原理，高度取决于，i 的高度和弹栈以后的新栈顶元素的高度 int currentHeight = Math.min(height[stack.peekLast()], height[i]) - height[bottomIndex]; area += (width * currentHeight); } // 栈中存下标 stack.addLast(i); } return area; } } 力扣84：给定n个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为1。求在该柱状图中，能够勾勒出来的矩形的最大面积。 输入：heights = [2,1,5,6,2,3] 输出：10 解释：最大的矩形为图中红色区域，面积为 10 查看解析 class Solution { public int largestRectangleArea(int[] heights) { int n = heights.length; int[] left = new int[n]; int[] right = new int[n]; // 在遍历结束后，栈中仍然有一些位置，这些位置对应的右边界就是位置为 n 的「哨兵」。我们可以将它们依次出栈并更新右边界，也可以在初始化右边界数组时就将所有的元素的值置为 n Arrays.fill(right, n); Deque&lt;Integer&gt; mono_stack = new ArrayDeque&lt;Integer&gt;(); for (int i = 0; i &lt; n; ++i) { while (!mono_stack.isEmpty() &amp;&amp; heights[mono_stack.peek()] &gt;= heights[i]) { // 确实无法求出正确的右边界，但对最终的答案没有任何影响。这是因为在答案对应的矩形中，如果有若干个柱子的高度都等于矩形的高度，那么最右侧的那根柱子是可以求出正确的右边界的（因此最终的答案还是可以从最右侧的与矩形高度相同的柱子求得的） right[mono_stack.peek()] = i; mono_stack.pop(); } left[i] = (mono_stack.isEmpty() ? -1 : mono_stack.peek()); // 左边界可以正确求出，-1 表示左边界的「哨兵」 mono_stack.push(i); } int ans = 0; for (int i = 0; i &lt; n; ++i) { ans = Math.max(ans, (right[i] - left[i] - 1) * heights[i]); } return ans; } } 队列先进先出的数据结构，可以用数组或链表实现，例如java.util.concurrent.ArrayBlockingQueue就是由数组支持的有界队列，由于数组扩容有性能消耗，因此它不支持扩容，当队列满的时候，它的处理策略是阻塞。一些场合，我们希望在队列的两端都可以进行出队和入队的操作，这种更灵活的数据结构称为双端队列。 经典问题，用栈实现队列：设计用两个栈实现，一个栈用于元素进栈，一个栈用于元素出栈。为保证出队顺序，一定要在元素出栈的栈为空时，才从用于元素进栈的栈中将所有元素倒入用于元素出栈的栈 public class MyQueue { private Deque&lt;Integer&gt; pushStack; private Deque&lt;Integer&gt; popStack; /** * Initialize your data structure here. */ public MyQueue() { pushStack = new ArrayDeque&lt;&gt;(); popStack = new ArrayDeque&lt;&gt;(); } /** * Push element x to the back of queue. */ public void push(int x) { // 在任何时候都可以向 pushStack 推入元素 pushStack.addLast(x); } /** * Removes the element from in front of queue and returns that element. */ public int pop() { // 从 popStack 取出元素 if (!popStack.isEmpty()) { return popStack.removeLast(); } // 走到这里是因为 popStack 为空，此时需要将 pushStack 里的所有元素依次放入 popStack while (!pushStack.isEmpty()) { popStack.addLast(pushStack.removeLast()); } return popStack.removeLast(); } /** * Get the front element. */ public int peek() { // 从 popStack 取出元素 if (!popStack.isEmpty()) { return popStack.peekLast(); } // 走到这里是因为 popStack 为空，此时需要将 pushStack 里的所有元素依次放入 popStack while (!pushStack.isEmpty()) { popStack.addLast(pushStack.removeLast()); } return popStack.peekLast(); } /** * Returns whether the queue is empty. */ public boolean empty() { // 两个栈都为空，才说明队列为空 return pushStack.isEmpty() &amp;&amp; popStack.isEmpty(); } } /** * Your MyQueue object will be instantiated and called as such: * MyQueue obj = new MyQueue(); * obj.push(x); * int param_2 = obj.pop(); * int param_3 = obj.peek(); * boolean param_4 = obj.empty(); */ 经典问题，用队列实现栈：思路是在peek()和pop()的时候，依次将队首出队到队尾： public class MyStack { private Queue&lt;Integer&gt; queue; /** * Initialize your data structure here. */ public MyStack() { queue = new LinkedList&lt;&gt;(); } /** * Push element x onto stack. */ public void push(int x) { queue.add(x); } /** * Removes the element on top of the stack and returns that element. */ public int pop() { int size = queue.size(); for (int i = 0; i &lt; size - 1; i++) { queue.add(queue.poll()); } return queue.poll(); // 获取队尾元素（新队首），满足后进先出 } /** * Get the top element. */ public int top() { int size = queue.size(); for (int i = 0; i &lt; size - 1; i++) { queue.add(queue.poll()); } int res = queue.poll(); queue.add(res); // 为保证下次元素入队顺序的正确性，得到队尾元素之后，要继续将队首元素（旧队尾）移动到队尾 return res; } /** * Returns whether the stack is empty. */ public boolean empty() { return queue.isEmpty(); } } /** * Your MyStack object will be instantiated and called as such: * MyStack obj = new MyStack(); * obj.push(x); * int param_2 = obj.pop(); * int param_3 = obj.top(); * boolean param_4 = obj.empty(); */ 思考题：如何设计一个能在常数时间内检索到最小元素的栈？ 查看解析 class MinStack { Deque&lt;Integer&gt; xStack; Deque&lt;Integer&gt; minStack; // 辅助栈 public MinStack() { xStack = new LinkedList&lt;Integer&gt;(); minStack = new LinkedList&lt;Integer&gt;(); minStack.push(Integer.MAX_VALUE); } public void push(int x) { xStack.push(x); minStack.push(Math.min(minStack.peek(), x)); // 每个入栈的元素都有一个对应当时栈（状态）中的一个最小值 } public void pop() { xStack.pop(); minStack.pop(); // 辅助栈的栈顶元素也一并弹出 } public int top() { return xStack.peek(); } public int getMin() { return minStack.peek(); // 当前栈内元素的最小值总是辅助栈的栈顶元素 } } 经典问题，设计循环队列：依旧是队列的数据结构，但是队尾被连接在队首之后以形成一个环，特点是可以利用这个队列之前用过的空间。 public class MyCircularQueue { private int[] arr; private int capacity; /** * front 指向当前队列中最早入队的元素 */ private int front; /** * rear 指向下一个添加到队尾的元素 */ private int rear; /** * Initialize your data structure here. Set the size of the queue to be k. */ public MyCircularQueue(int k) { // 始终保持 1 个位置不存有效元素，是为了避免判断队列为空和队列为满的条件冲突 capacity = k + 1; arr = new int[capacity]; front = 0; rear = 0; } /** * Insert an element into the circular queue. Return true if the operation is successful. */ public boolean enQueue(int value) { // 队尾为满不可以入队 if (isFull()) { return false; } arr[rear] = value; rear = (rear + 1) % capacity; return true; } /** * Delete an element from the circular queue. Return true if the operation is successful. */ public boolean deQueue() { // 队尾为空不可以出队 if (isEmpty()) { return false; } front = (front + 1) % capacity; return true; } /** * Get the front item from the queue. */ public int Front() { // 队列非空才可以取出队头 if (isEmpty()) { return -1; } return arr[front]; } /** * Get the last item from the queue. */ public int Rear() { // 队列非空才可以取出队尾 if (isEmpty()) { return -1; } // 有数组下标的计算一定要考虑是否越界 return arr[(rear - 1 + capacity) % capacity]; } /** * Checks whether the circular queue is empty or not. */ public boolean isEmpty() { return front == rear; } /** * Checks whether the circular queue is full or not. */ public boolean isFull() { // 有数组下标的计算一定要考虑是否越界 return (rear + 1) % capacity == front; } } 若设计循环双端队列，则需要添加两个方法： /** * Adds an item at the front of Deque. Return true if the operation is successful. */ public boolean insertFront(int value) { if (isFull()) { return false; } front = (front - 1 + capacity) % capacity; // 由于 front 指向第一个队首元素，因此需要先将 front 左移一个单位，然后再赋值，要避免数组下标越界和处理循环 arr[front] = value; return true; } /** * Deletes an item from the rear of Deque. Return true if the operation is successful. */ public boolean deleteLast() { if (isEmpty()) { return false; } rear = (rear - 1 + capacity) % capacity; // 由于 rear 指向 队尾元素的下一个元素，因此需要将 rear 左移一个单位即可，同样要避免数组下标越界和处理循环 return true; } 单调队列同样只是普通的队列，只不过在使用队列的过程中，根据问题的特点保持了队列的单调性。 力扣239：给定一个数组nums，有一个大小为k的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的k个数字。滑动窗口每次只向右移动一位。返回滑动窗口中的最大值。 输入：nums = [1,3,-1,-3,5,3,6,7], k = 3 输出：[3,3,5,5,6,7] 解释： 滑动窗口的位置 最大值 ============= [1 3 -1] -3 5 3 6 7 (3) 1 [3 -1 -3] 5 3 6 7 (3) 1 3 [-1 -3 5] 3 6 7 (5) 1 3 -1 [-3 5 3] 6 7 (5) 1 3 -1 -3 [5 3 6] 7 (6) 1 3 -1 -3 5 [3 6 7] (7) 查看解析 分析题意，需要使用双端队列来实现，整个队列的数值（不是下标）呈现的特征是单调不减的，因此是一个单调队列： 删除队首信息：当滑窗离开左边界的时候，当前最大值需要被删除，这一步需要准确知道队首的下标，因此队列中存的是下标 查看队首信息：队首元素一定是当前滑动窗口的最大值 队尾添加：如果一个数有可能是将来的滑动窗口的最大值，就把它添加到队尾 队尾删除：如果新来的数比当前队尾的数还要大，当前队尾元素一定不可能是滑动窗口的最大值，需要把当前队尾删除，这个过程是循环进行的 public class Solution { public int[] maxSlidingWindow(int[] nums, int k) { int len = nums.length; int[] res = new int[len - k + 1]; // 注意结果集长度 Deque&lt;Integer&gt; deque = new ArrayDeque&lt;&gt;(k); // 双端队列实现的滑动窗口 for (int i = 0; i &lt; len; i++) { // 判断队首元素是否移出滑动窗口 if (i &gt;= k &amp;&amp; deque.peekFirst() == i - k) { deque.removeFirst(); } // 依次判断待添加元素是否比队首元素大，注意可以取等号 while (!deque.isEmpty() &amp;&amp; nums[deque.peekLast()] &lt;= nums[i]) { deque.removeLast(); } // 加入队列的是下标 deque.addLast(i); if (i &gt;= k - 1) { res[i - k + 1] = nums[deque.peekFirst()]; // 队首元素总是对内最大值 } } return res; } } .center { width: auto; display: table; margin-left: auto; margin-right: auto; }","categories":[{"name":"生活","slug":"生活","permalink":"http://goodguyjameswin.github.io/categories/生活/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://goodguyjameswin.github.io/tags/学习笔记/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"http://goodguyjameswin.github.io/categories/生活/"}]},{"title":"链表","slug":"链表","date":"2022-04-28T10:43:57.000Z","updated":"2022-07-18T03:56:58.847Z","comments":false,"path":"2022/04/28/链表/","link":"","permalink":"http://goodguyjameswin.github.io/2022/04/28/链表/","excerpt":"","text":"解决链表中的指针指向问题力扣25：给你链表的头节点head，每k个节点一组进行翻转，请你返回修改后的链表。k是一个正整数，它的值小于或等于链表的长度。如果节点总数不是k的整数倍，那么请将最后剩余的节点保持原有顺序。 你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。 输入：head = [1,2,3,4,5], k = 2 输出：[2,1,4,3,5] 查看解析 class Solution { public ListNode reverseKGroup(ListNode head, int k) { ListNode hair = new ListNode(0); hair.next = head; ListNode pre = hair; while (head != null) { ListNode tail = pre; // 查看剩余部分长度是否大于等于 k for (int i = 0; i &lt; k; ++i) { tail = tail.next; if (tail == null) { return hair.next; } } ListNode nex = tail.next; ListNode[] reverse = myReverse(head, tail); head = reverse[0]; tail = reverse[1]; // 把子链表重新接回原链表 pre.next = head; tail.next = nex; pre = tail; head = tail.next; } return hair.next; } public ListNode[] myReverse(ListNode head, ListNode tail) { ListNode prev = tail.next; ListNode p = head; while (prev != tail) { ListNode nex = p.next; p.next = prev; prev = p; p = nex; } return new ListNode[]{tail, head}; } } 力扣234：给你一个单链表的头节点head，请你判断该链表是否为回文链表。如果是，返回true；否则，返回false。你必须以O(n)时间复杂度和O(1)空间复杂度解决此题。 输入：head = [1,2,2,1] 输出：true 查看解析 // 快指针走到末尾，慢指针刚好到中间。其中慢指针将前半部分反转，然后比较。 public boolean isPalindrome(ListNode head) { if(head == null || head.next == null) { return true; } ListNode slow = head, fast = head; ListNode pre = head, prepre = null; while(fast != null &amp;&amp; fast.next != null) { pre = slow; slow = slow.next; fast = fast.next.next; pre.next = prepre; prepre = pre; } if(fast != null) { slow = slow.next; } while(pre != null &amp;&amp; slow != null) { if(pre.val != slow.val) { return false; } pre = pre.next; slow = slow.next; } return true; } 虚拟头结点力扣23：给你一个链表数组，每个链表都已经按升序排列。请你将所有链表合并到一个升序链表中，返回合并后的链表。 输入：lists = [[1,4,5],[1,3,4],[2,6]] 输出：[1,1,2,3,4,4,5,6] 查看解析 方法一：分治合并 class Solution { public ListNode mergeKLists(ListNode[] lists) { return merge(lists, 0, lists.length - 1); } public ListNode merge(ListNode[] lists, int l, int r) { if (l == r) { return lists[l]; } if (l &gt; r) { return null; } int mid = (l + r) &gt;&gt; 1; return mergeTwoLists(merge(lists, l, mid), merge(lists, mid + 1, r)); } public ListNode mergeTwoLists(ListNode a, ListNode b) { if (a == null || b == null) { return a != null ? a : b; } ListNode head = new ListNode(0); ListNode tail = head, aPtr = a, bPtr = b; while (aPtr != null &amp;&amp; bPtr != null) { if (aPtr.val &lt; bPtr.val) { tail.next = aPtr; aPtr = aPtr.next; } else { tail.next = bPtr; bPtr = bPtr.next; } tail = tail.next; } tail.next = (aPtr != null ? aPtr : bPtr); return head.next; } } 方法二：优先队列 class Solution { PriorityQueue&lt;ListNode&gt; queue = new PriorityQueue&lt;ListNode&gt;((l1, l2) -&gt; l1.val - l2.val); public ListNode mergeKLists(ListNode[] lists) { for (ListNode node: lists) { if (node != null) { queue.offer(node); } } ListNode head = new ListNode(0); ListNode tail = head; while (!queue.isEmpty()) { ListNode node = queue.poll(); tail.next = node; tail = tail.next; if (node.next != null) { queue.offer(node.next); } } return head.next; } } 力扣86：给你一个链表的头节点head和一个特定值x，请你对链表进行分隔，使得所有小于x的节点都出现在大于或等于x的节点之前。你应当保留两个分区中每个结点的初始相对位置。 输入：head = [1,4,3,2,5,2], x = 3 输出：[1,2,2,4,3,5] 查看解析 class Solution { public ListNode partition(ListNode head, int x) { ListNode small = new ListNode(0); ListNode smallHead = small; ListNode large = new ListNode(0); ListNode largeHead = large; while (head != null) { if (head.val &lt; x) { small.next = head; small = small.next; } else { large.next = head; large = large.next; } head = head.next; } large.next = null; small.next = largeHead.next; return smallHead.next; } } 快慢指针指在链表遍历的过程中，使用两个指针变量同向移动的一种解决问题的技巧，需要注意一下快指针可以前进的条件： 如果快指针以及快指针的下一个结点非空，来到的是中间结点的前一个结点 如果快指针的下一个结点以及快指针的下一个结点的下一个结点非空，来到的是中间结点的后一个结点 环形链表经典问题：编写一个程序，检测一个单链表是否有环。 通常可以用快慢指针的思路，只要进入环，可以认为是快指针在追赶慢指针，它们相遇，肯定是由于快指针从慢指针的后面赶超了慢指针 public class Solution { public boolean hasCycle(ListNode head) { // 特判 if (head == null || head.next == null) { return false; } ListNode slow = head; ListNode fast = head; // 慢指针一次走一步、快指针一次走两步 // 注意：快指针可以走的条件 fast != null &amp;&amp; fast.next != null while (fast != null &amp;&amp; fast.next != null) { slow = slow.next; fast = fast.next.next; if (slow == fast) { return true; } } return false; } } 力扣287：给定一个包含n + 1个整数的数组nums，其数字都在[1, n]范围内（包括1和n），可知至少存在一个重复的整数。假设nums只有一个重复的整数，返回这个重复的数。 输入：nums = [1,3,4,2,2] 输出：2 查看解析 对nums数组建图，每个位置i连一条i-&gt;nums[i]的边。由于存在的重复的数字target，因此target这个位置一定有起码两条指向它的边，因此整张图一定存在环，且我们要找到的target就是这个环的入口。 先设置慢指针slow和快指针fast，慢指针每次走一步，快指针每次走两步，两个指针在有环的情况下一定会相遇。 假设环长为L，从起点到环的入口的步数是a，从环的入口继续走b步到达相遇位置，从相遇位置继续走c步回到环的入口，则有b+c=L，其中L,a,b,c都是正整数。根据上述定义，慢指针走了a+b步，快指针走了2(a+b)步。从另一角度考虑，在相遇位置，快指针比慢指针多走了若干圈，因此快指针走的步数还可以表示成a+b+kL，其中k表示快指针在环上走的圈数。联立等式，可以得到：2(a+b)=a+b+kL，解得a=kL-b，整理可得：a=(k-1)L+(L-b)=(k-1)L+c。 从上述等式可知，如果慢指针从起点出发，快指针从相遇位置出发，每次两个指针都移动一步，则慢指针走了a步之后到达环的入口，快指针在环里走了k-1圈之后又走了c步，由于从相遇位置继续走c步即可回到环的入口，因此快指针也到达环的入口。两个指针在环的入口相遇，相遇点就是答案。 // 看成是链表，数组下标i是当前节点，nums[i] 是下一个节点，如果成环,按照这种方式遍历链表会无限循环 class Solution { // 当存在多个重复值，也就是多个环时，只会在最小环中无限循环，也就是重复元素第2次出现的位置形成的环，不会走到后面更大的环 public int findDuplicate(int[] nums) { // 因此可以用环形链表的解法来找出环的入口 int slow = 0, fast = 0; do { slow = nums[slow]; fast = nums[nums[fast]]; } while (slow != fast); slow = 0; while (slow != fast) { slow = nums[slow]; fast = nums[fast]; } return slow; } } 相交链表经典问题：编写一个程序，找到两个单链表相交的起始节点。 方法一：考虑截断长的链表中多的部分，分别使用两个变量指向两个链表的第一个结点，让长的链表先走一些步数，这个步数就是长短链表的长度差，然后再让这两个变量齐头并进，在遍历的过程中只要检测到这两个变量指向同一个结点，这个结点就是两个链表的第一个公共结点。 public class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { // 特判 if (headA == null || headB == null) { return null; } int aLen = getLenOfListNode(headA); int bLen = getLenOfListNode(headB); // 总是让 A 链表是短链表 if (aLen &gt; bLen) { ListNode temp = headA; headA = headB; headB = temp; } // 注意：这里要取绝对值 int distance = Math.abs(aLen - bLen); for (int i = 0; i &lt; distance; i++) { headB = headB.next; } while (headA != headB) { headA = headA.next; headB = headB.next; } return headA; } private int getLenOfListNode(ListNode head) { int len = 0; while (head != null) { head = head.next; len++; } return len; } } 方法二：想办法让两个链表等长，具体方法是让链表A在遍历完成以后转向链表B，同时让链表B在遍历完成以后转向链表A。如果两个链表有公共结点，它们第一次相遇的时候返回的结点一定是两个链表的公共结点。 public class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { // 特判 if (headA == null || headB == null) { return null; } ListNode head1 = headA; ListNode head2 = headB; while (head1 != head2) { if (head1 != null) { head1 = head1.next; } else { head1 = headB; } if (head2 != null) { head2 = head2.next; } else { head2 = headA; } } return head1; } } .center { width: auto; display: table; margin-left: auto; margin-right: auto; }","categories":[{"name":"生活","slug":"生活","permalink":"http://goodguyjameswin.github.io/categories/生活/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://goodguyjameswin.github.io/tags/学习笔记/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"http://goodguyjameswin.github.io/categories/生活/"}]},{"title":"data-augtools","slug":"data-augtools","date":"2022-04-25T07:14:03.000Z","updated":"2022-07-18T03:41:51.957Z","comments":false,"path":"2022/04/25/data-augtools/","link":"","permalink":"http://goodguyjameswin.github.io/2022/04/25/data-augtools/","excerpt":"","text":"简介在原项目的基础上，添加了针对标注工具labelimg2的数据增强 在labelme的数据增强部分添加了旋转和裁剪处理，并做了标签增强 修改后","categories":[{"name":"技术","slug":"技术","permalink":"http://goodguyjameswin.github.io/categories/技术/"}],"tags":[{"name":"开源项目","slug":"开源项目","permalink":"http://goodguyjameswin.github.io/tags/开源项目/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://goodguyjameswin.github.io/categories/技术/"}]},{"title":"排序","slug":"排序","date":"2022-04-23T10:42:11.000Z","updated":"2022-07-18T03:56:42.730Z","comments":false,"path":"2022/04/23/排序/","link":"","permalink":"http://goodguyjameswin.github.io/2022/04/23/排序/","excerpt":"","text":"选择排序选择排序每一轮都选取未排定部分的最小元素，然后将它交换到未排定部分的第一个位置。 public class Solution { public int[] selectSort(int[] nums) { int len = nums.length; // 最后一轮只有一个元素，一定是最大的元素，因此写 i &lt; len - 1 for (int i = 0; i &lt; len - 1; i++) { // 在 [i + 1, len - 1] 区间里选择最小的元素的下标 int minIndex = i; for (int j = i + 1; j &lt; len; j++) { if (nums[j] &lt; nums[minIndex]) { minIndex = j; } } swap(nums, minIndex, i); } return nums; } private void swap(int[] nums, int index1, int index2) { int temp = nums[index1]; nums[index1] = nums[index2]; nums[index2] = temp; } } 选择排序的每一轮循环没有为下一次循环记录更多的信息。堆可以帮助我们在每次未排定的部分里快速地选择出当前最小的元素。因此堆排序是选择排序的优化排序算法。 冒泡排序冒泡排序的内循环使用相邻双指针j, j+1从左至右遍历，依次比较相邻元素大小，若左元素大于右元素则将它们交换，遍历完成时，最大元素会被交换至数组最右边；外循环不断重复内循环，每轮将当前最大元素交换至剩余未排序数组最右边，直至所有元素都被交换至正确位置时结束。 public class Solution { public int[] bubbleSort(int[] nums) { int N = nums.length; for (int i = 0; i &lt; N - 1; i++) { // 外循环 for (int j = 0; j &lt; N - i - 1; j++) { // 内循环 if (nums[j] &gt; nums[j + 1]) { // 交换 nums[j], nums[j + 1] swap(nums, j, j + 1); } } } } private void swap(int[] nums, int index1, int index2) { int temp = nums[index1]; nums[index1] = nums[index2]; nums[index2] = temp; } } 插入排序插入排序将一个元素插入到一个有序数组中，使之成为更长的有序数组。插入排序内层循环可以提前终止，如果待排序的数组是 接近有序 的数组（即数组中的元素离它最终排定以后的位置很近）和元素个数较少的数组，插入排序就可以很快完成。 public class Solution { public int[] sortArray(int[] nums) { int len = nums.length; // 循环不变量：将 nums[i] 插入到区间 [0, i) 使之有序 for (int i = 1; i &lt; len; i++) { // 先暂存这个元素，然后之前数值严格小于 temp 的所有元素逐个后移 int temp = nums[i]; int j = i; // 注意边界 j &gt; 0 while (j &gt; 0 &amp;&amp; nums[j - 1] &gt; temp) { nums[j] = nums[j - 1]; j--; } // 最后这一步容易忽略 nums[j] = temp; } return nums; } } 在内层循环里都有j &gt; 0这个判断条件，有一种插入排序的写法，先找到整个数组中最小的那个元素，把它交换到数组的第一个位置（下标为0），后面的逻辑就可以去掉j &gt; 0。这样的技巧有一个很形象的名字，叫哨兵，即放置一个元素，通常是边界位置，它能帮助我们回避边界条件，从而减少分类讨论。 希尔排序希尔排序使用的是缩小增量（或者称有间隔的）的插入排序方法，以增量为步长划分子序列（与子数组不同，子序列不要求在原始序列中是连续的，但要保证数组中的元素位置相对顺序不变，子序列的长度可以为1），即属于同一子序列的元素，下标的步长等于增量。对每一个子序列应用插入排序，不断缩小增量，当增量为1时所有的数组元素都在一个子序列中，执行一次插入排序，数组最终有序。 public class Solution { // 希尔排序，使用 Shell 建议的序列 N/2,N/4,...,2,1 public int[] sortArray(int[] nums) { int len = nums.length; int h = 1; int gap = len / 2; while (gap &gt;= 1) { // 缩小增量的插入排序 for (int i = h; i &lt; len; i++) { insertionForDelta(nums, gap, i); } gap /= 2; } return nums; } /** * 将 nums[end] 插入到对应分组的正确位置上，其实就是将原来 1 的部分改成 gap * * @param nums * @param gap 间隔 * @param end */ private void insertionForDelta(int[] nums, int gap, int end) { int temp = nums[end]; int j = end; while (j &gt;= gap &amp;&amp; nums[j - gap] &gt; temp) { nums[j] = nums[j - gap]; j -= gap; } nums[j] = temp; } } 归并排序将两个或两个以上的有序序列合并成一个新的有序序列，数组的归并需要使用额外的空间。 public class Solution { // 列表大小等于或小于该大小，将优先于 mergesort 使用插入排序 private static final int INSERTION_SORT_THRESHOLD = 47; public int[] sortArray(int[] nums) { int len = nums.length; 优化3：全局使用一份临时数组 int[] temp = new int[len]; mergeSort(nums, 0, len - 1, temp); return nums; } // 对数组 nums 的子区间 [left, right] 进行归并排序，左右边界都可以取到 private void mergeSort(int[] nums, int left, int right, int[] temp) { if (left == right) { return; } // 优化1：小区间使用插入排序 if (right - left &lt;= INSERTION_SORT_THRESHOLD) { insertionSort(nums, left, right); return; } int mid = left + (right - left) / 2; mergeSort(nums, left, mid); mergeSort(nums, mid + 1, right); // 优化2：数组已经有序的情况下，不再合并 if (nums[mid] &lt;= nums[mid + 1]) { return; } mergeOfTwoSortedArray(nums, left, mid, right); } // 合并两个有序数组：先把值复制到临时数组，再合并回去，[left, mid] 有序，[mid + 1, right] 有序 private void mergeOfTwoSortedArray(int[] nums, int left, int mid, int right, int[] temp) { for (int i = left; i&lt;= right; ++i) { temp[i] = nums[i]; } // i 和 j 分别指向前有序数组和后有序数组的起始位置 int i = left; int j = mid + 1; for (int k = left; k &lt;= right; ++k) { // 先写 i 和 j 越界的情况 if (i == mid + 1) { nums[k] = temp[j]; j++; } else if (j == right + 1) { nums[k] = temp[i]; i++; } else if (temp[i] &lt;= temp[j]) { // 这里是 &lt;= ，否则归并排序就变成了非稳定的排序 nums[k] = temp[i]; i++; } else { nums[k] = temp[j]; j++; } } } // 对数组给定的部分使用插入排序，左右边界都能取到 private void insertionSort(int[] arr, int left, int right) { for (int i = left + 1; i &lt;= right; ++i) { int temp = arr[i]; int j = i; while (j &gt; left &amp;&amp; arr[j - 1] &gt; temp) { arr[j] = arr[j - 1]; j--; } arr[j] = temp; } } } 力扣315：给你一个整数数组nums，按要求返回一个新数组counts。数组counts有该性质：counts[i]的值是nums[i]右侧小于nums[i]的元素的数量。 输入：nums = [5,2,6,1] 输出：[2,1,1,0] 解释： 5 的右侧有 2 个更小的元素（2 和 1） 2 的右侧仅有 1 个更小的元素（1） 6 的右侧有 1 个更小的元素（1） 1 的右侧有 0 个更小的元素 查看解析 public class Solution { public List&lt;Integer&gt; countSmaller(int[] nums) { List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); int len = nums.length; if (len == 0) { return result; } int[] temp = new int[len]; int[] res = new int[len]; // 索引数组，作用：归并回去的时候，方便知道是哪个下标的元素 int[] indexes = new int[len]; for (int i = 0; i &lt; len; i++) { indexes[i] = i; } mergeAndCountSmaller(nums, 0, len - 1, indexes, temp, res); // 把 int[] 转换成为 List&lt;Integer&gt;，没有业务逻辑 for (int i = 0; i &lt; len; i++) { result.add(res[i]); } return result; } /** * 针对数组 nums 指定的区间 [left, right] 进行归并排序，在排序的过程中完成统计任务 * * @param nums * @param left * @param right */ private void mergeAndCountSmaller(int[] nums, int left, int right, int[] indexes, int[] temp, int[] res) { if (left == right) { return; } int mid = left + (right - left) / 2; mergeAndCountSmaller(nums, left, mid, indexes, temp, res); mergeAndCountSmaller(nums, mid + 1, right, indexes, temp, res); // 归并排序的优化，如果索引数组有序，则不存在逆序关系，没有必要合并 if (nums[indexes[mid]] &lt;= nums[indexes[mid + 1]]) { return; } mergeOfTwoSortedArrAndCountSmaller(nums, left, mid, right, indexes, temp, res); } /** * [left, mid] 是排好序的，[mid + 1, right] 是排好序的 * * @param nums * @param left * @param mid * @param right * @param indexes * @param temp * @param res */ private void mergeOfTwoSortedArrAndCountSmaller(int[] nums, int left, int mid, int right, int[] indexes, int[] temp, int[] res) { for (int i = left; i &lt;= right; i++) { temp[i] = indexes[i]; } int i = left; int j = mid + 1; for (int k = left; k &lt;= right; k++) { if (i &gt; mid) { indexes[k] = temp[j]; j++; } else if (j &gt; right) { indexes[k] = temp[i]; i++; res[indexes[k]] += (right - mid); } else if (nums[temp[i]] &lt;= nums[temp[j]]) { // 注意：这里是 &lt;= ，保证稳定性 indexes[k] = temp[i]; i++; res[indexes[k]] += (j - mid - 1); } else { indexes[k] = temp[j]; j++; } } } } 快速排序最重要的思想是划分（partition），partition先选取一个元素作为基准元素（随机选择），一次划分将数组分为两个部分，跳过大于等于基准元素的元素，继续遍历，遇到小的元素，就把它们依次交换到数组的前面去。 public class Solution { private static final Random RANDOM = new Random(); public int[] sortArray(int[] nums) { int len = nums.length; quickSort(nums, 0, len - 1); return nums; } private void quickSort(int[] nums, int left, int right) { // 与归并排序不同，这里包括 &gt; 的情况 if (left &gt;= right) { return; } int p = partition(nums, left, right); quickSort(nums, left, p - 1); quickSort(nums, p + 1, right); } private int partition(int[] nums, int left, int right) { // 随机选择一个元素作为切分元素 int randomIndex = left + RANDOM.nextInt(right - left + 1); swap(nums, randomIndex, left); int pivot = nums[left]; // 循环不变量：lt 意即 less than // [left + 1, lt] &lt; pivot // [lt + 1, i) &gt;= pivot int lt = left; for (int i = left + 1; i &lt;= right; ++i) { if (nums[i] &lt; pivot) { ++lt; swap(nums, lt, i); } } // 最后要记得交换到起始位置 swap(nums, left, lt); return lt; } private void swap(int[] nums, int index1, int index2) { int temp = nums[index1]; nums[index1] = nums[index2]; nums[index2] = temp; } } 力扣80：给你一个有序数组nums。请你原地删除重复出现的元素，使得出现次数超过两次的元素只出现k次，返回删除后数组的新长度。不能使用额外的数组空间，你必须原地修改输入数组并仅使用O(1)的额外空间。 输入：nums = [1,1,1,2,2,3]，k = 2 输出：5, nums = [1,1,2,2,3] 解释：函数应返回新长度 length = 5，并且原数组的前五个元素被修改为 1, 1, 2, 2, 3。不需要考虑数组中超出新长度的后面的元素。 查看解析 class Solution { public int removeDuplicates(int[] nums, int k) { int n = nums.length; if (n &lt;= k) { return n; } int slow = k, fast = k; while (fast &lt; n) { if (nums[slow - k] != nums[fast]) { nums[slow] = nums[fast]; ++slow; } ++fast; } return slow; } } 指针对撞的快速排序：当输入数组中有大量重复元素的数据时，需要把和pivot相等的元素平均分到数组的两边，使得递归树平衡。 public class Solution { private static final Random RANDOM = new Random(); public int[] sortArray(int[] nums) { int len = nums.length; quickSort(nums, 0, len - 1); return nums; } private void quickSort(int[] nums, int left, int right) { // 注意：这里包括 &gt; 的情况，与归并排序不同，请通过调试理解这件事情 if (left &gt;= right) { return; } int p = partition(nums, left, right); quickSort(nums, left, p - 1); quickSort(nums, p + 1, right); } /** * 目标：与切分元素相等的元素均匀地分布在切分元素最终所在位置的两侧 * 这个定义非常重要，直接影响我们的算法初始值定义 * [left + 1, i) 全部小于标定点 * (j, right] 全部大于标定点 * 在指针对撞的过程中，和标定点相同的元素就被挤到了中间 * * @param nums * @param left * @param right * @return */ public int partition(int[] nums, int left, int right) { int randomIndex = left + RANDOM.nextInt(right - left + 1); swap(nums, randomIndex, left); // 循环不变量，le = less equals，ge = greater equals // all in [left + 1, le) &lt;= pivot // all in (ge, right] &gt;= pivot // le &gt; ge 的时候终止 int pivot = nums[left]; int le = left + 1; int ge = right; while (true) { // 注意：这里一定是 nums[le] &lt; pivot，等于 pivot 的元素是被交换过来得到的 while (le &lt;= ge &amp;&amp; nums[le] &lt; pivot) { le++; } // 此时 le 来到第 1 个大于等于 pivot 的位置 while (le &lt;= ge &amp;&amp; nums[ge] &gt; pivot) { ge--; } // 此时 ge 来到第 1 个小于等于 pivot 的位置 if (le &gt; ge) { break; } swap(nums, le, ge); le++; ge--; } // 循环退出后，ge 来到 le 的左边，根据循环不变量，它所指向的元素一定是小于等于 pivot 的，因此交换 left 与 ge 位置上的元素，这时排定的元素 ge 对应的元素，应该把 ge 返回回去 swap(nums, left, ge); return ge; } private void swap(int[] nums, int index1, int index2) { int temp = nums[index1]; nums[index1] = nums[index2]; nums[index2] = temp; } } 力扣215：给定整数数组nums和整数k，请返回数组中第k个最大的元素。请注意，你需要找的是数组排序后的第k个最大的元素，而不是第k个不同的元素。 输入：[3,2,1,5,6,4] 和 k = 2 输出：5 查看解析 class Solution { private final static Random random = new Random(System.currentTimeMillis()); public int findKthLargest(int[] nums, int k) { // 第 1 大的数，下标是 len - 1; // 第 2 大的数，下标是 len - 2; // ... // 第 k 大的数，下标是 len - k; int len = nums.length; int target = len - k; int left = 0; int right = len - 1; while (true) { // 无需使用递归调用栈，通过二分查找的方式即可逐步缩小搜索区间 int pivotIndex = partition(nums, left, right); if (pivotIndex == target) { return nums[pivotIndex]; } else if (pivotIndex &lt; target) { left = pivotIndex + 1; } else { // pivotIndex &gt; target right = pivotIndex - 1; } } } private int partition(int[] nums, int left, int right) { int randomIndex = left + random.nextInt(right - left + 1); swap(nums, left, randomIndex); // all in nums[left + 1..le) &lt;= pivot; // all in nums(ge..right] &gt;= pivot; int pivot = nums[left]; int le = left + 1; int ge = right; while (true) { while (le &lt;= ge &amp;&amp; nums[le] &lt; pivot) { le++; } while (le &lt;= ge &amp;&amp; nums[ge] &gt; pivot) { ge--; } if (le &gt;= ge) { break; } swap (nums, le, ge); le++; ge--; } swap(nums, left, ge); return ge; } private void swap(int[] nums, int index1, int index2) { int temp = nums[index1]; nums[index1] = nums[index2]; nums[index2] = temp; } } 三向切分的快速排序：如果执行partition的子区间当中，有很多元素都和基准元素相等，那么这些元素在这一轮中都被挤到了中间，它们前面的元素都比pivot小，它们后面的元素都比pivot大，因此它们就位于排序以后最终应该在的位置。 public class Solution { private static final Random RANDOM = new Random(); public int[] sortArray(int[] nums) { int len = nums.length; quickSort(nums, 0, len - 1); return nums; } private void quickSort(int[] nums, int left, int right) { if (left &gt;= right) { return; } int randomIndex = left + RANDOM.nextInt(right - left + 1); swap(nums, randomIndex, left); // all in [left + 1, lt] &lt; pivot // all in [lt + 1, i) = pivot // all in [gt, right] &gt; pivot // 因为 i 是循环变量，定义为“遍历之前的元素”更好理解 int pivot = nums[left]; // 如下初始化，可保证遍历开始时三个区间都为空 int lt = left; int gt = right + 1; int i = left + 1; while (i &lt; gt) { if (nums[i] &lt; pivot) { lt++; swap(nums, i, lt); i++; } else if (nums[i] == pivot) { i++; } else { gt--; swap(nums, i, gt); // 此时 i 无需移动，因为交换过来是一个未访问过的元素，需要在下一轮循环中继续判断 } } swap(nums, left, lt); // 注意这里，大大减少了分治的区间，区间 [lt, gt - 1] 不必递归求解 quickSort(nums, left, lt - 1); quickSort(nums, gt, right); } private void swap(int[] nums, int index1, int index2) { int temp = nums[index1]; nums[index1] = nums[index2]; nums[index2] = temp; } } 计数排序对于每一个输入数组的元素，计算严格小于它的元素的个数（前缀和计数数组），进而把它放到输出数组对应的位置上。 public class CountingSort { public void sort(int[] nums) { int len = nums.length; int max = nums[0]; // 检验数据有效性 // 找到数组中的最大值，以确定计数数组的长度 for (int i = 1; i &lt; len; i++) { if (nums[i] &gt; max) { max = nums[i]; } // 数据有效性校验，因为要将数值作为数组 count 的下标使用，因此 nums[i] 不能小于 0 if (nums[i] &lt; 0) { throw new IllegalArgumentException(&quot;该数组不适合使用计数排序&quot;); } } // 第 1 步：对原始数组进行计数，这里将原始数组的值，作为了计数数组的下标 int[] count = new int[max + 1]; // 遍历原始数组，完成计数 for (int i = 0; i &lt; len; i++) { count[nums[i]] += 1; } // 第 2 步：将 count 数组改造成前缀和数组，我们需要的是前缀和，在原地进行变换即可 // 由前缀和数组就可以推出这个元素所在的位置 for (int i = 1; i &lt;= max; i++) { count[i] += count[i - 1]; } // 为了写回去，需要对原始数组做一个拷贝 int[] numsCopy = new int[len]; System.arraycopy(nums, 0, numsCopy, 0, len); // 第 3 步：从后向前扫描，依次把看到的数写回原始数组，从后向前是为了保证稳定性 for (int i = len - 1; i &gt;= 0; i--) { // 位置有一个偏移，在纸上写出来就很容易发现规律 int position = count[numsCopy[i]] - 1; // 把看到的数覆盖回去 nums[position] = numsCopy[i]; // 前缀和减一，作为下一个看到的相同数存放位置的依据 count[numsCopy[i]]--; } } } 基数排序越高位的排序是放在后面进行的，在高位相同的情况下，需要比较次高位，需要比较次高位，而次高位在之前的排序中已经排好序。 public class RadixSort { public void sort(int[] nums) { int len = nums.length; // 第 1 步：找出最大的数字 int max = nums[0]; for (int i = 0; i &lt; len; i++) { if (nums[i] &gt; max) { max = nums[i]; } // 数据有效性校验，因为要将数值作为 count 的索引用，因此 nums[i] 不能小于 0 if (nums[i] &lt; 0) { throw new IllegalArgumentException(&quot;该数组不适合使用计数排序&quot;); } } // 第 2 步：计算出最大的数字有几位，这个数值决定了我们要将整个数组看几遍 int maxLen = getMaxLen(max); // 第 3 步：每一趟都使用计数排序 int[] count = new int[10]; int[] temp = new int[len]; int divisor = 1; // 有几位数，外层循环就得执行几次 for (int i = 0; i &lt; maxLen; i++) { // 每一步都使用计数排序，保证排序结果是稳定的，这一步需要额外空间保存结果集，因此把结果保存在 temp 中 countingSort(nums, temp, divisor, len, count); System.arraycopy(temp, 0, nums, 0, len); divisor *= 10; } } /** * * @param nums 原始数组 * @param temp 在计数排序的过程中使用的辅助数组，这一次基于 divisor 关键字的排序结果存在这里 * @param divisor * @param len 原始数组的长度（冗余变量） * @param count 计数数组 */ private void countingSort(int[] nums, int[] temp, int divisor, int len, int[] count) { // 内层循环得把数组从头到尾看一遍 for (int j = 0; j &lt; len; j++) { // 计算数位上的数是几，先取个位，再十位、百位 int remainder = (nums[j] / divisor) % 10; count[remainder]++; } for (int j = 1; j &lt; 10; j++) { count[j] += count[j - 1]; } for (int j = len - 1; j &gt;= 0; j--) { int remainder = (nums[j] / divisor) % 10; int index = count[remainder] - 1; temp[index] = nums[j]; count[remainder]--; } // 重置数组 count，以便下次使用 for (int j = 0; j &lt; 10; j++) { count[j] = 0; } } /** * 获取一个整数的最大位数 * * @param num * @return */ private int getMaxLen(int num) { int maxLen = 0; while (num &gt; 0) { num /= 10; maxLen++; } return maxLen; } } 桶排序将待排序数组分配到若干个桶内，然后再对每个桶各自执行一次排序任务。桶内的排序可以使用不同的排序方法，每个桶内排序完成以后，依次将每个桶内的元素取出来，最终得到一个有序数组。 public class BucketSort { public void sort(int[] nums) { int len = nums.length; int max = nums[0]; // 第 1 步：找到数组中的最大值，以确定计数数组的长度 for (int i = 1; i &lt; len; i++) { if (nums[i] &gt; max) { max = nums[i]; } // 数据有效性校验，因为要将数值作为 count 的索引用，因此 nums[i] 不能小于 0 if (nums[i] &lt; 0) { throw new IllegalArgumentException(&quot;该数组不适合使用计数排序&quot;); } } // 第 2 步：计算出最大的数字有几位，这个数值决定了桶的个数 int maxLen = getMaxLen(max); // 步长 int step = 1000; // 决定设置几个桶 if (maxLen &lt; 5) { // 如果最大数小于 10000 // 3 位数就设置 100 个桶 // 2 位数就设置 10 个桶 step = (int) Math.pow(10, maxLen - 1); } // System.out.println(&quot;步长：&quot; + step); // 桶的个数 int bucketLen = max / step + 1; // System.out.println(&quot;桶的个数：&quot; + bucketLen); // 因为不能确定每个桶存放的数据量，因此每个桶的长度都设置为 len int[][] temp = new int[bucketLen][len]; int[] next = new int[bucketLen]; // 第 3 步：分桶 for (int i = 0; i &lt; len; i++) { // 找到所在的桶的索引 int bucketIndex = nums[i] / step; // 在该桶中放入元素 temp[bucketIndex][next[bucketIndex]] = nums[i]; // 该桶存放的元素个数 + 1 next[bucketIndex]++; } // 第 4 步：对于每个桶执行插入排序 for (int i = 0; i &lt; bucketLen; i++) { insertionSort(temp[i], next[i] - 1); } // 第 5 步：从桶里依次取出来 int index = 0; for (int i = 0; i &lt; bucketLen; i++) { int curLen = next[i]; for (int j = 0; j &lt; curLen; j++) { nums[index] = temp[i][j]; index++; } } } private void insertionSort(int[] arr, int endIndex) { for (int i = 1; i &lt;= endIndex; i++) { int temp = arr[i]; int j = i; while (j &gt; 0 &amp;&amp; arr[j - 1] &gt; temp) { arr[j] = arr[j - 1]; j--; } arr[j] = temp; } } /** * 获取一个整数的最大位数 * * @param num * @return */ private int getMaxLen(int num) { int maxLen = 0; while (num &gt; 0) { num /= 10; maxLen++; } return maxLen; } } 力扣41：给你一个未排序的整数数组nums，请你找出其中没有出现的最小的正整数。 输入：nums = [1,2,0] 输出：3 查看解析 public class Solution { public int firstMissingPositive(int[] nums) { int len = nums.length; for (int i = 0; i &lt; len; i++) { while (nums[i] &gt; 0 &amp;&amp; nums[i] &lt;= len &amp;&amp; nums[nums[i] - 1] != nums[i]) { // 满足在指定范围内、并且没有放在正确的位置上，才交换 // 例如：数值 3 应该放在索引 2 的位置上 swap(nums, nums[i] - 1, i); } } // [1, -1, 3, 4] for (int i = 0; i &lt; len; i++) { if (nums[i] != i + 1) { return i + 1; } } // 都正确则返回数组长度 + 1 return len + 1; } private void swap(int[] nums, int index1, int index2) { int temp = nums[index1]; nums[index1] = nums[index2]; nums[index2] = temp; } } 力扣287：给定一个包含n + 1个整数的数组nums，其数字都在[1, n]范围内（包括1和n），可知至少存在一个重复的整数。假设nums只有一个重复的整数，返回这个重复的数。 输入：nums = [1,3,4,2,2] 输出：2 查看解析 方法一：二分查找 class Solution { // 定义 cnt[i] 表示 nums 数组中小于等于 i 的数有多少个，cnt[] 数组随数字 i 逐渐增大具有单调性 public int findDuplicate(int[] nums) { int n = nums.length; int l = 1, r = n - 1, ans = -1; while (l &lt;= r) { int mid = (l + r) &gt;&gt; 1; int cnt = 0; for (int i = 0; i &lt; n; ++i) { if (nums[i] &lt;= mid) { cnt++; } } if (cnt &lt;= mid) { l = mid + 1; } else { r = mid - 1; ans = mid; } } return ans; } } 方法二：快慢指针 // 看成是链表，数组下标i是当前节点，nums[i] 是下一个节点，如果成环,按照这种方式遍历链表会无限循环 class Solution { // 当存在多个重复值，也就是多个环时，只会在最小环中无限循环，也就是重复元素第2次出现的位置形成的环，不会走到后面更大的环 public int findDuplicate(int[] nums) { // 因此可以用环形链表的解法来找出环的入口 int slow = 0, fast = 0; do { slow = nums[slow]; fast = nums[nums[fast]]; } while (slow != fast); slow = 0; while (slow != fast) { slow = nums[slow]; fast = nums[fast]; } return slow; } } 最坏时间复杂度 平均时间复杂度 最好时间复杂度 额外空间复杂度 稳定性 是否原地排序 选择排序 O(N2) O(N2) O(N2) O(1) 不稳定 原地排序 堆排序 O(NlogN) O(NlogN) O(NlogN) O(1) 不稳定 原地排序 冒泡排序 O(N2) O(N2) O(N) O(1) 稳定 原地排序 插入排序 O(N2) O(N2) O(N) O(1) 稳定 原地排序 希尔排序 O(N2) O(n1.25)~O(1.6n1.25) (没有相关研究) O(1) 不稳定 原地排序 归并排序 O(NlogN) O(NlogN) O(NlogN) O(N) 稳定 非原地排序 快速排序 O(N2) O(NlogN) O(NlogN) O(logN) 不稳定 原地排序 计数排序 O(N+k) O(N+K) O(N+K) O(N+K) 稳定 非原地排序 基数排序 O(kN) O(KN) O(N2) O(N+K) 稳定 非原地排序 桶排序 O(N2) O(N) O(N) 视情况而定 稳定 非原地排序 .center { width: auto; display: table; margin-left: auto; margin-right: auto; }","categories":[{"name":"生活","slug":"生活","permalink":"http://goodguyjameswin.github.io/categories/生活/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://goodguyjameswin.github.io/tags/学习笔记/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"http://goodguyjameswin.github.io/categories/生活/"}]},{"title":"PaddleOCR","slug":"PaddleOcr","date":"2022-04-20T02:20:57.000Z","updated":"2022-07-18T03:41:39.136Z","comments":false,"path":"2022/04/20/PaddleOcr/","link":"","permalink":"http://goodguyjameswin.github.io/2022/04/20/PaddleOcr/","excerpt":"","text":"简介由于项目需求，直接调用PaddleOCR官方训练好的中英文通用检测识别权重，把检测字符和识别串联的代码结构合并了一下，然后修改了分行的判别机制 原项目 修改前： 修改后： cpu串联推理结合mkldnn设置，速度大概提升了30%","categories":[{"name":"技术","slug":"技术","permalink":"http://goodguyjameswin.github.io/categories/技术/"}],"tags":[{"name":"开源项目","slug":"开源项目","permalink":"http://goodguyjameswin.github.io/tags/开源项目/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://goodguyjameswin.github.io/categories/技术/"}]},{"title":"双指针与滑动窗口","slug":"双指针与滑动窗口","date":"2022-04-18T10:44:18.000Z","updated":"2022-07-18T03:43:57.989Z","comments":false,"path":"2022/04/18/双指针与滑动窗口/","link":"","permalink":"http://goodguyjameswin.github.io/2022/04/18/双指针与滑动窗口/","excerpt":"","text":"滑动窗口滑动窗口算法的两个指针变量的移动方向是相同的，形成了一个窗口在直线上滑动的效果。 力扣3：给定一个字符串s，请你找出其中不含有重复字符的最长字串的长度。 输入：s = “abcabcbb” 输出：3 解释：因为无重复字符的最长字串是 “abc”，所以其长度为 3。 查看解析 public class Solution { // 在遍历的过程中，记录元素出现的位置 public int lengthOfLongestSubstring(String s) { // 重复元素上一次出现的位置很重要 int len = s.length(); if (len &lt; 2) { return len; } // 当做哈希表使用。key：字符的 ASCII 值，value：最新下标，-1 表示当前字符在遍历的时候还未出现过 int[] window = new int[128]; for (int i = 0; i &lt; 128; i++) { window[i] = -1; } char[] charArray = s.toCharArray(); int res = 1; int left = 0; // [left, right) 没有重复元素 for (int right = 0; right &lt; len; right++) { // 当有重复元素出现的时候，只要这个元素之前出现的下标 大于等于 当前滑动窗口左边界的下标，就可以直接跳过来；如果重复元素之前出现的下标 严格小于 当前滑动窗口左边界的下标，左边界不用移动 if (window[charArray[right]] != -1) { left = Math.max(left, window[charArray[right]] + 1); } window[charArray[right]] = right; // 注意理解这里为什么是 + 1 res = Math.max(res, right - left + 1); } return res; } } 力扣76：给你一个字符串s，一个字符串t。返回s中涵盖t所有字符的最小字串。如果s中不存在涵盖t所有字符的字串，则返回空字符串&quot;&quot;。 对于t中重复字符，我们寻找的子字符串中该字符数量必须不少于t中该字符数量 如果s中存在这样的字串，我们保证它是唯一的答案 输入：s = “ADOBECODEBANC”, t = “ABC” 输出：”BANC” 查看解析 public class Solution { public String minWindow(String s, String t) { int[] window = new int[128]; int[] pattern = new int[128]; // 对 t 做频数统计 final int A = &#39;A&#39;; for (Character c : t.toCharArray()) { pattern[c - A]++; } int distance = 0; // 记录 t 中一共有多少个不同的字母 for (int i = 0; i &lt; 128; i++) { if (pattern[i] &gt; 0) { distance++; } } int sLen = s.length(); int start = 0; int left = 0; int right = 0; int match = 0; int minLen = sLen + 1; while (right &lt; sLen) { Character curChar = s.charAt(right); if (pattern[curChar - A] &gt; 0) { window[curChar - A]++; // 只对 t 中出现的字符做统计 if (window[curChar - A] == pattern[curChar - A]) { match++; // 表示滑动窗口内的字符种类与 t 的差距减少了 1 } } right++; while (match == distance) { if (right - left &lt; minLen) { start = left; minLen = right - left; } // 考虑左边界向右边走 Character leftChar = s.charAt(left); if (pattern[leftChar - A] &gt; 0) { window[leftChar - A]--; if (window[leftChar - A] &lt; pattern[leftChar - A]) { match--; } } left++; } } return minLen == sLen + 1 ? &quot;&quot; : s.substring(start, start + minLen); } } 力扣438：给定两个字符串s和p，找到s中所有p的异位词的字串，返回这些子串的起始索引。不考虑答案输出的顺序。异位词指由相同字母重排列形成的字符串（包括相同的字符串）。 输入：s = “cbaebabacd”, p = “abc” 输出：[0,6] 解释：起始索引等于 0 的字串是 “cba”，它是 “abc” 的异位词。起始索引等于 6 的字串是 “bac”，它是 “abc” 的异位词。 查看解析 维护一个长度与字符串p的长度相同的滑动窗口，当窗口中每种字母的数量与字符串p中每种字母的数量相同时，则说明当前窗口为字符串p的异位词。 class Solution { public List&lt;Integer&gt; findAnagrams(String s, String p) { int sLen = s.length(), pLen = p.length(); // 当字符串 s 的长度小于字符串 p 的长度时，字符串 s 中一定不存在字符串 p 的异位词 if (sLen &lt; pLen) { return new ArrayList&lt;Integer&gt;(); } List&lt;Integer&gt; ans = new ArrayList&lt;Integer&gt;(); int[] sCount = new int[26]; int[] pCount = new int[26]; for (int i = 0; i &lt; pLen; ++i) { ++sCount[s.charAt(i) - &#39;a&#39;]; ++pCount[p.charAt(i) - &#39;a&#39;]; } if (Arrays.equals(sCount, pCount)) { ans.add(0); } for (int i = 0; i &lt; sLen - pLen; ++i) { --sCount[s.charAt(i) - &#39;a&#39;]; ++sCount[s.charAt(i + pLen) - &#39;a&#39;]; if (Arrays.equals(sCount, pCount)) { ans.add(i + 1); } } return ans; } } 也可以不分别统计滑动窗口和字符串 p 中每种字母的数量，而是统计滑动窗口和字符串 p 中每种字母数量的差，并引入变量 differ 来记录当前窗口与字符串 p 中数量不同的字母的个数。 class Solution { public List&lt;Integer&gt; findAnagrams(String s, String p) { int sLen = s.length(), pLen = p.length(); if (sLen &lt; pLen) { return new ArrayList&lt;Integer&gt;(); } List&lt;Integer&gt; ans = new ArrayList&lt;Integer&gt;(); int[] count = new int[26]; for (int i = 0; i &lt; pLen; ++i) { ++count[s.charAt(i) - &#39;a&#39;]; --count[p.charAt(i) - &#39;a&#39;]; } int differ = 0; for (int j = 0; j &lt; 26; ++j) { if (count[j] != 0) { ++differ; } } if (differ == 0) { ans.add(0); } for (int i = 0; i &lt; sLen - pLen; ++i) { if (count[s.charAt(i) - &#39;a&#39;] == 1) { // 窗口中字母 s[i] 的数量与字符串 p 中的数量从不同变得相同 --differ; } else if (count[s.charAt(i) - &#39;a&#39;] == 0) { // 窗口中字母 s[i] 的数量与字符串 p 中的数量从相同变得不同 ++differ; } --count[s.charAt(i) - &#39;a&#39;]; if (count[s.charAt(i + pLen) - &#39;a&#39;] == -1) { // 窗口中字母 s[i+pLen] 的数量与字符串 p 中的数量从不同变得相同 --differ; } else if (count[s.charAt(i + pLen) - &#39;a&#39;] == 0) { // 窗口中字母 s[i+pLen] 的数量与字符串 p 中的数量从相同变得不同 ++differ; } ++count[s.charAt(i + pLen) - &#39;a&#39;]; if (differ == 0) { ans.add(i + 1); } } return ans; } } 力扣424：给你一个字符串s和一个整数k。你可以选择字符串中的任一字符，并将其更改为任何其他大写英文字符。该操作最多可执行k次。在执行上述操作后，返回包含相同字母的最长子字符串的长度。 输入：s = “ABAB”, k = 2 输出：4 解释：用两个’A’替换为两个’B’，反之亦然。 查看解析 每次滑动窗口右移，更新右移位置的字符出现的次数，然后尝试用它更新重复字符出现次数的历史最大值，最后我们使用该最大值计算出区间内非最长重复字符的数量，以此判断左指针是否需要右移即可，左边界只须要向右移动一格以后，右边界就又可以开始向右移动了，继续尝试找到更长的目标子串。 class Solution { public int characterReplacement(String s, int k) { int[] num = new int[26]; int n = s.length(); int maxn = 0; int left = 0, right = 0; while (right &lt; n) { num[s.charAt(right) - &#39;A&#39;]++; maxn = Math.max(maxn, num[s.charAt(right) - &#39;A&#39;]); if (right - left + 1 - maxn &gt; k) { num[s.charAt(left) - &#39;A&#39;]--; left++; } right++; } return right - left; } } 双指针双指针的问题，通常是两个变量一头一尾，向着中间移动。 力扣15：给你一个包含n个整数的数组nums，判断nums中是否存在三个元素a, b, c，使得a+b+c=0?请你找出所有和为0且不重复的三元组。答案中不能包含重复的三元组。 输入：nums = [-1,-,1,2,-1,-4] 输出：[[-1,-1,2],[-1,0,1]] 查看解析 public class Solution { public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) { List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); int len = nums.length; if (len &lt; 3) { return res; } // 预处理 Arrays.sort(nums); for (int i = 0; i &lt; len - 2; i++) { // 剪枝 2 if (nums[i] &gt; 0) { break; } // 剪枝 3 if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) { continue; } // 在 [i + 1, len - 1] 区间里查找两数之和为 -nums[i] // 因为有序，因此可以可以把 j 和 k 分别从区间的两端向中间靠拢 // 由此省去一个循环 int target = -nums[i]; int left = i + 1; int right = len - 1; while (left &lt; right) { if (nums[left] + nums[right] &lt; target) { left++; } else if (nums[left] + nums[right] &gt; target) { right--; } else { List&lt;Integer&gt; cur = new ArrayList&lt;&gt;(3); cur.add(nums[i]); cur.add(nums[left]); cur.add(nums[right]); res.add(cur); // 剪枝 1: 找到了一个解以后 while (left &lt; right &amp;&amp; nums[left] == nums[left + 1]) { left++; } while (left &lt; right &amp;&amp; nums[right] == nums[right - 1]) { right--; } left++; right--; } } } return res; } } 力扣42：给定n个非负整数表示每个宽度为1的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。 输入：height = [0,1,0,2,1,0,1,3,2,1,2,1] 输出：6 解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水） 查看解析 public class Solution { // 双指针 public int trap(int[] height) { int len = height.length; // 特判 if (len &lt; 3) { return 0; } int res = 0; int leftMax = height[0]; int rightMax = height[len - 1]; // 注意初值的选取，前面做了特判，因此这里不会越界 // 头和尾都不存雨水 int left = 1; int right = len - 2; // 强调：这里是等于 while (left &lt;= right) { // 调试代码 // System.out.println(&quot;left = &quot; + left + &quot; right = &quot; + right + &quot; leftMax = &quot; + leftMax + &quot; rightMax = &quot; + rightMax+ &quot; res = &quot; + res ); int minVal = Math.min(leftMax, rightMax); if (minVal == leftMax) { if (minVal &gt; height[left]) { res += minVal - height[left]; } leftMax = Math.max(leftMax, height[left]); left++; } else { if (minVal &gt; height[right]) { res += minVal - height[right]; } rightMax = Math.max(rightMax, height[right]); right--; } } return res; } } .center { width: auto; display: table; margin-left: auto; margin-right: auto; }","categories":[{"name":"生活","slug":"生活","permalink":"http://goodguyjameswin.github.io/categories/生活/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://goodguyjameswin.github.io/tags/学习笔记/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"http://goodguyjameswin.github.io/categories/生活/"}]},{"title":"二分查找","slug":"二分查找","date":"2022-04-15T14:15:01.000Z","updated":"2022-07-03T09:50:25.017Z","comments":false,"path":"2022/04/15/二分查找/","link":"","permalink":"http://goodguyjameswin.github.io/2022/04/15/二分查找/","excerpt":"","text":"排除法二分下标// 排除法实现二分查找 public class Solution { public int search(int[] nums, int target) { int len = nums.length; int left = 0; int right = len - 1; // 目标元素可能存在在区间 [left, right] while (left &lt; right) { int mid = left + (right - left) / 2; if (nums[mid] &lt; target) { // 下一轮搜索区间是 [mid + 1, right] left = mid + 1; } else { // 下一轮搜索区间是 [left, mid] right = mid; } // int mid = left + (right - left + 1) / 2; // if (nums[mid] &gt; target) { // // 下一轮搜索区间是 [left, mid - 1] // right = mid - 1; // } else { // // 下一轮搜索区间是 [mid, right] // left = mid; // } } if (nums[left] == target) { return left; } return -1; } } 力扣34：给你一个按照非递减顺序排列的整数数组nums，和一个目标值target。请你找出给定目标值在数组中的开始位置和结束位置。如果数组中不存在目标值target，返回[-1, -1]。 输入：nums = [5,7,7,8,8,10]，target = 8 输出：[3,4] 查看解析 public class Solution { public int[] searchRange(int[] nums, int target) { int len = nums.length; if (len == 0) { return new int[]{-1, -1}; } int firstPosition = searchFirstPosition(nums, target); if (firstPosition == -1) { return new int[]{-1, -1}; } // 能走到这里，一定是数组中存在目标元素 int lastPosition = searchLastPosition(nums, target); return new int[]{firstPosition, lastPosition}; } private int searchLastPosition(int[] nums, int target) { int left = 0; int right = nums.length - 1; while (left &lt; right) { int mid = (left + right + 1) / 2; if (nums[mid] &gt; target) { // mid 以及 mid 的右边一定不是目标元素最后一次出现的位置 // 下一轮搜索的区间是 [left, mid - 1] right = mid - 1; } else { // 下一轮搜索的区间是 [mid, right] left = mid; } } return left; } private int searchFirstPosition(int[] nums, int target) { int left = 0; int right = nums.length - 1; while (left &lt; right) { int mid = (left + right) / 2; if (nums[mid] &lt; target) { // mid 以及 mid 的左边一定不是目标元素第 1 次出现的位置 // 下一轮搜索的区间是 [mid + 1, right] left = mid + 1; } else { // 下一轮搜索的区间是 [left, mid] right = mid; } } if (nums[left] == target) { return left; } return -1; } } 力扣153：已知一个长度为n的数组，预先按照升序排列，经由1到n次旋转后，得到输入数组。例如，原数组nums = [0,1,2,4,5,6,7]在变化后可能得到： 若旋转4次，则可以得到[4,5,6,7,0,1,2] 若旋转7次，则可以得到[0,1,2,4,5,6,7] 注意，数组[a[0], a[1], a[2], ..., a[n-1]]旋转一次 的结果为数组[a[n-1], a[0], a[1], a[2], ..., a[n-2]]给你一个元素值互不相同的数组nums，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的最小元素。 输入：nums = [3,4,5,1,2] 输出：1 解释：原数组为 [1,2,3,4,5]，旋转3次得到输入数组。 查看解析 class Solution { public int findMin(int[] nums) { int low = 0; int high = nums.length - 1; while (low &lt; high) { int pivot = low + (high - low) / 2; // 说明 nums[pivot] 是最小值右侧的元素，因此可以忽略二分查找区间的右半部分 if (nums[pivot] &lt; nums[high]) { high = pivot; } else { // 说明 nums[pivot] 是最小值左侧的元素，因此可以忽略二分查找区间的左半部分 low = pivot + 1; } } return nums[low]; } } 若数组中可能存在重复元素，需要单独讨论： class Solution { public int findMin(int[] nums) { int low = 0; int high = nums.length - 1; while (low &lt; high) { int pivot = low + (high - low) / 2; if (nums[pivot] &lt; nums[high]) { high = pivot; } else if (nums[pivot] &gt; nums[high]) { low = pivot + 1; } else { high -= 1; // 由于 nums[pivot] == nums[high]，因此可以忽略二分查找区间的右端点 } } return nums[low]; } } 力扣33：搜索旋转排序数组 输入：nums = [4,5,6,7,0,1,2]，target = 0 输出：4 查看解析 class Solution { public int search(int[] nums, int target) { int n = nums.length; if (n == 0) { return -1; } if (n == 1) { return nums[0] == target ? 0 : -1; } int l = 0, r = n - 1; while (l &lt;= r) { int mid = (l + r) / 2; if (nums[mid] == target) { return mid; } if (nums[0] &lt;= nums[mid]) { if (nums[0] &lt;= target &amp;&amp; target &lt; nums[mid]) { r = mid - 1; } else { l = mid + 1; } } else { if (nums[mid] &lt; target &amp;&amp; target &lt;= nums[n - 1]) { l = mid + 1; } else { r = mid - 1; } } } return -1; } } 若数组中可能存在重复元素，需要单独讨论： class Solution { public boolean search(int[] nums, int target) { int n = nums.length; if (n == 0) { return false; } if (n == 1) { return nums[0] == target; } int l = 0, r = n - 1; while (l &lt;= r) { int mid = (l + r) / 2; if (nums[mid] == target) { return true; } // 此时可以将当前二分区间的左边界加一，有边界减一，然后在新区间上继续二分查找 if (nums[l] == nums[mid] &amp;&amp; nums[mid] == nums[r]) { ++l; --r; } else if (nums[l] &lt;= nums[mid]) { if (nums[l] &lt;= target &amp;&amp; target &lt; nums[mid]) { r = mid - 1; } else { l = mid + 1; } } else { if (nums[mid] &lt; target &amp;&amp; target &lt;= nums[n - 1]) { l = mid + 1; } else { r = mid - 1; } } } return false; } } 力扣1095：给定一个山脉数组moutainArr，请你返回能够使得mountainArr.get(index)等于target最小的下标index值。如果不存在这样的下标index，则返回-1。 如果数组A是一个山脉数组的话，那它满足如下条件：首先，A.length &gt;= 3，其次，在0 &lt; i &lt; A.length - 1条件下，存在i使得： A[0] &lt; A[1] &lt; … A[i-1] &lt; A[i] A[i] &gt; A[i+1] &gt; … &gt; A[A.length - 1] 你将不能直接访问该山脉数组，必须通过MountainArray接口来获取数据： MountainArray.get(k) - 会返回数组中索引为k的元素（下标从0开始） MountainArray.length() - 会返回该数组的长度 输入：array = [1,2,3,4,5,3,1], target = 3 输出：2 解释：3 在数组中出现了两次，下标分别为 2 和 5，我们返回最小的下标 2。 查看解析 class Solution { public int findInMountainArray(int target, MountainArray mountainArr) { int l = 0, r = mountainArr.length() - 1; // 先寻找“山峰” while (l &lt; r) { int mid = (l + r) / 2; if (mountainArr.get(mid) &lt; mountainArr.get(mid + 1)) { l = mid + 1; } else { r = mid; } } int peak = l; // 山峰两侧即为有序数组，可直接进行二分查找 int index = binarySearch(mountainArr, target, 0, peak, true); if (index != -1) { return index; } return binarySearch(mountainArr, target, peak + 1, mountainArr.length() - 1, false); } public int binarySearch(MountainArray mountainArr, int target, int l, int r, boolean flag) { if (!flag) { target *= -1; } while (l &lt;= r) { int mid = (l + r) / 2; int cur = mountainArr.get(mid) * (flag ? 1 : -1); if (cur == target) { return mid; } else if (cur &lt; target) { l = mid + 1; } else { r = mid - 1; } } return -1; } } 力扣4：给定两个大小分别为m和n的正序（从小到大）数组nums1和nums2。请你找出并返回这两个正序数组的中位数。 输入：nums1 = [1,3], nums2 = [2] 输出：2.00000 解释：合并数组 = [1,2,3], 中位数 2 查看解析 class Solution { public double findMedianSortedArrays(int[] nums1, int[] nums2) { int length1 = nums1.length, length2 = nums2.length; int totalLength = length1 + length2; if (totalLength % 2 == 1) { int midIndex = totalLength / 2; double median = getKthElement(nums1, nums2, midIndex + 1); return median; } else { int midIndex1 = totalLength / 2 - 1, midIndex2 = totalLength / 2; double median = (getKthElement(nums1, nums2, midIndex1 + 1) + getKthElement(nums1, nums2, midIndex2 + 1)) / 2.0; return median; } } public int getKthElement(int[] nums1, int[] nums2, int k) { /* 要找到第 k (k&gt;1) 小的元素，那么就取 pivot1 = nums1[k/2-1] 和 pivot2 = nums2[k/2-1] 进行比较 * 这里的 &quot;/&quot; 表示整除 * nums1 中小于等于 pivot1 的元素有 nums1[0 .. k/2-2] 共计 k/2-1 个 * nums2 中小于等于 pivot2 的元素有 nums2[0 .. k/2-2] 共计 k/2-1 个 * 取 pivot = min(pivot1, pivot2)，两个数组中小于等于 pivot 的元素共计不会超过 (k/2-1) + (k/2-1) &lt;= k-2 个 * 这样 pivot 本身最大也只能是第 k-1 小的元素 * 如果 pivot = pivot1，那么 nums1[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 &quot;删除&quot;，剩下的作为新的 nums1 数组 * 如果 pivot = pivot2，那么 nums2[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 &quot;删除&quot;，剩下的作为新的 nums2 数组 * 由于我们 &quot;删除&quot; 了一些元素（这些元素都比第 k 小的元素要小），因此需要修改 k 的值，减去删除的数的个数 */ int length1 = nums1.length, length2 = nums2.length; int index1 = 0, index2 = 0; int kthElement = 0; while (true) { // 边界情况 if (index1 == length1) { return nums2[index2 + k - 1]; } if (index2 == length2) { return nums1[index1 + k - 1]; } if (k == 1) { return Math.min(nums1[index1], nums2[index2]); } // 正常情况 int half = k / 2; int newIndex1 = Math.min(index1 + half, length1) - 1; int newIndex2 = Math.min(index2 + half, length2) - 1; int pivot1 = nums1[newIndex1], pivot2 = nums2[newIndex2]; if (pivot1 &lt;= pivot2) { k -= (newIndex1 - index1 + 1); index1 = newIndex1 + 1; } else { k -= (newIndex2 - index2 + 1); index2 = newIndex2 + 1; } } } } 二分答案如果题目要求一个整数，并且知晓这个整数它可能的最小值和最大值时，可以考虑使用二分查找算法找到这个目标值。 力扣1300：给你一个整数数组arr和一个目标值target，请你返回一个整数value，使得将数组中所有大于value的值变成value后，数组的和最接近target（最接近表示两者之差的绝对值最小）。 如果有多种使得和最接近target的方案，请你返回这些整数中的最小值。 请注意，答案不一定是arr中的数字。 输入：arr = [4,9,3], target = 10 输出：3 解释：当选择 value 为 3 时，数组会变成 [3,3,3]，和为 9，这是最接近 target 的方案。 查看解析 class Solution { public int findBestValue(int[] arr, int target) { Arrays.sort(arr); int n = arr.length; int[] prefix = new int[n + 1]; for (int i = 1; i &lt;= n; ++i) { prefix[i] = prefix[i - 1] + arr[i - 1]; } int l = 0, r = arr[n - 1], ans = -1; while (l &lt;= r) { int mid = (l + r) / 2; int index = Arrays.binarySearch(arr, mid); if (index &lt; 0) { index = -index - 1; } int cur = prefix[index] + (n - index) * mid; if (cur &lt;= target) { ans = mid; l = mid + 1; } else { r = mid - 1; } } // 在 [0,max(arr)] 的范围之内，随着 value 的增大，数组的和是严格单调递增的，因此可以通过二分查找的方式找到最接近且不大于 target 和最接近且大于 target 的两个数，显然后者等于前者加一，取两者中最接近 target 的值即为答案 int chooseSmall = check(arr, ans); int chooseBig = check(arr, ans + 1); return Math.abs(chooseSmall - target) &lt;= Math.abs(chooseBig - target) ? ans : ans + 1; } public int check(int[] arr, int x) { int ret = 0; for (int num : arr) { ret += Math.min(num, x); } return ret; } } 还有一类问题是根据目标变量具有的单调性质编写判别函数。目标变量和另一个变量有相关关系（一般而言是线性关系），目标变量的性质不好推测，但是另一个变量的性质相对容易推测。这样的问题的判别函数通常会写成一个函数的形式。 力扣410：给定一个非负整数数组nums和一个整数m，你需要将这个数组分成m个非空的连续子数组。 设计一个算法使得这m个子数组各自和的最大值最小。 输入：nums = [7,2,5,10,8], m = 2 输出：18 解释：一共有四种方法将 nums 分割为 2 个子数组。其中最好的方式是将其分为 [7,2,5] 和 [10,8]。因为此时这两个子数组各自的和的最大值为 18，在所有情况中最小。 查看解析 public class Solution { public int splitArray(int[] nums, int m) { int max = 0; int sum = 0; // 计算「子数组各自的和的最大值」的上下界 for (int num : nums) { max = Math.max(max, num); sum += num; } // 使用「二分查找」确定一个恰当的「子数组各自的和的最大值」，使得它对应的「子数组的分割数」恰好等于 m int left = max; int right = sum; while (left &lt; right) { int mid = left + (right - left) / 2; int splits = split(nums, mid); if (splits &gt; m) { // 如果分割数太多，说明「子数组各自的和的最大值」太小，此时需要将「子数组各自的和的最大值」调大 // 下一轮搜索的区间是 [mid + 1, right] left = mid + 1; } else { // 下一轮搜索的区间是上一轮的反面区间 [left, mid] right = mid; } } return left; } /*** * * @param nums 原始数组 * @param maxIntervalSum 子数组各自的和的最大值 * @return 满足不超过「子数组各自的和的最大值」的分割数 */ private int split(int[] nums, int maxIntervalSum) { // 至少是一个分割 int splits = 1; // 当前区间的和 int curIntervalSum = 0; for (int num : nums) { // 尝试加上当前遍历的这个数，如果加上去超过了「子数组各自的和的最大值」，就不加这个数，另起炉灶 if (curIntervalSum + num &gt; maxIntervalSum) { curIntervalSum = 0; splits++; } curIntervalSum += num; } return splits; } } .center { width: auto; display: table; margin-left: auto; margin-right: auto; }","categories":[{"name":"思维","slug":"思维","permalink":"http://goodguyjameswin.github.io/categories/思维/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://goodguyjameswin.github.io/tags/学习笔记/"}],"keywords":[{"name":"思维","slug":"思维","permalink":"http://goodguyjameswin.github.io/categories/思维/"}]},{"title":"text_generator","slug":"text-generator","date":"2022-04-12T04:37:14.000Z","updated":"2022-07-18T03:56:18.986Z","comments":false,"path":"2022/04/12/text-generator/","link":"","permalink":"http://goodguyjameswin.github.io/2022/04/12/text-generator/","excerpt":"","text":"引言用pillow的ImageFont模块去生成可供ocr模型训练的文本检测和识别训练数据，原项目暂时没找到。。 修改引入背景roi 就像上面这张图，有时候场景文本检测和识别任务中，文字只会出现在场景图片特定的语义区域中。因此在制作文本数据时，就需要限定文本出现的范围 调用opencv-python里的api： import cv2 class UseCv: def __init__(self): self.path = &#39;bg.jpg&#39; def cut(self): img = cv2.imread(self.path, flags=cv2.IMREAD_COLOR) bbox = cv2.selectROI(img, False) cut = img[bbox[1]:bbox[1] + bbox[3], bbox[0]:bbox[0] + bbox[2]] cv2.imwrite(&#39;bg_cut.jpg&#39;, cut) 更改： self.roi = cv2.selectROI(cv2.imread(self.bg, 1), False) if x + w &gt; (self.roi[0] + self.roi[2] - 10) or y + h &gt; (self.roi[1]+ self.roi[3] - 10): return draw, (w, h), False tl_x = random.randrange(self.roi[0], self.roi[0] + self.roi[2]) # 字体位置 tl_y = random.randrange(self.roi[1], self.roi[1] + self.roi[3]) 使用命令行调用生成语料： 9CHCAV1 6TXYQ WNVKWX 9OMKKCM5Y X4EPT1J- 9ZG4GB HUTTQRF KDB6TFFP 1ZNKT45E ULR26VPJE 选择roi 运行 结果","categories":[{"name":"技术","slug":"技术","permalink":"http://goodguyjameswin.github.io/categories/技术/"}],"tags":[{"name":"开源项目","slug":"开源项目","permalink":"http://goodguyjameswin.github.io/tags/开源项目/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://goodguyjameswin.github.io/categories/技术/"}]},{"title":"yolo_icdar","slug":"yolo_icdar","date":"2022-04-10T12:30:01.000Z","updated":"2022-07-18T03:40:24.305Z","comments":false,"path":"2022/04/10/yolo_icdar/","link":"","permalink":"http://goodguyjameswin.github.io/2022/04/10/yolo_icdar/","excerpt":"","text":"引言第一篇文章（水文）！研一参与的第一个项目，用yolo来检测（识别）图片中的喷码字符，然后很长一段时间都在给数据打标签 问题在于用yolo去做逐字符的检测，输出的框顺序并不像我们所认知的那样，分行排列，从上至下，从左至右 yolo格式标签&lt;object-class&gt; &lt;x&gt; &lt;y&gt; &lt;width&gt; &lt;height&gt; x，y是检测框的中心坐标；width，height是检测框的宽和高。这些坐标是通过归一化的，其中x，width是使用原图的width进行归一化；而y，height是使用原图的height进行归一化 icdar格式标签path/to/img [{&quot;transcription&quot;: &quot;content&quot;, &quot;points&quot;: [[x1, y1], [x2, y2], [x3, y3], [x4, y4]]}, {...}] 标签是包含多个字典的list，字典中的 points 表示文本框的四个点的坐标(x, y)，从左上角的点开始顺时针排列。 transcription 表示当前文本框的内容 实现把问题转换为对yolo输出检测框的排序。已知量是每个检测框的横、纵坐标，思路是先把所有检测框按纵坐标分成不同行，每行再按横坐标排序 原先的项目数据里，待识别的图片样式基本不变，可以直接在界面里设置每行文本的字符个数，当时的代码就是直接根据这一条件来对检测框排序。然后就检测条形码和二维码去了 后来项目的数据样式变多了，感觉原来的方法行不通了，最近在用paddleocr做文本识别，需要把以前训练yolo的一些数据标签转成icdar格式，所以又要重新面对这个yolo检测框的排序问题，那就趁着这个机会把代码写清楚 自然断点法a = np.array([5, 35, 38, 41, 65, 68, 98, 99, 100, 99, 105, 106, 102, 104, 103, 100, 110, 69, 64, 70, 75, 71, 73, 72, 42, 46, 40, 36, 37, 6, 8, 11, 4, 15, 10, 9, 4, 8, 135]) 思路还是先把检测框按纵坐标分行，想了半天，放弃 后来在pycharm里边写代码边debug，发现对数组View as Array的时候有个Colored cells选项，可以把一维数组分块，联想到yolo检测框按纵坐标分行，然后上网去搜有没有一维数组的聚类方法 发现可以用python的机器学习算法库里一个叫核密度估计的方法，实现对多维数据分布规律的曲线模拟。那把一维数组扩充到多维不就好了？（大材小用），搜了下这个库的调用方法 a = np.array([5, 35, 38, 41, 65, 68, 98, 99, 100, 99, 105, 106, 102, 104, 103, 100, 110, 69, 64, 70, 75, 71, 73, 72, 42, 46, 40, 36, 37, 6, 8, 11, 4, 15, 10, 9, 4, 8, 135]).reshape(-1, 1) kde = KernelDensity(kernel=&#39;gaussian&#39;, bandwidth=3).fit(a[:, 0].reshape(-1, 1)) # 构造指定数据的核密度估计 s = np.linspace(0, 140) e = kde.score_samples(s.reshape(-1, 1)) # 在特定数据上用核函数拟合 观察了下拟合出来的曲线，确实求个极值就可以找到断点了 mi, ma = argrelextrema(e, np.less)[0], argrelextrema(e, np.greater)[0] # 计算数组指定轴的相对极值 Minima: [25.71428571 54.28571429 85.71428571 122.85714286] Maxima: [8.57142857 37.14285714 71.42857143 100. 134.28571429] 然后根据断点把一维数组分块，还行 [5 6 8 11 4 15 10 9 4 8] [35 38 41 42 46 40 36 37] [65 68 69 64 70 75 71 73 72] [98 99 100 99 105 106 102 104 103 100 110] [135] 后话最后整合到标签转换脚本里去，转换速度还行。。吧 这样就可以用上学长的data_maker了哈哈哈 虽然我个人倾向于用python的pillow库函数ImageFont来制作字符数据，但是喷码样式的字体文件着实不好搞，字符贴图的背景区域定位那块代码也一直想吐槽，之后抽个时间优化下吧，顺便再水一篇文章","categories":[{"name":"技术","slug":"技术","permalink":"http://goodguyjameswin.github.io/categories/技术/"}],"tags":[{"name":"开源项目","slug":"开源项目","permalink":"http://goodguyjameswin.github.io/tags/开源项目/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://goodguyjameswin.github.io/categories/技术/"}]}]}